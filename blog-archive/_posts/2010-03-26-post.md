*Nendo* 多値の実装完了 
私がRubyで書いているLisp方言、 *[Nendo*]について。

多値が動いた。(参考リンク: *[http://practical-scheme.net/wiliki/wiliki.cgi?Scheme%3A%E5%A4%9A%E5%80%A4|Scheme:多値*])
Chatonでつぶやいたら、さっそくShiroさんが答えて下さった。

 *[http://practical-scheme.net/chaton/gauche/a/2010/03/24#entry-4baa20ec-37241|Gauche > Archives > 2010/03/24*] 周辺のログを抜粋
 kiyokaの質問
  オレLisp処理系Nendoに多値を組み込みたいけど、どうやったらいいのか悩み中です。
  ちなみにNendoは継続とかサポートしていません。
  巷のSchemeライブラリのソースを流用したいことが多いので、できれば values と receive がそのまま動けばうれしいのですが...
 shiroさんからの回答
  >kiyoka 性能を考えないなら、guileがやってたように0個と2個以上の値を特別なオブジェクトにパックしてしまうってのでとりあえず動かすことはできますよ。
  受け取る値の個数を間違えた場合にその内部的な「多値オブジェクト」が見えてしまう、というのがちょっと残念ですが。
  (define (values . args) (match args *(val) val* *_ (make-values args)*))
  (define (call-with-values producer consumer) (let ((v (producer))) (if (values? v) (apply consumer (values-values v)) (consumer v))))
  多値オブジェクトは make-values で作成、values? で判断、 values-valuesで値リスト取り出し、と想定。
  (define-syntax receive (syntax-rules () ((receive vars expr body ...) (call-with-values (lambda () expr) (lambda vars body ...)))))

ほぼshiroさんの回答通り実装してみた。
残念ながら*[Nendo*]には match と define-syntax がまだ装備されていないので、別の手段で実装してある。
make-values、values?、values-values は Rubyで書いてある。

- ソースコード
!(define (values . args)
!  (case (length args)
!    ((1)
!     (car args))
!    (else
!     (make-values args))))
!
!(define (call-with-values producer consumer)
!  (let ((v (producer)))
!    (if (values? v)
!        (apply consumer (values-values v))
!        (consumer v))))
!
!;; srfi-8
!(define receive
!  (macro (vars expr . body)
!    `(call-with-values
!         (lambda () ,expr)
!       (lambda ,vars ,@body))))

- 実行結果
-- R5RSの仕様書に書いてある例
!nendo> (call-with-values
!            (lambda () (values 4 5))
!          (lambda (a b) b))
 => 5

!nendo> (call-with-values * -)
 => -1

-- その他
!nendo> (call-with-values
!            (lambda () (values 1 2))
!          cons)
 => (1 . 2)

!nendo> (call-with-values
!            (lambda () (values 10))
!          list)
 => (10)

!nendo> (receive all       (values)           all)
 => ()
この結果は実装依存だと思うが、Gauche 0.9と同じ動作になっている。

!nendo> (receive (a . b)   (values 10 20 30)  (list a b))
 => (10 (20 30))

これで、Gaucheのtext.html-liteのポーティング準備が一歩前進した。
後は、keyword関連と list* を実装したら簡単にポーティング出来るんじゃないかと。
この作業のゴールとしては、Sinatraのページ記述用プラグインとしてhamlとかerb等があるが、その一つとしてS式でもページが書けることを狙っている。(Sinatraのソースを読んだら、プラグイン追加するためには、パッチを当てないとダメっぽいが...)
とりあえずの中間地点として、まずS式でCGIが書ける段階を目指そう。

##(comment-data shiro list%2a%e3%81%af%e7%b0%a1%e5%8d%98%e3%81%a7%e3%81%99%e3%82%88%e3%80%82%20%28define%20%28list%2a%20arg%20.%20args%29%20%28if%20%28null%3f%20args%29%20arg%20%28cons%20arg%20%28apply%20list%2a%20args%29%29%29%29%0d%0a)
##(comment-data kiyoka list%2a%20%e3%81%ae%e5%ae%9a%e7%be%a9%e3%81%af%e7%b0%a1%e5%8d%98%e3%81%aa%e3%82%93%e3%81%a7%e3%81%99%e3%81%ad%e3%83%bc%e3%80%82%e3%81%82%e3%82%8a%e3%81%8c%e3%81%a8%e3%81%86%e3%81%94%e3%81%96%e3%81%84%e3%81%be%e3%81%99%e3%80%82%0d%0a%e4%b8%8a%e8%a8%98%e3%82%b3%e3%83%bc%e3%83%89%e3%81%8cNendo%e3%81%a7%e3%82%82%e5%8b%95%e3%81%8d%e3%81%be%e3%81%97%e3%81%9f%e3%80%82%0d%0a%0d%0anendo%3e%20%28list%2a%201%29%0d%0a%3d%3e%201%0d%0anendo%3e%20%28list%2a%201%202%203%204%29%0d%0a%3d%3e%20%281%202%203%20.%204%29%0d%0a)
