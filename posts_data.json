[
  {
    "id": "2004-07-12-post",
    "title": "ノーム・チョムスキーの「生成文法の企て」を読む。",
    "date": "2004-07-12",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2004-07-12-post.md",
    "content": "コンパイラやコンパイラコンパイラの本を読むと出てくる名前なんだけど、今回初めてこの人の本を読むことになった。この本は対談形式の本なんだけど、研究者というのは幅広い知見が求められてたいへんなんだなと感じた。僕は、エンジニアなので残念ながらウマみだけをエンジニアリングに利用させてもらうぞ。そのウマみだけ抽出できるかどうか、いろんな本を読み込み中。",
    "url": "/2004/7/12/2004-07-12-post/"
  },
  {
    "id": "2004-07-14-post",
    "title": "Olegさん([Olegさんのサイトはこちら)](http://okmij.org/ftp/README.html)よりメールをもらう。",
    "date": "2004-07-14",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2004-07-14-post.md",
    "content": "いつも僕のようなへっぽこプログラマの相手をしていただいてありがたく思う。メールの趣旨は、最近Lisp/Schemeの価値が少しずつ理解されてきたという内容。ボストンのUsenixコンファレンスでSXMLを銀行のトランザクションとして使おうとしている人と話をしたこと、有名なNetBSDカーネルハッカーと話をして、その人はLisp/Schemeの価値に気\nづいていることなど。(Olegさんも十分有名人なんですけどね)。こんなメールを頂けるなんて、オープンソースに携わっている身としてはうれしい限りである。今後も微力ながら役に立つも\nのを作っていきたい。(僕の場合、アイデア一発物ばっかりなんだけどね。）",
    "url": "/2004/7/14/2004-07-14-post/"
  },
  {
    "id": "2004-07-22-post",
    "title": "宣言型言語",
    "date": "2004-07-22",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2004-07-22-post.md",
    "content": "C言語やPerlなどが手続き型言語だと定義すると、SQLは宣言型言語だといえると思う。宣言型言語は、適用できる範囲が限定される代わりに、いざ目的にぴったりマッチした場合は少ない記述量でものすごい仕事をする。最近SQLを使うことがぼちぼち出てきてそう感じる。ちなみに、もちろん僕の好きなLisp/Schemeも宣言型言語の側面が大きい（関数型言語の特徴でもあるかも）。再起的定義をたくさん使ったプログラムはもろ宣言的だ。反対に、手続き型的な記述も可能だ。ちゅうわけで、今のところSQLとSchemeでWebプログラミングを行うとすごく強力なコードが短く書けるので気に入っている。",
    "url": "/2004/7/22/2004-07-22-post/"
  },
  {
    "id": "2004-08-30-post",
    "title": "デッドラインを読む",
    "date": "2004-08-30",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2004-08-30-post.md",
    "content": "内容については結構楽しめました。少し簡単すぎるほど、鮮かに問題が解決してしまうところがいくつもあって、あんまり苦労らしい苦労が無い物語になっている。なので、小説としてはちょっと物足りない部分はある。もうちょっと「ザ・ゴール」のように、成功するまで多難な感じが欲しかったが、ノウハウ本として考えるとこれでいいのかもしれない。どちらにしてもデマルコらしい内容なので、デマルコファンは一読をお勧めする。",
    "url": "/2004/8/30/2004-08-30-post/"
  },
  {
    "id": "2004-09-21-post",
    "title": "[Lisp プログラマのための Python 入門](http://www.unixuser.org/~euske/doc/python/python-lisp-j.html)",
    "date": "2004-09-21",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2004-09-21-post.md",
    "content": "Lisp プログラマのための Python 入門\nにわか Schemer かつ Emacs Lisper なのですが、この記事を読んで、Pythonもやってみたくなりました。最近、趣味プログラミングではGauche ばかり使うようになったんですが、仕事ではPHPを使うことが増えていきそうな感じです。最近、Perl,Ruby,Gauche,Java を順に切替えて使っていくとそれぞれの良さが分かって来て、TPOで言語を選択できるようになってきました。また、いろんな人がいろんな言語を選択するので仕方なく全ての言語を習得する必要があった感じもあります。個の程度の数の言語であれば、混乱無く使えますがこれ以上増えると大変似なるので、Python をやるのはもうちょっとしてからかな。\n普通のやつらの上を行け\nこのエッセイを読んでLispを本格的に始めたのですが、やりこむと、このエッセイで言っていることが実感として分かってきました。 Gauche をやる前は、PerlとRubyをやってきましたが、今の所 Gaucheが一番パワーがあると感じています。ここでいうパワーとは、同じことをやる場合になるべく少ない行数で書けた方がよりパワーがあるという意味で使っています。あと、Lisp系言語で書くと、バグが出にくいと感じるのはなぜでしょうか。関数型言語で宣言的にコードが書けるという性質が効いているのでしょうか。そんな気がしています。",
    "url": "/2004/9/21/2004-09-21-post/"
  },
  {
    "id": "2004-11-20-post",
    "title": "[Kinesis](http://www.kinesis-ergo.com/)を買う",
    "date": "2004-11-20",
    "categories": [
      "コンピュータ"
    ],
    "file_path": "_posts/2004-11-20-post.md",
    "content": "遂にキーボード入力へのこだわりが高じて、このような廃人的キーボードを買ってしまいました。\n Kinesis \n\nKinesis を持っている人のサイトをいろいろ見てみると、いろんなキーボードを買って行くうちに、とうとうここにたどり着いてしまうみたいです。僕も遂にたどり着いてしまいました。１週間使ってみましたが、なんか最終目的地にたどり着いたような使用感があります。これまで、Happy Hacking や Microsoft Natural Keyboard などを試しましたが。Kinesisは他と比べものにならないくらい考えられています。まず、全てのキーが自然な位置にあり、ほとんどのキーに最小距離で届きます。横着者のコタツ生活を彷彿とさせる横着キーボード生活です。普段僕は、マウスをほとんど使いませんが、これでますますマウスを使わない生活が続きそうです。",
    "url": "/2004/11/20/2004-11-20-post/"
  },
  {
    "id": "2005-01-05-post",
    "title": "オープンソース参加を経済の言葉で考える",
    "date": "2005-01-05",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2005-01-05-post.md",
    "content": "少しばかりオープンソースの世界に参加してきた僕の経験をもとに、オープンソースの世界に参加する場合のコツをお教えします。ポイントは投資と回収のバランスです。オープンソースに参加するには自分の使った時間または満足度が黒字化しているかどうかに思いを巡らせながら活動すると幸せな生活が送れるんじゃないかと思います。投資とは、日頃あなたが使用するソフトウェアを改善するために使う労力です。回収とは、そのソフトウェアを使って得られた生産性や満足度ということになります。もし、それが黒字化していればあなたは幸せでしょう。\n一般にオープンソース開発やバグフィックス・テスト等はボランティアといわれますが、上記の用にコストとベネフィットという考え方に置き換えれば、開発者は受益者でもあるといえます。また、無数のオープンソースソフトウェアを大きなポートフォリオと考えるなら、一部のソフトウェアに投資して、別のソフトウェアから回収しても良いでしょう。問題は、「フリーライダー」と呼ばれる人々です。この人達は投資を行っていないにもかかわらず、先に利益だけを得ようとしています。人にもよりますが、これは精神衛生上幸せではないでしょう。ちょうどいい黒字バランスが幸せを生むのだと僕は考えます。",
    "url": "/2005/1/5/2005-01-05-post/"
  },
  {
    "id": "2005-01-10-post",
    "title": "No config is good config",
    "date": "2005-01-10",
    "categories": [
      "デザインポリシー"
    ],
    "file_path": "_posts/2005-01-10-post.md",
    "content": "直訳すると『設定が無いのが良い設定』という意味ですね。意訳すると『設定不要なモノが良いデザイン』でしょうか。\nこのポリシーは、自分の作ったソフトウェアをなるべく多くの人に試して欲しいと思っている人には重要なポイントになると思います。ポチさんところで知りました。高林さんが発信されているポリシーはいつも参考になります。\n最近、有名タブブラウザSleipnirの作者の方とお話させていただいたのですが、彼もこのデザインポリシーの信奉者であることが伺えました。技術に明るくないユーザーにも使ってもらうとなると、特に重要になるのは当然ですね。\nそういえば、以前僕がPRIMEを試してみようと思った時に、インストールが面倒だったので、試すのを躊躇したことを思い出しました。\n本 \nまだちゃんと見ていませんが、楽しいことができそうです。Sumibiと組み合わせると面白いことができたりして。 \nちなみに将来 Sumibiも Google APIのように SOAPによるAPIを提供することを考えています。",
    "url": "/2005/1/10/2005-01-10-post/"
  },
  {
    "id": "2005-04-03-post",
    "title": "リチャード ドーキンスの『遺伝子の川』を読む",
    "date": "2005-04-03",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2005-04-03-post.md",
    "content": "僕はリチャード・ドーキンスのファンです。今この本を図書館で借りてきて読んでいます。\nこの本で知った一番の驚きは、動物の神経を通る情報がアナログ量ではなくパルスであるという事です。つまりデジタルという事です。\nだから脳味噌から腕の先まで2000回の信号の中継機によって再増幅があっても情報が劣化しないという訳です。\nキリンの首はあんなに長いけど、ちゃんと情報が正確に伝達されているのだろうかと思っていました。これで謎が解けました。\nDNAも結局デジタル(4進法の数値データ)だし、僕等はデジタルで過去と繋がっているのですね。\nでも、この本で『ブートストラップ』のことを『ブーストラップ』と書いてあるのが気になった。誤植ですか？\nそれにしても、10回以上この間違いが繰返されていると読むときのリズムが狂うんですけどね。\nでも、この本古いけどほんとに素人にもわかりやすく書かれています。",
    "url": "/2005/4/3/2005-04-03-post/"
  },
  {
    "id": "2005-05-08-post",
    "title": "『心脳マーケティング』、『コトラーのマーケティング・コンセプト』を読む",
    "date": "2005-05-08",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2005-05-08-post.md",
    "content": "マーケティングの本です。ゴールデンウィーク中に読みました。\n僕はあまりマーケティングの本を読んだことがないので、他のマーケティングの本と比べた感想は書けませんが、次のようなことはこの本を読むまで考えもしませんでした。いわれてみれば自分の経験と照らし合わせると納得できます。\n以下第2章の概要の引用です。\n多くの読者が驚くべき事実に直面することだろう。たとえば、消費者の思考内\n 容の95%が無意識のうちに起こっているという事実や、その思考内容の多くは\n メタファーを通じて掘り起こすことが可能であること、マーケターが無意識の\n うちに考えていることが、意識して考えていることと同様に、消費者の考え方\n に影響を及ぼすこと、などである。\nこの本に書いてある、『我々の認知活動のまさに95%を越える部分が無意識のうちにおこなわれている。』ということが本当なら、ユーザーが本当に欲しいソフトウェアを作るためには、マーケティングを抜きではかなりムダの多い活動をしているということになるのでしょう。むしろ、ユーザーが本当に欲しいものを作る方法がマーケティングということでしょうか。\nフィリップ・コトラーの『コトラーのマーケティング・コンセプト』の序文にも同様の説明があるので、引用しておきます。\nマーケティングはしばしば販売と混同される。だが、マーケティングと販売は、\n ほとんど正反対とも言える活動だ。『ハードセル・マーケティング』などとい\n う表現は矛盾しているのである。ずいぶん以前のことになるが，私は次のよう\n に述べたことがある。『マーケティングは、生産物のうまい処分方法を見つけ\n るための技術ではない。本物の顧客価値を生みだすための技術なのだ。同時に\n それは、顧客の生活向上を支援する技術でもある。品質、サービス、価値、こ\n れがマーケターの合言葉なのだ。』\nソフトウェアに関連する技術だけを日々追いかけていては得難い内容です。みなさんも読んでみては？",
    "url": "/2005/5/8/2005-05-08-post/"
  },
  {
    "id": "2005-05-22-post",
    "title": "『パターン認識と学習の統計学―新しい概念と手法』を読む",
    "date": "2005-05-22",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2005-05-22-post.md",
    "content": "『パターン認識と学習の統計学―新しい概念と手法』を読む\n実際はゴールデンウィークにマーケティングの本といっしょに読みましたが、今頃書いています。\n結論からいうと今開発中のSumibiの役に立ちそうなアイデア・手法は載っていませんでした。\nこの本に書いてある内容は、主に『学習データが少ない場合にどうやってパターン認識の性能を上げるか』ということに重点が置かれています。\n一番の収穫は『学習データが沢山ある場合は別段工夫しなくてもある程度性能が出る』という事が分かったことです。\nといっても、僕の知らない統計的学習の手法がたくさん紹介されていて面白かったです。\nSumibi の場合は力技アプローチを採用しているので、ある程度、変換性能が出るという事でしょう。\nところで、マーケティングの本と一緒に読むとなんか不思議な感じがします。\n一見、共通点が無さそうな気がしますが、実はどちらも人間の無意識を扱うという点で共通点があります。\nマーケティングは人間の無意識を解明し、人間の欲しいモノを作るというテーマですし、パターン認識の方は人間が無意識で行っている事を解明し機械にやらせるというのがテーマです。\n最近、僕は無意識の解明・最大限の利用というテーマに興味があるようです。\nグーグルCEO、同社のプライバシーポリシーを語る\nこの記事を読んでSumibi.orgも同じ深い問題を抱えているんだなあと改めて思いました。\n現在のSumibi.org で提供している辞書は厳選したWebサイトだけを読みこんで作ったものなので良いのですが、今後も気を付けていきたいと思います。\nSumibi.orgのプライバシーポリシーも『邪悪なことはしない(当然)』です。",
    "url": "/2005/5/22/2005-05-22-post/"
  },
  {
    "id": "2005-08-09-post",
    "title": "紙飛行機の思い出",
    "date": "2005-08-09",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2005-08-09-post.md",
    "content": "ふと、僕が小学生の時、近所の幼なじみと紙飛行機を作って遊んだことを思いだしました。\n僕は昔から、何かを作るということが好きでした。\n特に、ねんどやダンボール箱をこねくりまわして、車やヘリコプターなどを作った事を覚えています。\nある日、いつものように幼なじみと紙飛行機を作ってどちらが遠くまで飛ぶか競争をしていました。\n二人とも試行錯誤を繰り返したあげく、遠くまで飛ばすのにも飽きてしまいました。\nそうなると、僕は距離よりも少しでもかっこよく速く飛ぶ飛行機の製作に興味は移って行きます。\n結果思いついたのが、紙飛行機の先端を折鶴の頭部の如く下向きに折り曲げて、先端を重くして航行速度を上げるという\nアイデアでした。作ってみると外観も本当にかっこよく、真っ直ぐ飛んだのをよく覚えています。\n続いて、幼なじみも負けじと同じアイデアで先端の折り曲げる量を変えたりして、宙返りが簡単にできるカッコイイ紙飛行機を作りました。\nその時、僕はなんと子供だったのでしょう、『人の真似は禁止』とつっかかっていって、その幼なじみの紙飛行機がどんどんかっこよくなっていくのを根本から阻止しようとしました。\n普通ならタダのガキのよくある風景だなと思うだけで通り過ぎるかも知れませんが、僕はここで知的財産権とソフトウェア特許に重ねあわせて考えてしまいます。\n『自分のアイデアを真似されたくない』これは根源的なものなんでしょうか。\nオープンソースソフトウェアのメリットを実体験している今となっては、過去の自分が愚かしく見えますが、子供の頃の自分がそんなことを言ったということは、なんの疑いもなくアイデアの無断利用は間違いだと思っていたし、それが常識だったのかもしれません。\nその後は、幼なじみの抗議を受け入れ、仲直りして紙飛行機を改良しては二人でスゴイスゴイと言いながら楽しく遊びましたが、今でもその時の幼なじみの抗議での『なんと理不尽な』という表情は忘れていません。\nアイデアの再利用のメリットは大きいけれども、それを身を持って体験するというのは貴重です。\n僕は、何時からアイデアの再利用・共有の推進派になったのでしょう。しかもオープンな再利用の推進派に。\n残念ながら何時からかははっきりしません、こういう経験の連続で少しずつ考えが固まっていったのでしょうか。",
    "url": "/2005/8/9/2005-08-09-post/"
  },
  {
    "id": "2005-08-20-post",
    "title": "『ランチェスター戦略「弱者逆転」の法則』を読む",
    "date": "2005-08-20",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2005-08-20-post.md",
    "content": "僕の回りではマーケティング関連の本を沢山持っている人がいるので、オススメの本を借りて読んでいっています。\n確かにこの本はオススメです。シェアナンバーワンと二位以下で取るべき戦略が違うというのは非情に納得できます。\nオープンソースソフトでも何でもいいんですが、これから何かを世の中に出してできるだけ反応を得たいと思っている人は一読です。\n僕もいままで漠然と自分の作りたい or 使いたいソフトウェアをオープンソースとして作っていましたが、今では次の一手を考える時にこの本の基本戦略も考えるようになりました。\n[Sumibi]で言うと日本語変換全体でのユーザシェアでナンバーワンは取れないのは明白なので、ニッチな世界でナンバーワンに近づける様に、今はどんどん差別化する段階だということになります。",
    "url": "/2005/8/20/2005-08-20-post/"
  },
  {
    "id": "2005-08-21-post",
    "title": "[自然言語処理ことはじめ―言葉を覚え会話のできるコンピュータ』を何度も読み返す",
    "date": "2005-08-21",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2005-08-21-post.md",
    "content": "自然言語処理の本なのですが難しい本ではありません。専門家でなくてもわかりやすいように書いてあります。\nしかも、この本は最初から最後まで一貫して夢があって楽しいので、何度も読み返してしまいます。\nこれから、自然言語処理をやってみようと考えている方は、まずこの本でワクワクしてからスタートすることをお勧めします。",
    "url": "/2005/8/21/2005-08-21-post/"
  },
  {
    "id": "2005-09-24-post",
    "title": "『検索エンジン戦争』を読む",
    "date": "2005-09-24",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2005-09-24-post.md",
    "content": "図書館に行くと新刊の棚に置いてあったので、読んでみました。最近のサーチエンジンの開発元は買収につぐ買収でサーチエンジンと開発元の関係がさっぱり追えてなかったのですが、この本でやっと把握できました。よくまとまっています。\nまた、なぜmsn,yahoo（もちろんgoogleも）が検索エンジンを自前で作って戦おうとするのかもわかりました。結局のところ、現在はWebの入り口は全て検索エンジンになってしまっているので、そこを押さえてしまった者が全てを手にするというわけですね。\nそういえば、僕も最近ブックマークはあまり使わずに、'nikkei'とか'apple'とか 'cnn' とかで検索して目的のサイトに行きます。まして、URLを直接打ち込んでサイトに行くなんてことはもう誰もやらないでしょうね。\nこの本を読みながら広告ビジネスとSumibi.orgを組み合わせて考えていくといろいろ面白いことが思いつくのですが、あまりやると暗黒面に落ちて行きそうなので、オープンソースコミュニティーにそっぽを向かれるようなことにならないように抑えるつもりです。実験的な、又はネタ的なものならいいでしょうけどね。\nフォースの力をむやみに使ってはいけません。オープンソースの力は信じて使っていきますけどね。",
    "url": "/2005/9/24/2005-09-24-post/"
  },
  {
    "id": "2005-10-16-post",
    "title": "CodeFest Kyoto 2005参加",
    "date": "2005-10-16",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2005-10-16-post.md",
    "content": "CodeFest Kyoto 2005という、イベントに行ってきましたので一応どんな事をしていたか書きます。(Sumibi-dev MLに書いた内容とかなり被っています。)\n金曜日の17:30くらいに会場に到着し、ちょっと上記のWikiの設定などを行った後、Anthyの田畑さんと同じくAnthyの吉田さん(oxyさん)とSumibiの変換アルゴリズムや、辞書の構造などいろいろ雑談っぽくお話しさせて頂きました。\nshelarcyさんとも初めてお会いしました。僕の作ったSxmlcnvというソフトウェアを使っていただいています。Kahuaはsxmlライブラリのバグが直ているので参考に直してくださいとのことです。了解しました。\n後、Sumibiの辞書の再配布方法など田畑さんに助言を頂きました。また、oxyさんにSumibi.orgで遊んで頂き、『えっ？SOAP？』と興味を持っていらっしゃったのでネタでsim-sumibiを作って頂けるかも知れません。もちろんプレゼンでのつかみネタ程度のモノを考えておられると思いますが…\n他にも、今後AnthyもWikipedia日本語版を読み込んで統計的アプローチも取り入れる予定だという話をされていました。\n最後に、田畑さんが漢字変換エンジンなんか作ってても尊敬されないとか、PRIMEを開発されている方から『Anthyがちゃんとしているから、他の漢字変換エンジンが心置きなくネタに走れる』と言われたとぼやいていらっしゃったのが印象的でした。ついでに『すごく共感します。Sumibiもネタに走れるのはAnthyがちゃんとしているからです。』という事を伝えておきました。(^^;)\n僕はその日の22:00頃 会場を出たので、それまでの間Anthy関連の人を質問攻めにして一行もコードを書いていません。もしかしたら、コンピュータ持たずに手ぶらで行っても良かったかもと思っています。^^; 自宅に戻ってからはドキュメントしか書いていませんし。\nコードは一行も書いていませんが参加してみて有意義なイベントでした。また、関西で開催されれば参加したいです。",
    "url": "/2005/10/16/2005-10-16-post/"
  },
  {
    "id": "2005-10-25-post",
    "title": "ピアノハッカー、キース・ジャレット",
    "date": "2005-10-25",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2005-10-25-post.md",
    "content": "2005年来日公演があったので 10月17日（月）の大阪公演を見てきました。\n感動でした！全編アドリブ曲で映画音楽の様な美しいメロディーが次から次へと生まれては消えていきます。\nまさに、ピアノハッカーです。完全なるハッキングです。\nまた、日本に来られるのは 3年ぶりだそうなので大変貴重な公演でした。\nアルバム『ケルン・コンサート』とは違って、バラードとアップテンポの曲が交互に生み出されていきました。\n公開録音だったので、もし大阪公園がCDとして発売されたら絶対買いです。\n僕の敬愛するpiano nerdsビル・エヴァンスはもうとうに亡くなってしまったので、生で堪能できる好きなピアニストはキース・ジャレットくらいしか無くなってしまいました。残念。",
    "url": "/2005/10/25/2005-10-25-post/"
  },
  {
    "id": "2005-11-16-post",
    "title": "良きライバルは必要か",
    "date": "2005-11-16",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2005-11-16-post.md",
    "content": "最近、SumibiのEmacsクライアントの改善を行っていました。\nEmacsのoverlayという機能を使って実装したのですが、一番苦労したのは、GNU EmacsとXEmacsの両方で動くようにする作業です。\n僕は普段GNU Emacsを使っているのですがGNU Emacsで『上手く動いたー』と思うのも束の間、次の瞬間にはXEmacsではちゃんと動かないことを知って愕然とします。\nEmacsは一つでいいと思っているのは僕だけではないはず。\nそれともIEとFirefoxの様に何でもライバルの存在は必要なのでしょうか？\nXEmacsが存在したことで競争を促しGNU Emacsが今の様な画像表示機能やその他諸々の機能を実装したといえなくもないかな。\nやっぱり受け入れざるを得ないのでしょうか。",
    "url": "/2005/11/16/2005-11-16-post/"
  },
  {
    "id": "2005-12-11-post",
    "title": "コトラーのマーケティングの本",
    "date": "2005-12-11",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2005-12-11-post.md",
    "content": "僕は、時々マーケティングの本を読みます。\n単純に技術的な興味だけでオープンソースを作るというのも楽しさ半減だということが最近わかってきたからです。\n趣味でやっているといえども技術的に面白いだけでなく、世の中の役に立つものを作って共有したいという想いが強くなっています。\n特に、今Sumibi.orgというWebサイトで世の中の役に立つサービスを提供し、沢山のユーザーさんに利用して頂いているので、マーケティングを本だけでなく実体験として勉強できる環境があります。\n僕はこれまでオープンソースソフトウェアをコミュニティーで開発しいろんな凄腕のプログラマからアドバイスをもらう体験してきました。\n今後は、生活必需品としてサービスを利用する人と一緒にさらに経験を積んでいきたいと思っています。",
    "url": "/2005/12/11/2005-12-11-post/"
  },
  {
    "id": "2005-12-17-post",
    "title": "アフィリエイトバブルの崩壊",
    "date": "2005-12-17",
    "categories": [
      "コンピュータ"
    ],
    "file_path": "_posts/2005-12-17-post.md",
    "content": "最近、どんなブログを見てもアフィリエイト広告が掲載されていますね。\nかくいう僕のkiyoka日記にもamazonのアフィリエイトを掲載しております。(収入はほとんどありませんが...)\n世の中には嘘か真かわかりませんが月に100万円もの収入があるよというブログ記事が沢山あります。\n逆にそのような記事でしか他の人がどれくらい収入があるのかわかりません。\nなんか面白いですね。\nアフィリエイトで儲かるという記事を書く人が沢山のページビューを稼いで沢山儲けているという異常な状態が続いているようですね。\nそういうサイトを沢山見ていくと、もうそのような話題では人が集らなくなったのか、はたまた疲れてしまったのか、もう収益報告をやめますという人が多いです。\nということは、みんな小手先の努力では儲からないということがわかってきて、そのようなページを見にいかなくなり異常なループが成立しなくなったのですかね。\nこの現象は株のバブルと同様に考えると『アフィリエイトバブルの崩壊』という感じでしょうか。\n早めに始めて早めに止めるという必勝パターンまで株のバブルのときと同じですね。\n後は良質な本物のコンテンツが生き残るという正常な市場が形成される、と。\nもうそろそろ、その時期でしょうか。そうなればいいですね。",
    "url": "/2005/12/17/2005-12-17-post/"
  },
  {
    "id": "2006-01-09-post",
    "title": "コトラーのマーケティングの本を読了",
    "date": "2006-01-09",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-01-09-post.md",
    "content": "読了といっても、自分に必要な部分だけです。なにせ900ページ弱もあるので。実質ページ数でいうと3分の1程度しか読んでいません。\nコトラーのマーケティング本は巨大組織におけるマーケティングの実践方法について書かれているように思えます。\n僕の様に巨大企業ではない職場で働いていて、しかもマーケティングの勉強は自分の趣味であるオープンソースソフトウェア開発に応用出来ないかというところから始まっているので、あまりにもスケールが違いすぎる章が多いです。\nしかし、巷の和書のマーケティング本だけを読んでいては体系立ってマーケティングを理解できないので、あわせて読むと良いでしょう。\nコトラーの本で一番良い所は、丁寧に言葉の定義をしながら進んでいく所です。理解が明確になり、マーケティング本でよくあるような曖昧な例え話で終わっていません。\nまた、実例が豊富で読んでいても楽しいです。中を開けて見るまで信じられないでしょうがコラム等が沢山あり楽しいです。\nおすすめの一冊です。\n他にも、個人スケールにあった本も読んだのでそれも後日紹介します。",
    "url": "/2006/1/9/2006-01-09-post/"
  },
  {
    "id": "2006-01-15-post",
    "title": "『図解 実戦マーケティング戦略』を読む",
    "date": "2006-01-15",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-01-15-post.md",
    "content": "近所の中古本屋で買いました。\nあまり期待せずに読んだのですがなかなか参考になりました。(但し、買う価値あると思ったので買ったのですが。)\n個人サイト等のマーケティングにこの本のツールを使えば、分かりやすく役に立つサイトを作れそうです。\n特に、ポジショニングや伝わるメッセージの組み立て方など、思考ツールを使わないと答えにたどりつきにくい問題を分かりやすく解説しています。\nこの本は戦略BASiCSという思考ツールを丁寧に紹介するという内容になっており、後は実際に使ってみてくださいというものです。\n『実戦マーケティング戦略』というタイトルのとおり実戦で使ってみようと思います。\nまずはトレーニングとして新サービスに適用してみます。",
    "url": "/2006/1/15/2006-01-15-post/"
  },
  {
    "id": "2006-01-24-post",
    "title": "創作にいたるまのでステップ(1)",
    "date": "2006-01-24",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-01-24-post.md",
    "content": "僕にはオープンソースソフトウェアを作るという趣味があります。\n作るといっても、既にあるオープンソースプロジェクトに参加するというよりも、自分で一から立ち上げることに楽しみを感じる性質のようです。\nいつも微妙なものを作っては回の人たちを困惑させてしまうというパターンが定着しつつあります。 ^_^\nさて、新しくものを作る(創る)場合、いかに自分の心理状態をコントロールするかというのが勝負になります。\nまず、自分の貴重な時間を使ってでもやる意味があるかというのが最初の関門です。\nそして、その最初の関門をクリアしたアイデアだけが採用となります。\n僕の場合、アイデアの評価基準としては新規性というのがかなりの比重を占めます。誰もやっていないことをやるのが基本です。基本的には誰もが願っていることだと思います。\n逆にこれがあるから既存のプロジェクトに参加するのはちょっとものたりない気がするのかも知れません。\nもし、その第一関門を突破したら次に実験段階に入るのですがここでも、かなりのアイデアが脱落していきます。\n一人ではとてもスケールが壮大過ぎて作れないもの等もこの段階で中止となります。\nなかなかここを通過するアイデアは少ないのですが、そこを通過すれば本格的な創作開始となります。\n『あんた、それがその何かい？Sumibi.orgというやつかい！』というツッコミは無しでおねがいします。\nまた続きを書きます。",
    "url": "/2006/1/24/2006-01-24-post/"
  },
  {
    "id": "2006-02-06-post",
    "title": "創作にいたるまのでステップ(2)",
    "date": "2006-02-06",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-02-06-post.md",
    "content": "前回、新しいものを作る場合、いかに自分の心理状態をコントロールするかが重要だと書きました。\n実は、自分の心理状態をコントロールする前にもっと大事なことがあります。それは『企画』や『アイデア』です。\n特に仕事ではなく趣味として自分が楽しみながら続けていくために、どんなアイデアを採用すればよいかを書きます。\n個人的には次の点を心がけるとうまくいくと思います。\n※重要と思うものから順に並べています。\n- できあがったものが、ありきたりでないこと(新規性・驚き)\n- 日常的に自分が使うもの\n- 作る過程が楽しいこと\n- 作るのに壮大な時間がかからないこと\n昔は、ついつい 1. を追いかける余り、 4. に反するアイデアのものを頑張って作ってました。よく自分のスキルを超えるモノを作ろうとして失敗していました。\nオープンソースソフトウェアが沢山存在する昨今、自分で作らないといけないものはかなり少なくなってきている気がするのでますます壮大な時間を費やす必要は薄れてきています。\nそれよりも既存のオープンソースソフトウェアを組みあわせて少ない時間で驚きと楽しさのあるものを作った方が何倍も有意義です。\nSumibi.orgは一応これらの条件を満たしていると思います。\nちなみに、今作っている『携帯向けブラウザ』もこれらの条件を満たしています。(但し、順番は 2. 1. 3. 4. かな？)\n問題は、作るスピードよりもアイデアが生れるスピードのほうが早いということですかね。^_^;",
    "url": "/2006/2/6/2006-02-06-post/"
  },
  {
    "id": "2006-02-12-post",
    "title": "一人プロジェクトと『鳥の目』",
    "date": "2006-02-12",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-02-12-post.md",
    "content": "僕も江島さんの記事に激しく同意します。ちょうど同じことを考えていたところです。\n僕もクリエイター受難の時代が終わって状況が変わってきたと思います。\n創造的なエンジニアのための働く環境とは（２）:江島健太郎 / Kenn's Clairvoyance - CNET Japan\n いまはクリエイター系のエンジニアの出番が急激に増えてきた時代だっていう\n こと。そしてそのフロンティアは、まちがいなくWebにある。しかも、誰でも\n タダでブログが書け、自宅に引き込んだブロードバンド回線にサーバを立てる\n コストなんてたかが知れている。チープ革命万歳だ。\n近年、コンピューターの高性能化によってアマチュアでもプロと変わらない品質のCGアニメーションが作れるようになってきているようですが、同様のことがプログラマの世界にも起きようとしているのだと思います。\n創造的なエンジニアのための働く環境とは（２）:江島健太郎 / Kenn's Clairvoyance - CNET Japan\n こういうフロンティアをつきつめるときに、中途半端にすぐお金になるビジネ\n スプランをセットにして考えてしまうと、その一番大切な何かを失ってしまう。\n もちろん、最後の最後にはビジネスとして成立しなければいけないけど、おそ\n らく普通の人が想像しうる限界を超えてロングタームなものであるはずだ。\nこれも、アマチュアCG作家の場合と同じなのでは無いでしょうか。\nちなみに、江島さんの記事でいくと僕は明かにクリエイター・ギーク系です。\nちょっと引用すると\n 創造的なエンジニアのための働く環境とは（２）:江島健太郎 / Kenn's Clairvoyance - CNET Japan\n (１) クリエイター・ギーク系\n - 小規模なベンチャーで新しいサービスを作りたいタイプの人\n - 会社の中で認められたいのではなく、会社の外で認められたい\n - 週末も趣味でコーディングしている\n - お金、ステータスにこだわらない\nということです。\n項目のほぼ全てがマッチしているといっても過言ではないです。\nやっぱり、僕は自分で全てコントロールして新しいサービスを作るということに喜びを感じる性質です。\nなぜそうなのか... 記事の中で紹介されていた記事(以下に引用)が僕のもやもやを解消してくれた様な気がします。\n １人のプロジェクトと、チーム開発をつなぐ「鳥の目」：Goodpic\n WEB系の開発は、ますます少人数で効率的におこなえる環境が整ってきて、\n ちょっとしたサービスなら一人で作って公開もできてしまう。ただ、やはりあ\n る程度の人数でないと作れないものもある。どちらも違った楽しさがあるけれ\n ど、「一度は一人でやってみる」という経験は、チーム開発でも役に立つし、\n 「一人でも作れるかもしれない」という思い込み、予感は、ソフトウェアの多\n 様性、可能性をひろげていくのではないだろうか。\n今新しいサービス『Webリーダー』を作っている所ですが、同じ想いで作っています。\n一人で全部の流れをやったという経験はなにものにも代えがものです。\n今回も一人で全ての流れを経験できると思うし、Gaucheによる開発効率の倍速化というレバレッジが効いているので、分業の必要がなく逆に一人のメリットが生かせるはずです。\nどちらかというと、30%の完成度でサービス開始してユーザーにブラッシュアップの議論に参加してもらう方向で分業できないかなと考えています。\n僕も一人プロジェクトを通じて『鳥の目』を手に入れることが出来るのか。もし手に入ればその後の人生が確実に豊かなものになると想像します。",
    "url": "/2006/2/12/2006-02-12-post/"
  },
  {
    "id": "2006-03-04-post",
    "title": "良い問題設定を",
    "date": "2006-03-04",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-03-04-post.md",
    "content": "生産的になろうを読んで共感しました。思っていることを書いてみます。\nこの短い人生で自分が今取り組むべき問題はなにか。\n常に何か独創的なものを作りたいと思っている人に付いてまわる命題です。\nしかし残念ながら、その人がその時期に思いつくアイデアと実現できる力というのはぴったり合致しないものです。\nすばらしいアイデアだけれども今の自分の技術力や経験が不足していて完遂しない事が明白な場合は、もっと簡単な問題から取り組むべきだと思っています。だからといって、手ごろだからという理由でそれを選択するのも違うと思います。\n何事も経験が伴っていないとちゃんとしたものはできないと思います。いくらアイデアが良くても。\nインターネット上に新しいサービスが出現した時に、『自分もこれ思いついてたんだけどなー』と悔しがる人がいますが、実際に作るという決断をして、時間をかけて実際に形にするのは難しいものです。『もし、そう思うのなら自分で作ればよかったのに』と言いたい。やりはじめるとすぐに判ります。\nその人は作らなかった、もしくは作れなかったのです。作らなかった理由としては、実際にはそれほど重要では無かったか、作るには技術力(もしくは時間や環境)が不足していたということになります。『お金があればなあ』というのもこれに含まれます。\nもし、このようなシチュエーションに出会った時のために、僕のやりかたを書いてみます。\n僕の場合は、良いアイデアを思いついた場合、ちょっと自分の技術力が足りなさそうなものでも、とりあえずtryしてみます。\n(どんなものを選択するかという僕なりの判断基準は『 [kiyoka.2006_02_06] 創作心理創作にいたるまのでステップ(2) 』に書きました。)\nそして実際にそのアイデアの一番重要な部分を1日ででっち上げてみます。\nコア部分があまりに自分には歯が立たない問題であったり、意外と面白くないものであったりした場合はそこで中止となります。\nプロトタイプを使ってみると『案外面白くないではないか』というモノも有りますので。\n実は、現在開発中のWebリーダーでもコア部分を作ってみて、イケル！ということがわかったのでどんどん進めています。\n2年前だと自分の技術力は完全に不足していたでしょう。\n良い問題設定とはタイミングという要素もからんできます。難しいですね。",
    "url": "/2006/3/4/2006-03-04-post/"
  },
  {
    "id": "2006-03-12-post",
    "title": "ウェブ進化論",
    "date": "2006-03-12",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-03-12-post.md",
    "content": "僕の日頃からの想いを代弁してくれている本だと思います。すばらしい。\n個人的に気になったキーワードを列挙すると『Web 2.0』『ブログ』『ロングテール』『チープ革命』『オープンソース』『情報発電所』『(ネットの)こちら側とあちら側』『組織と個とブログ』です。\nこれらのキーワードがうまく整理されて説明されています。\n本当にいろんな方に読んで頂きたいです。\n普段ネットに出かける時間が多い人は当然読まれるでしょうが、それ以外の方にも読んで頂きたいです。朝日新聞に大きな広告が出るそうなのでテレビ等のメディアにも取り上げられるといっきに認知度があがるのでしょうね。\n特にオープンソースに関わっている方、ブログを書いていらっしゃる方はこれを土台にして議論が展開されていく可能性が高いので読まないわけには行かないでしょう。\n僕は普段から個人的に『Web 2.0』『ブログ』『チープ革命』『オープンソース』等の進歩に恩恵を受けて生活しているので、これからの世の中がこの本の様に止められない大きな動きになるのか早く知りたい所です。\nとにかく僕は自分の今やっている事の意味を再確認できたという意味で貴重な読書体験でありました。",
    "url": "/2006/3/12/2006-03-12-post/"
  },
  {
    "id": "2006-03-29-post",
    "title": "『ソフトウェアの肥大化』と『ムーアの法則』",
    "date": "2006-03-29",
    "categories": [
      "コンピュータ"
    ],
    "file_path": "_posts/2006-03-29-post.md",
    "content": "「ソフトウェアの肥大化」と「ムーアの法則」:中島聡・ネット時代のデジタルライフスタイル - CNET Japan\n しかし、私は、その方向性はソフトウェアを走らせることが出来るデバイスが\n 実質的にパソコンしかなく、それも全ての処理をクライアント側で処理するし\n かなかった一昔前の時代のものだ、と感じている。\n 携帯電話、カーナビ、テレビ、デジカメ、などのあらゆるデバイスにCPUが入\n り、それらがネットワークに繋がってきたユビキタス・デバイス、ユビキタス・\n ネットワークの時代には、この「ムーアの法則のおかげで増大したハードウェ\n ア能力をソフトウェアで全て使い切る」方向性が正しいとはどうしても思えな\n いのだ。\n そんなことを続ける限り、デバイス間でアプリケーションやサービスを共有す\n ることは実質的に不可能である。ソフトウェアの開発コストは上昇するばかり\n だし、ユーザー・エクスペリエンスも向上させることはできない。\nおっしゃる通りだと思います。僕はメール配信型WebリーダーR@eply.orgという携帯電話向けのサービスを開発しています。\nこれは、いかにブログを効率よく読める携帯ブラウザを、いかに少ないコストで作れるか考えた結果生まれたものです。\nパソコン以外のものに目を向けた瞬間に、増大したハードウェア能力の使い道として、パソコン上のソフトウェアの機能追加だけではつまらないと感じます。\nムーアの法則のおかげで個人でも安い値段でWebベースのサービスが作れる、いわゆる『チープ革命』のほうが価値があると思います。\nソフトウェアの肥大化は開発コストを上げるだけで、せっかくハードウェアがチープになった分を帳消しにしてしまいます。\n僕がいいたいのは、既存のソフトウェアをもっと高機能にするのではなく、不可能だった事を実現するために利用したほうが相対的に価値が高いということです。\nそう考えると、現在、コンピューティングの中心がクライアント側でなく、サーバー側にシフトしていっているのは自然な流れだと思います。\n追記: 中島さんの別のブログでも重ねて言及されていますね。「ムーアの法則」とUIEngine",
    "url": "/2006/3/29/2006-03-29-post/"
  },
  {
    "id": "2006-04-04-post",
    "title": "S式暗号",
    "date": "2006-04-04",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-04-04-post.md",
    "content": "もし、貴方の書いたソフトウェアをオープンソースにしたいが、ソースコードを暗号化したいという複雑な要求があったとします。\n僕はその解決方法を知っています。それはS式で書くことです。\nそうしておけば、JavaやPHPしか分からない人にとっては、強力な暗号となります。\nその人たちはあまりの小括弧の多さに『うへぇーダメだー』となります。\n...というのは冗談で、S式は本当に開発効率が高い記述言語です。\n最近、僕はS式でプログラミングすることが多くなってきました。\nSumibiもR＠eply.orgもS式で書かれています。\nでも、S式でオープンソースソフトウェアを公開すると、読める人が少ないせいか協力者を得ることが難しくなります。\n近年少しづつ、Lisp系言語への回帰傾向がいたるところで始まっているようなので、それも改善されてくるのかも知れません。\nというか、そうなればいいなぁー。^_^;",
    "url": "/2006/4/4/2006-04-04-post/"
  },
  {
    "id": "2006-04-07-post",
    "title": "やさしい機能仕様 - なぜわざわざ書く必要があるのか？",
    "date": "2006-04-07",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-04-07-post.md",
    "content": "有名なJoel on Softwareの中の やさしい機能仕様 - なぜわざわざ書く必要があるのか？を読みました。\nこれには同意します。\nSumibi.orgもMail配信型WebリーダーR＠eply.orgも機能仕様書をじっくり書いてからプログラムを実装しはじめました。\n機能仕様を書くことは重要だと思います。\nMail配信型WebリーダーR＠eply.orgの場合は、機能仕様を書き始める前は漠然と、iアプリとしてテキストブラウザを作る予定でした。\nまず機能仕様を書いてみて、僕のほしい機能はiアプリではできそうもないということが早い段階でわかりました。\n特に、RSSリーダーとして使うためコンテンツをPUSH型にしたかったのと大量のタブ(しかも未読機能付き)をサポートしたかったのでiアプリで作るのは大変そうだということが明らかになりました。\nその結果思いついた実装手段がHTMLメールです。(iモードメールの世界では『デコメール』と呼ばれています。)\nもし、iアプリとして実装していたら途中で疲れ果ててしまってサービス開始できなかったかも知れません。\nやっぱり実装方法は抜きにして一度サービスを文章化してみるべきです。\nこれは個人で余暇を費やしてプログラムを作る場合、なおさらです。\n皆さんも、趣味とはいえど、むしろ趣味だからこそ貴重な時間を有効に活用するために、作る前に機能仕様を書いてみてはいかがでしょうか。",
    "url": "/2006/4/7/2006-04-07-post/"
  },
  {
    "id": "2006-04-22-post",
    "title": "何でもGauche",
    "date": "2006-04-22",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-04-22-post.md",
    "content": "Gaucheという処理系は使えます。\n僕のプライベートなプログラミングは全てGaucheになってきました。まさに、なんでもGaucheです。\n何がそんなに良いのか。\n今日はその辺りを書いてみたいと思います。\nそれでは、箇条書きで。\n\nLisp系言語なので生産性が高い\nいままで、Emacs LispやGaucheなどのLisp系言語をやってきて思うのは、他の手続き型言語に比べて生産性が高いということです。\n関数型言語一般に言える事だと思いますが、手続的なプログラミングではなく宣言的にプログラミングすることで一行で表現できる意味濃度が高くなります。\n関数型言語でプログラミングしたことのない人には想像しにくいと思いますので、About Haskellの関数型言語とは？の部分を引用しておきます。非常に分かりやすい説明がされています。(Scheme言語の説明ではないですが同じ関数型言語であるScheme言語の説明としてもそのまま通ります。)\n About Haskell\n 関数型言語とは?\n\nC, Java, Pascal, Adaといった言語は命令型(imperative)言語です。これらは\n 逐次実行されるコマンドの列により構成されているという意味で'命令型'と呼\n んでいます。\n Haskellは関数型言語です。関数型プログラムはただ一つの式からなり、それが\n 評価されることによりプログラムは実行されます。\n 表計算ソフトを使ったことがある人は関数型プログラミングを経験済みだと言\n えるでしょう。表計算ソフトでは各セルの値を、他のセルの値を基に決定しま\n す。ここで注目されるのは何を計算するのかであり、どう計算されるかではあ\n りません。例えば\n\nセルが計算される順序は指定されません。- その代わりに表計算ソフトがそ\n れぞれのセルの依存性に応じてセルの計算をしてくれるであろうという考え\n が根底にあります。\n\n表計算ソフトがメモリをどのように配置するかを指定することはありません。\n\nむしろ、表計算ソフトが表面的には無限のセルの列があるように見せてく\n れて、実際に使用される時に初めてメモリを配置してくれることを期待しま\n す。\n\nほとんどの場合、各セルの値は、その値を計算するためのコマンドの列では\n なく、ただ一つの式により指定されます。 (式の中の部分式の評価順は問わ\n れません)。\n\nこの表計算ソフトにおける計算の順序が指定されないということから、代入と\n いう概念はそれほど役にたたないという面白いことが言えます。\n とりわけ、もし代入がいつ起こるか正確にわからないのであれば、それを有効\n 利用することはできません!\n このことは、基本的に代入文を慎重に並べていくことにより計算を構成してい\n く C言語や、メソッドの呼び出し順が重要となるJavaといったような慣習的な\n 言語とはかなり対称的です。\n このレベルの低い'どう' ではなくレベルの高い'何' に焦点を当てているのが、\n 関数型言語が他と最も異なる特徴と言えます。\n 他のよくしられた関数型言語に近い言語として、標準的なデータベースクエリー\n 言語である SQLがあります。\n SQLのクエリーは投射、選択、結合などを含めた式になります。クエリーには\n どの関係が計算されるかが記述され、どのように計算するかは記述されません。\n もちろんクエリーはどのような順序で評価されても構いません。\n SQLの実装の多くは、(考え得る中で)最も最適な式の評価順序を見つけること\n でクエリーの最適化を行ないます。\n\nライブラリが充実している\n充実している上にバランスが良いのが特徴です。\n作者のShiroさんのバランス感覚は外の言語処理系の作者をしのぐ素晴らしさです。\n\n日本語がネイティブサポートされている(UTF-8)\nUTF-8を自然に扱え日本語の正規表現なども問題なくいけます。ソースコードもUTF-8で書けるのでUTF-8 onlyの世界が実現します。\nというような理由でオススメです。\nLisp系言語では実用的なアプリが作れないというイメージをお持ちの方は一度試してみてはいかがでしょうか。\n僕は今のところ、利用するばっかりでGaucheのライブラリ開発などにはうまくフィードバックできていないのですが、\nもっとスキルを高めてフィードバックしていきたいと思っています。\n\nコメント by Mario:\nWhat a joy to find soemnoe else who thinks this way.",
    "url": "/2006/4/22/2006-04-22-post/"
  },
  {
    "id": "2006-05-04-post",
    "title": "ANSI Common Lisp を読む",
    "date": "2006-05-04",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-05-04-post.md",
    "content": "連休中たっぷり時間があったので、『ANSI Common Lisp』を読みました。\n実用プログラムを書く上で必要な関数が惜しげもなくGaucheに輸入されています。\nそんなわけで、Gaucheは実用プログラムが書きやすいのでしょうね。 \nこの本を読んで、もっとマクロを活用したりして、Sumibiエンジンをもっと読みやすくできると思ったので、さっそくリファクタリングしてみるつもりです。 \nこの本は、2年前くらいに買ったまま，読まずに置いていたものです。(買った当時は難しくて、途中で放置していました。 )\n今回久しぶりに読んでみて、特に詰まる所も無かったので、自分のLisperレベルが上ったかも！と喜んでいます。 \nCommon Lispの本ですが、Gaucheのプログラミングにもそのまま通用する内容が沢山書かれていますので、Gaucheを始めようと思っている人にもオススメです。 \n追記：この方も書いていらっしゃいますが、この本を読むとLispの処理系を作ってみたくなりますよね。そんな時間はありませんが...",
    "url": "/2006/5/4/2006-05-04-post/"
  },
  {
    "id": "2006-05-14-post",
    "title": "入門Haskell",
    "date": "2006-05-14",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-05-14-post.md",
    "content": "Anthyの開発者のProxyさんの強いススメに従って、Haskellを習得すべく『入門Haskell』を読み始めました。\n言語を勉強する理由として、新しい概念を習得できるということが大きいです。\n逆に、新しい概念や考え方を学べない言語は勉強する価値がありません。(既にあるソースコードを改変する場合は言語を選べませんが...)\nPerl,Python,Ruby,PHP等は、何れか一つを深く使えればよく、次はLispやHaskellなど全く違ったスタイルの言語を勉強するほうが良いと思っています。\nさらには、実際に本を読むだけでなく新しい言語でそれなりに使えるソフトウェアを開発してみるのが一番理解が早いと思います。\nさて、Haskellで何をつくってみようかな。1日程度でできるものが良いですね。",
    "url": "/2006/5/14/2006-05-14-post/"
  },
  {
    "id": "2006-05-18-post",
    "title": "『ザ・キャッシュマシーン』を読む",
    "date": "2006-05-18",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-05-18-post.md",
    "content": "『ザ・キャッシュマシーン』を読みました。\nTOC(制約条件理論)の本を読んだのはこれで4冊目です。\nこのシリーズの本で出てくる『思考プロセス』で使う対立点のグラフは現実の問題に一度使って見たくて仕方ありません。\n普段のソフトウェアの設計や仕様決めに使えるんじゃないかと。\nこういう小説風になっているビジネス書は、テーマになっているソリューションを使ってあまりにも問題を簡単に解いてしまうので、そのソリューションの適用可能範囲の限界が見えにくいという問題があります。\n要は良いことばかりが書いてあって、ソリューションの使用上の注意点がほとんど書かれていないのです。\nということで今度は、小説形式でない解説書である『利益を最大化するTOC意思決定プロセス』を読み始めています。\n他に、ソフトウェアのプロジェクトマネジメントに関係する本で言えば『クリティカルチェーン』も読みましたが、納期直前まで作業を始めない「学生症候群」、結局は無駄になる「セーフティー（時間的余裕）」、という話など、本当か？と疑ってしまうキーワードが沢山あります。\n僕は、なんでも試してみたいタチなので、実際にこのクリティカルチェーンの考え方を試してみて実証してみるつもりです。\nあなたも、TOCの本を一冊読んでみてはいかがですか？",
    "url": "/2006/5/18/2006-05-18-post/"
  },
  {
    "id": "2006-05-23-post",
    "title": "言語の学習コストと生産性",
    "date": "2006-05-23",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-05-23-post.md",
    "content": "最近色んなブログでPerlの学習コストの話題が持ち上がっています。\n( Danさんの所 を出発点にしてもらえらば沢山たどれます。)\n僕は、Perlの学習コストは高いと思っている派です。そして、もうひとつ学習コストが高いと思っている言語が有ります。Schemeです。\nこれだけでは何のコストか良く分からないので、もうちょっと突っ込んで書いてみます。\nPerlのコスト高の原因は色んな書きかたが用意されていて、その量に圧倒されてしまうという所にあると思います。モジュールを使って言語機能を拡張できます。\n例えば、このエントリーを読むと、覚えることが多いせいでPerl5以降のperlの学習コストが、かなり高いと感じられるでしょう。\n逆に、Schemeのコスト高の原因はマクロなどを使って、ドメインスペシフィックな記法が編み出せてしまうので、他人のコードを読む時のコストが高いのではないかと思います。\nそれぞれ、学習コストは高いですがコスト高の原因が違います。\nしかし、どちらも言語の学習コストは高いですが、一度深くその言語を使いこなせると、そのぶん生産性が何倍にもなって返ってくるという気がします。\n同じ処理を書いてもより短いコードで多くの事が表現できる。\n生産性のためなら学習コストは厭わない。それがプログラマーというものです。\nそして、さらなる生産性を求めてHaskellへの興味が湧いてきています。",
    "url": "/2006/5/23/2006-05-23-post/"
  },
  {
    "id": "2006-05-25-post",
    "title": "Joyが面白そう",
    "date": "2006-05-25",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-05-25-post.md",
    "content": "大昔にstackベースの言語でなんか面白そうな言語が作れるのではないかと妄想したことがありました。\n最近のForth言語関連でなんか動きは無いのかと調べていたら、Joyが見付かりました。\nぱっと見た限りでは、stackベースの言語Forthに強く影響を受けているみたいです。\nしかも関数型プログラミングができると来たもんだ。\nschemeやperlでおなじみのmap関数も書けるという...\n僕が瞬間に思いついたアイデアとしてはこのJoyという言語の特徴をひまわりのように日本語プログラムに応用するというものです。\nどうです？題材としては、楽しそうでしょ？\nこれをHaskellでちょいちょいっと作ってみるというのも楽しいかも知れません。\n僕にはそんな能力はありませんので誰かトライしてみてください。但し、クロスプラットフォームで動くようにしといてくださいね。",
    "url": "/2006/5/25/2006-05-25-post/"
  },
  {
    "id": "2006-05-30-post",
    "title": "図書館2.0",
    "date": "2006-05-30",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2006-05-30-post.md",
    "content": "今図書館が僕の中で熱いのです。\n僕の住んでいる近所の図書館なのですが、最近サービスが向上して喜んでいます。ここ2年くらいの変化だとおもいますが。\n(ちなみに、僕は大阪に住んでいます。)\n最近の僕の本の探索行動パターンについて紹介します。\n本屋で気になる本を見つける\n携帯のメールで自分にメールを投げておく(メモ)\n図書館のWebサイトで検索して予約を入れておく\n図書館のWebサイトで検索して見つからない本は、最寄りの図書館に電話して大阪府立図書館から取り寄せてもらう\nO'Reillyの本はSafari Bookshelfで読む\nそれ以外の本をAmazonで買う\nAmazonのアフィリエイトをやっているのに、なんというヤツでしょうか。まあ、一つも売れていないので許して下さい。^_^\nでも図書館でほとんどの本が揃うので本当に便利ですよ。\nだれか、AmazonのURLから図書館の本を直接検索するWebインターフェースを作って下さい(笑)\n\nコメント by Shalinder:\nSuper jazzed about getitng that know-how.",
    "url": "/2006/5/30/2006-05-30-post/"
  },
  {
    "id": "2006-06-04-post",
    "title": "GaucheFestに参加した",
    "date": "2006-06-04",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2006-06-04-post.md",
    "content": "GaucheFest第12回に参加しました。\n特に実作業でGaucheのプロジェクトに貢献出来ている訳けではないです。(ずっとSumibiの作業をやっていましたので。)\nリモートからの参加ですが、仲間がいるという安心感のもと、いつもとは違うマインドで作業ができます。\nまた、IRCでちょっと会話をするだけですが、Inspireされて、いろんなアイデアに繋がります。\nSumibiの改良を続けていくことで、『Gaucheでもいろいろ作れるんだ』という認識が広がっていけばいいなと思います。",
    "url": "/2006/6/4/2006-06-04-post/"
  },
  {
    "id": "2006-06-23-post",
    "title": "No code No life.",
    "date": "2006-06-23",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-06-23-post.md",
    "content": "コードを書かずして生きられないのです。しかし、ただがむしゃらに思いついたコードを書き散らすには人生は短すぎます。アイデアも手段も取捨選択したいものです。\n日々、次から次へと実装せずにはいられないアイデアが降って湧いてきます。インターネット上のアルファギークと呼ばれる人達には私と同じ症状に悩まされている人が沢山いらっしゃるようです。\n多くのコードの達人系アルファギークの面々はプログラミング言語処理系を実装したりしながらも、同時にシブいアプリケーションも作ったりされています。こういう人達は別として(いやマジで)人生は有限なので、どんな優れたアイデアや楽しそうなことも取捨選択が必要となります。\n私もいろんなアイデアに取り付かれやすい割に、そんなにすばやく実装できるほうではありません。私達にはこれをエレガントにさらっと躱す術が必要になります。そこで私が心がけているものは次の様なことです。\n\n思いついてもそれが本当に優れたアイデアかどうか、完成イメージを文章化してみる\n数日間は(場合によっては1ヶ月くらい)そのアイデアが完成した状態をイメージしながら、便利か、楽しいかを確認し、完成イメージの文章を何度も修正する\n実装する場合は、極力、開発効率の良い言語を選択する ( Paul Graham のこのエッセイのように )\n\nどっちみちコードを書かずして生きられないなら、それが直せない病なら、せめてエレガントに躱す術を探して行くしかありません。\nNo code No life.",
    "url": "/2006/6/23/2006-06-23-post/"
  },
  {
    "id": "2006-07-06-post",
    "title": "Less Is More",
    "date": "2006-07-06",
    "categories": [
      "デザインポリシー"
    ],
    "file_path": "_posts/2006-07-06-post.md",
    "content": "ちょっと前に始めたサービスR＠eply.orgには何かが足りないです。\nR＠eply.orgのユーザーの皆さんもそう感じていらっしゃるかも知れません。\n何かが足りないです。\n足りないのは便利さなのか、それとも楽しさなのか、はたまた驚きなのか。\nLess Is More ( Jason Fried CEO, 37 signals )というpodcastを聞いているうちに、より少ない機能がシンプルさに繋がり、結果として分かりやすさを生むという考えかたに感銘を受けました。\nR＠eply.orgでそんなことが出来るかな？\n目指すところは、中身は賢く、表面はシンプルに。Sumibi.orgはその点、成功している様に見えます。\nうーん、どうすべきかなあ。",
    "url": "/2006/7/6/2006-07-06-post/"
  },
  {
    "id": "2006-07-23-post",
    "title": "高速CPUの使い道",
    "date": "2006-07-23",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-07-23-post.md",
    "content": "Paul Grahamのこのエッセーを読んだ時には、次の様な富豪な言語設計は大分先にならないと受入れられないだろうと思っていました。\nThe Hundred-Year Language\n 多くのデータ構造は速度のために存在する。例えば、現代の言語の多くは文字\n 列とリストを持っている。意味的には、文字列は、全ての要素が文字であると\n いうリストであって、一般的なリストのサブセットと言える。ならどうして別\n のデータタイプが必要なんだろう。実は必要じゃないんだ。文字列は単に効率\n のためだけに存在している。けれど、プログラムを速く走らせるハックのため\n だけに言語に意味をごてごてと付け足すなんて、スマートじゃない。\n 言語のコアを公理の集合と考えると、何ら表現能力を増やさない公理を効率の\n ためだけに追加するというのは醜いことだ。効率は重要だが、公理を追加する\n ことで達成するのは正しいやりかたとは思えない。\n 正しいやりかたは、プログラムの意味と実装の詳細を分けることだ。リストと\n 文字列を持つ代わりに、リストだけにしておいて、コンパイラが必要なら文字\n 列を連続したバイトとして表現できるような最適化のアドバイスを与えられる\n ようにしておくんだ。\n 大抵の、速度が問題じゃないプログラムにおいては、こんな細かいことを気に\n する必要はないだろう。コンピュータが速くなればなるほど、そういう場合は\n 増えてくる。\n 実装を気にして書く必要が少なくなれば、プログラムはより柔軟になる。プロ\n グラムを書いている最中に仕様が変わっても対応できる。これは単に避け難い\n というだけでなく、望ましいことだ。\nところが、最近知ったHaskellという言語はPaul Grahamのいう通り文字列型はなく、文字列は文字のリストで表現します。しかも人気の言語になっていきそうです。...\n(ちなみに最近興味を持っているJOYという言語も同様ですね。)\nうーん、大量のCPUパワーがあれば人間のブレインパワーの消費を肩代わりしてくれるという感じでしょうか。\nGauche等、特定のScheme実装で、文字列を文字のリストとして表現できるんではないかと思ったんですが、Schemeの仕様を守れなくなりそうですね。\n(list? str) がリストだと言われてしまうと、過去のプログラムが動かなくなりそうです。(string? str)を必ず先に評価していないと破綻するという。\nそうか、よく考えるとHaskellはコンパイラ言語だから、最適化できるんですね。\nでも、このままCPUが高速になっていけば、Paul Grahamのいう通りになっていくのかもしれませんね。",
    "url": "/2006/7/23/2006-07-23-post/"
  },
  {
    "id": "2006-07-30-post",
    "title": "『大前研一のアントレプレナー育成講座』を読む",
    "date": "2006-07-30",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-07-30-post.md",
    "content": "第3章の『アントレプレナー・マーケティング』- 事業の核心に迫る分析力 - が一番役に立ちそうです。\nこの章を書かれたのは株式会社ユニバースの小川政信さんという方です。\nマーケティングを軽く見てはいけなくて、製品開発の全ての大元だということが分かります。マーケティングという言葉は市場調査やプロモーション活動だけというように狭義のマーケティングの意味で捉えられることが多いですが、それは間違いです。(コトラーの本にも繰り返し書かれています。)\nこの本では、『顧客に取っての価値の見極め』の手法を細かく解説しています。\nコトラーの本などを読んでもこのように具体的には書いていなかったと記憶しています。\n顧客は何に価値を認めるのか？その価値にいくら対価を払うのか？\nへえ、そういうことができるのかと思った事としては、商品の魅力を様々な『要素』に分解して各要素がどれだけ魅力的なのか見極める方法があるということです。\nこの本ではその『コンジョイント分析』という手法をスターバックスコーヒーの日本展開を例にして解説されています。\nさらには、この分析結果で、例えば『コーヒーの美味さ』が重要となった場合、そのコーヒーの美味さとは何かを無意識レベルまで知らないと意味のある仕事はできないと説いています。\nまた、アサヒスーパードライの成功事例では味覚が良いがうまいビールというわけでもないという形で紹介されています。\n事業の核心に迫る分析力より\n これは消費者はうまいビールを求めていて、自分はうまさがわかると考えてい\n るが、実際には、消費者が評価するところのうまさは『新鮮さ』と『企業イメー\n ジ』であるということだ\n後は価格政策やメッセージ伝達、営業力の話に続くのですが、どれもわかりやすいです。\nこの本はこの章だけでもオススメです。\nこのブログを読んでいらっしゃるであろうOSS開発者の方々はマーケティングなんか関係ないと思っている方もいらっしゃるでしょう。\nしかし、OSSも認知度がプロジェクトの成否に関わると思っていますので、やっぱり知っておいて欲いです。\nちなみに、OSSでコンジョイント分析ってやった人いるんでしょうか。\nこのPart5が良かったので、Part4も読みはじめています。",
    "url": "/2006/7/30/2006-07-30-post/"
  },
  {
    "id": "2006-08-03-post",
    "title": "Cleanが面白い",
    "date": "2006-08-03",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-08-03-post.md",
    "content": "最近純粋関数型言語を順番に見てまわっています。\nCleanという言語も面白いですね。\n純粋遅延関数型言語Concurrent Clean\nHaskellと同じで、キーワードは『参照透明性』と『遅延評価』でしょうか。\nインデントが構文上の意味を持つというのも同じですね。\nまだちゃんと見ていませんが、Haskellと共通点が多そうです。逆にどこが違うのでしょうか。",
    "url": "/2006/8/3/2006-08-03-post/"
  },
  {
    "id": "2006-08-05-post",
    "title": "[Python](http://www.python.org/)をちょっと試す",
    "date": "2006-08-05",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-08-05-post.md",
    "content": "Pythonをちょっとだけ使ってみています。\nファーストインプレッションとしてはBetter Lispと言って良いと思います。そして、書きやすさはRubyと大差ない気がします。\n関数型言語風味な所は沢山ありますが、完全な関数型言語ではないので幾つか気に入らない所があります。\n一つ目は、reutrnを書かないと行けない所です。関数の最後の評価値がreturnの値になればよいのにと思います。\n二つ目は、lambda の関数本体に式が1つしか書けない所です。\nどちらも致命的という程ではありません。慣れれば普通になるのだと思います。\nまた、Python食わず嫌いの人の議論の的になりやすいインデントによるブロックの表現は意外といいです。",
    "url": "/2006/8/5/2006-08-05-post/"
  },
  {
    "id": "2006-08-06-post",
    "title": "EmacsのSchemeモードを拡張する quack.el",
    "date": "2006-08-06",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-08-06-post.md",
    "content": "quack.elをEmacsに追加すると、lambdaがλ記号で表示されます。\n他にも、キーワードの色付けが標準よりも見易くなります。(小括弧が赤、文字列や#fなどが緑、コメントが水色等)\nGaucheプログラマの皆さん、試してみましょう。なかなかいいですよ。",
    "url": "/2006/8/6/2006-08-06-post/"
  },
  {
    "id": "2006-08-07-post",
    "title": "温故知新の [newLisp](http://www.newlisp.org/)",
    "date": "2006-08-07",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-08-07-post.md",
    "content": "newLispという言語を見つけました。\nnewLispというぐらいなので、新しいのかと思ったら、1991年からある言語なのですね。\nかといって、停滞しているわけでもなく、最近のLisp系言語の盛りあがりも手伝ってか継続的に新しいバージョンがリリースされています。\nで、どこが他のLispと違うのでしょう。ざっと見た感じでは、Common LispやScehemeの仕様を簡略化したような感じです。\n実際にプログラミングしてみないとわかりませんが、簡略化した部分で私が困る様な所は無さそうです。\nGaucheと比べると、ライブラリの豊富さと日本語サポートの面でGaucheに軍配が上がるので、乗りかえる事はないですが。\n少々制限が増えても、言語をシンプルにしようとする方向性は賛成です。ただ、そのバランスは難しいですね。\n一応、『何が違うの？』という部分を引用しておきます。\nnewLISP - FAQ\n 13. What are some differences between newLISP and other LISPs?\n newLISP has differences from other LISPs include: the working of\n lambda expressions; the existence of namespaces (or contexts);\n parameter passing; and of course, the newLISP API (function\n repertoire).\n Overall, newLISP's new ways of LISP programming make it faster,\n smaller, and easier to understand and learn.\n For a more detailed discussion, see Differences from Other LISPs .",
    "url": "/2006/8/7/2006-08-07-post/"
  },
  {
    "id": "2006-08-10-post",
    "title": "続図書館2.0",
    "date": "2006-08-10",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2006-08-10-post.md",
    "content": "以前、kiyoka日記:図書館2.0という記事を書きました。その続きです。\n最近私は、図書館に自分の本を寄贈しはじめました。\nなぜかというと、図書館に自分の本を置いてもらったほうが色々とメリットが大きいからです。\nそのメリットを挙げると、\n\n家の本棚がスッキリする\n図書館のWebページから検索可能になる\n頻繁に読まない本を有効利用でき、気分が良い\n\nSafari Bookshelfと併せて、私の本棚はどんどん検索可能になっていきます。\n私は人ほど所有欲というものが少ないのでしょうか。\nそんなことはありません。どうしても家に置いておきたい本もあります。\nでもトータルで見ると、半分以上は読みたくなったら再度図書館で借りればこと足りる本です。\nどうです？ あなたも図書館2.0化をすすめてみてはいかがでしょうか。",
    "url": "/2006/8/10/2006-08-10-post/"
  },
  {
    "id": "2006-08-15-post",
    "title": "色々見たけどやっぱり[Gauche](http://www.shiro.dreamhost.com/scheme/gauche/index-j.html)",
    "date": "2006-08-15",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-08-15-post.md",
    "content": "Perl/Ruby/Python/Guile/Gaucheをやっみたけど、一番書きやすいのはやっぱりGaucheです。\nでも、さすがに仕事では自分一人でコードを書くわけにはいかないのでLisp系言語処理系であるGaucheは無しになってしまいます。本当にもったいないです。\nプライベートなプログラミングは今の所はGauche一本になっていますが、このまま行く積もりです。\nもっとSchemeの定石を増やして美しいコードを書く為にも、そろそろGaucheのコミュニティーにコード還元しないとなーと思っています。\nDBD SQLiteくらいから始めるかな。",
    "url": "/2006/8/15/2006-08-15-post/"
  },
  {
    "id": "2006-08-21-post",
    "title": "プログラム・デザイナー宣言",
    "date": "2006-08-21",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-08-21-post.md",
    "content": "小野和俊のブログ:続・プログラム・デザイナー宣言\n 高林さんのUNIXにみる世代間の断絶にならって職人プログラマー/プログラム・\n デザイナー/UIデザイン・プログラマーを表にすると次のようにな\n る。...(略)...文系と理系と同じように、プログラマーにだって、一言でプロ\n グラマーとまとめるべきでない、それぞれ異なる指向性がある。\nもし、あなたはどんなプログラマーですか？と聞かれると『プログラム・デザイナー』だと答えるだろうと思います。\n昔は、組みこみプログラミング中心の仕事をしていたので、『職人プログラマー』に傾倒していたと思います。\nしかし、チューニングと読みやすさを天秤に掛ける局面では、どうしても読みやすさに重点を置いてしまう自分がいました。\nそして、ふとSumibi.orgはどうかと振返ってみると、『プログラム・デザイナー』と『UIデザイン・プログラマー』の両方の要素が上手く融合しているかなと思います。\nGaucheという言語処理系を使うことでメンテナンスしやすくし、SOAPを使ってモジュールの分離を明確化しました。\nまた、Ajaxにより誰でも使えるような分かりやすいユーザーインターフェースが実現できました。\nそんなわけで私も、小野和俊さんと同じ『プログラム・デザイナー』宣言をしたいと思います。\nそして、『UIデザイン・プログラマー』の視点も忘れずに驚きのあるサービスを作っていきたいと思います。\nさて、あなたはどれに当てはまるでしょうか？一度振りかえってみては？",
    "url": "/2006/8/21/2006-08-21-post/"
  },
  {
    "id": "2006-08-28-post",
    "title": "LL Ringの感想など",
    "date": "2006-08-28",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-08-28-post.md",
    "content": "LL Ringに参加しました。LL系のイベント参加は初めてです。\n私は発表者で参加したので、ゆっくり見れないプレゼンもあったのですが、\n全体的にプレゼンと発表内容のクオリティーが高く、本当に有意義な一日となりました。\nまた、普段IRC等でしか出会えない人とお話しできて楽しかったです。\n全部ちゃんと見れていませんので、見れたところだけ感想を書きます。\nちなみに、今はやりのWebアプリケーションフレームワークにひっかけてAsahi SUPER 'DRY'を飲んでいます。^_^;\nLanguage Update\n\nFORTH\n個人的にJOYに興味があるので楽しみだったのですが、残念ながら今回は昔ながらのFORTHの話で終わってしまいました。\nPython\nプレゼンの内容が説得力があり、本当に仕事でPython使っていっても問題無さそうに思いました。\n特にMicrosoftとGoogleがPythonにかなり肩入れしているので、今後もPythonを使いつづけても安心な感じです。\nRuby\n生でまつもとゆきひろさんを見たのは2回目です。\n現在はまつもとさんの地元の広告塔みたいな活動をやられているのですね。\n大変ですが楽しんで活動されている様子が伝わってきました。\nJavaScript\n舞台袖のプロジェクターが見えない場所しか確保出来なかったので内容は良く分かりませんでした。\nサーバサイドにもJavaScriptが入っていっているらしいです。JavaScript周辺は混沌状態だそうです。\nSqueak\n継続ベースのWebアプリケーションフレームワーク(Seaside)があるのを初めて知りました。\nKahuaみたいですね。(もしかしたら、Seasideの方が先かも知れませんが)\nActionScript\nリッチなUIを持ったアプリが簡単に作れるのがわかりました。\nご本人も言及されていましたが、LLといって良いのか？\n\nLLで関数プログラミング\n後で、Sumibi Ajax Clientの作者のKato Atsushiさんに聞いた話では、前提となる解説が少なかったので良く分からない部分があったとのことです。\nそうですね。関数型言語ならではの概念が解説なく議論されて、後で『ふつうのHaskellプログラミング』の著者の青木さんが噛み砕いた言葉で補足されるという感じでした。\nたぶんMonadとかは解説があってもあの時間で全員が理解しながら進むのは難しそうです。\n私的には、ちょうど良い内容だったので複雑なところです。\nもう1,2年もすればLLのイベントで扱っても大部分の人が理解できるようになっているかも知れません(希望も入っていますが...)\nその後、Haskellの型推論と形式仕様記述の話に入っていくのですが、形式仕様記述言語を使ったフェリカネットワークスの話には興味を持ちました。\nそのとき考えたことは、形式仕様記述言語を使って無限ループに陥ることを発見することはできるのかなと思いました。(確か数学的に出来ないのでは無かったでしょうか？参考:チューリングマシンの停止問題)\nこのへん、個人的にもっと知りたいと思っています。\n例えば、Haskellの遅延評価によって、無限リストをreverseしたとします。当然プログラムは終了しないのですが、それをHaskell用形式仕様記述言語を使って定義すればバグとして見つけ出すことが出来るのでしょうか。(ポイントは、VDM++で今出来るかではなく本質的に数学でできるか出来ないかです。)\n最後に会場からPythonでは、これまでのプログラミングスタイルを維持しつつ、関数型プログラミングも混在させることができるという意見があり、その日のPythonの評価が更に上がった気がします。",
    "url": "/2006/8/28/2006-08-28-post/"
  },
  {
    "id": "2006-09-03-post",
    "title": "オープンソース開発をする理由",
    "date": "2006-09-03",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-09-03-post.md",
    "content": "昨日吉岡さんと梅田さんの対談を見たことがきっかけで書いています。\nオープンソース開発者が世界中になぜ200万人程もいるらいしいですね。\n私自身もオープンソース開発者といっても問題ないと思いますが、私自身なぜオープンソースソフトウェアを開発しているのか明確に一言で説明することはできません。\nもちろんそれで生計を立てているわけではありませんので、それが理由ではありません。\nオープンソース開発者は世界中に200万人もいるらしいのですが、動機は個人個人全く異なると思います。\nオープンソース開発者の中には、すでに存在するソフトウェアプロジェクトに参加して、バグフィックスや機能アップを行う人もいれば、新しいアイデアを試す目的でソフトウェアプロジェクトを起こす人もいると思います。\n私の場合は後者です。アイデアを試す為にコードを書かずにはいられない質の様です。\nオープンソース開発者になろうと思ってなっているわけではありません。\nそして、たまたまその成果物をオープンソースという手段でもって発信するのが一番自分にとってメリットが大きいのです。(フィードバックを得られるなど)\n発信するためにコードを書くわけではなく、いろいろコードを書いている間に発信すべき物が出来てしまうというという感じです。\nもちろん、アイデアをちょっと試してみた結果、アイデアに価値が無いことが判明したり、実現不可能なことが判明したりしてボツになった物も沢山あります。\n本当は仕事で毎日使わせてもらっているソフトウェアに貢献したいのですが、それはなかなか難しいです。その辺は次の機会に書きたいと思います。",
    "url": "/2006/9/3/2006-09-03-post/"
  },
  {
    "id": "2006-09-13-post",
    "title": "Pythonとschemeの役割分担",
    "date": "2006-09-13",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-09-13-post.md",
    "content": "Pythonは仕事でscheme(Gauche)はプライベートでという役割分担になっています。\nRed Hat Enterpriseに最初から入っている、言語仕様が安定している、という理由でPythonを仕事で使っています。\nRubyもいいのですが、それらの条件をクリアできません。\nまた、プライベートでscheme(Gauche)を使っている身としては、RubyよりもPythonの方がschemeに似ているという感じがあってスイッチしやすいです。\nschemeの小括弧を全て取ったらPythonに見えなくもないような...",
    "url": "/2006/9/13/2006-09-13-post/"
  },
  {
    "id": "2006-09-26-post",
    "title": "作りたい物がいっぱいあって困る",
    "date": "2006-09-26",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-09-26-post.md",
    "content": "最近、作りたい物があって困ります。\nプログラミングの練習で作ってみたい物から、自分が毎日使いたいツールまで色々です。\n例えば、今練習で作ってみたい物はWikiですね。\n日本のWikiだけでも日本発の wiki クローンリスト、日本発の wiki クローンリスト2の様にたくさん有るのにまだ作るんですか、と思われるかも知れません。\nでも、Wikiはプログラミングの練習には良い題材だと思います。\n簡単にできるし、あたらしいアイデアを短時間で試しやすいのでは無いかと思います。\n『どれだけ短いコードで書けるか』とか『どれだけ読みやすく書けるか』とかにも挑戦してみたくなります。\nそう考えると、My言語も沢山有るけど、MyWikiもたくさんある理由が分かりますね。",
    "url": "/2006/9/26/2006-09-26-post/"
  },
  {
    "id": "2006-09-28-post",
    "title": "デザインは引き算",
    "date": "2006-09-28",
    "categories": [
      "デザインポリシー"
    ],
    "file_path": "_posts/2006-09-28-post.md",
    "content": "最近、シンプルな物に惹かれるようになりました。\nこれから私が作るソフトウェアはその路線を変えないつもりです。\nこのような記事を見つけましたが、全く同感です。私がSchemeを好む理由もコアがシンプルだからです。\nデザインは引き算 - emeitch ダイアリ\n プログラミング言語の世界でも、言語仕様を制定する方々を「言語デザイナー」\n と呼ぶことがあります。このように、「言語をデザインする」という考え方を\n したとき、「デザインは引き算」という哲学を一番貫いているプログラミング\n 言語は、私が最も愛するプログラミング言語「Scheme」でしょう。\n Schemeは「引き算的デザイン」で洗練された結果、自身が組込みで持っている\n 機能の数は、他の言語に比べ非常に少ないです。ですが、その洗練された機能\n 一つ一つの力は絶大で、それらを組み合わせることにより、他の言語では実現\n できないような「表現」を可能にします。このSchemeにも宿る「デザインは引\n き算」の哲学が、私を魅了す大きな要因なのだと感じます。\n『引き算的デザイン』と一言で言っても実践するのは結構難しいものです。\nその難しさはどこから来るのでしょうか。せっかく作ったものを捨てるのがもったいないからでしょうか。\nいいえ、そんな簡単な事なら誰でもできます。\n何が残すべき本質かを知ることが難しいのです。\n対象の問題をシンプルに解決したい場合、最低限何があればいいのか。\n些末な物を削ぎ落して、本質だけを残す。\nそれをやるためには、良い問題設定が必要になります。\n良い問題設定というのがまた難しい。\n時には引き算した結果、作らないという結論に至ることも多々あります。それも『引き算的デザイン』の一環として考えても良いでしょう。\n梅田さんも関連したエントリー「やめること」を先に考えようを書いていらっしゃいます。",
    "url": "/2006/9/28/2006-09-28-post/"
  },
  {
    "id": "2006-10-11-post",
    "title": "富豪的プログラミング",
    "date": "2006-10-11",
    "categories": [
      "デザインポリシー"
    ],
    "file_path": "_posts/2006-10-11-post.md",
    "content": "最近はコンピューターのCPUとメモリ容量が大きくなったせいで昔とは違うプログラミングスタイルが主流になりつつあります。\nそれは、富豪的プログラミングと呼ばれるスタイルです。\n経済的に富豪で無くても、コンピュータープログラミングの世界に限って言えば、誰もが富豪になれます。ケチケチせずに富豪になってしまいましょう。\n富豪的プログラミング\n プログラマというものは、つい昔の癖で効率的なプログラムを工夫したり資源\n を節約したりしようとしがちですが、ユーザインタフェースのプログラムを開\n 発するときにはこれが裏目に出ることもあります。\n というのも、ユーザインタフェースのプログラムでは機械の効率よりも使い勝\n 手が優先されるべきですし、プロトタイプの作成とその評価/改良のサイクル\n を数多く繰り返す必要があるのですが、計算機資源を節約しようとするとこれ\n らの条件が後回しになりがちだからです。\n これを解決するのが富豪的プログラミングです。以下のような富豪的プログラ\n ミングを行なえばこのような問題は起こりません。\n\nメモリや実行効率を気にしないでお気楽にプログラムを作る\n 効率を重視したプログラムは作るのが大変ですし、ちゃんと動かすにはデバッ\n グも大変です。富豪的プログラミングでは一番単純で短いアルゴリズムを使い\n ます。\n\n条件が変わる度にすべての計算や表示を行なう\n 再表示が必要な場所だけ書き直ししたり、出力のバッファリングをしたりする\n 貧乏性な工夫はバグのもとになるので行なわず、条件が変わる度に計算を再実\n 行したり全体を書き直したりします。\n\n富豪的プログラミングでは現在の状態を記憶しておく必要が少なくなるのでプ\n ログラムが短く、バグを含みにくくなります。また、ユーザが何か操作を行な\n う度にシステムがすぐに反応するので、直感的操作が可能になります。\nSumibi.orgもかなり富豪的な計算をしています。本来ならば、難しいコーディングをすればリダクションできる計算も、シンプルになるという理由だけで二度以上計算している部分もあります。\nそうすることで、数式をプログラムに展開せずにそのまま記述できています。\nこれで、小難しいバグを何個かは回避できているんではないかと思っています。\nそして、その浮いた時間をもっとクリエイティブな部分に投資します。\nこれぞ富豪的プログラミングの醍醐味です。",
    "url": "/2006/10/11/2006-10-11-post/"
  },
  {
    "id": "2006-10-13-post",
    "title": "Rubyの生産性の高さはどこまで本当か？",
    "date": "2006-10-13",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-10-13-post.md",
    "content": "私も何度も生産性の議論を書いていますが、生産性の議論は本当に難しいと思います。\nこのエントリーでも、やっぱり純粋に自由度と生産性と気持ちよさを考えると最後には、S式macroとMOP最強論に吸いこまれていますね。\nやっぱりJavaの発明者から言語界のブラックホールといわれるだけあるLispです。\nもし、括弧に対するアレルギーが無いのだったら、Lisp系言語は最高ですよ。\n例えば、Gaucheを使えば、メタプログラミングは当然できますし、ブロック構文とソックリのイディオムを提供する関数も標準で沢山あります。\n(with-input-from-file 'filename' ...)など。\n細かい話は置いておくとして、もしLisp系言語のパワーそのままで、ソースコードの外観もPythonやRuby程度の普通っぽさを持っていたら、もうちょっと普及の方向に動くと思います。\n誰か作りませんか？GaucheベースのRubyスキンとか。\nSchemeハッカーは言語の拡張にいそしんで、普通のハッカーは、PythonとかRuby構文でプログラミングを行うという分業体制ができます。\nこれが将来ほとんどの言語が辿り着く姿なんじゃないかと予言します。外れると思いますが。",
    "url": "/2006/10/13/2006-10-13-post/"
  },
  {
    "id": "2006-10-17-post",
    "title": "創作の秋",
    "date": "2006-10-17",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-10-17-post.md",
    "content": "私には、創作の季節というのがあるようです。\n毎年、10月から年末にかけて、作るべきものが一つの形を成してきます。\nこれが不思議なことに毎年この季節なのです。\n食欲の秋とか読書の秋とかありますが、私の場合は創作の秋のようです。\n思えば、Sumibi.orgも R＠eply.orgも10月位から開発スタートしています。\n次に作るソフトウェアのアイデアは有るんですが、まだ完全なイメージになってないので、もうちょっと寝かしてから取りかかります。",
    "url": "/2006/10/17/2006-10-17-post/"
  },
  {
    "id": "2006-10-25-post",
    "title": "テクノロジストの条件を読む",
    "date": "2006-10-25",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-10-25-post.md",
    "content": "この本の主題は生産性を上げる為には、良い問題設定を行う必要がある。という事だと思います。\n当たりまえの物を当たりまえの方法で作る時代は終わり、何を作るか、変えるか、組合せるかということを模索していく必要があります。\nイノベーションを継続して発生させる方法を確立するしかありません。そうしないと、発展途上国に生産性の面で追いつかれます。\nこの本での生産性とは、狭義の生産性、つまり単に同じ物を作った場合の生産性の事を行っているわけではありません。\n広義の生産性、つまり何を行い、何を行わないかという問題設定も含めての生産性です。\n但し、どれが良い問題設定だったのかというのは、初期段階で予想することは難しく、ある程度試行錯誤を行った後でしか分かりません。\nなので、たくさんの種を蒔いてその中から芽の出そうな物を取捨選択する必要があります。\nこのような活動が出来ていない企業はやがて、発展途上国の爆発的な成長の中で追いつかれてしまいます。世界はフラット化して行きます。\n最近、私は本当に危機感を持っています。人事では無いなと感じています。",
    "url": "/2006/10/25/2006-10-25-post/"
  },
  {
    "id": "2006-11-05-post",
    "title": "GaucheFestで時計アプリを作る",
    "date": "2006-11-05",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-11-05-post.md",
    "content": "Gauche関連のハックをする集まりであるGaucheFestに参加しました。\n最近GaucheFestではLingrというWebブラウザ上で動くチャットを使うようになりました。\nというわけで、Lingr上で使用する時計アプリを作っています。\nチャットルームに来る人は住んでいる国が違うことが多く、相手が朝なのか夜なのか、はたまたもう寝ないといけない時間なのか分かりません。\nそこで、同時に複数のタイムゾーンの時間が表示される時計を作っています。\nこの時計は画像になっており、Lingrの発言欄に貼りつけることができます。\nまた、内部はCGIになっており、貼りつけた時刻だけでなく現在時刻も同時に表示されます。\n過去ログをたどって行った時に、複数のタイムゾーンでその発言時刻が分かるというわけです。\nゆっくり作っているので、実際に使えるようになるのは来週位の予定です。おたのしみに。\n開発中の時計の画像も貼っておきます。(ここに貼った時計画像はCGIではないので時刻が変化しません。悪からず。^_^;)\n 開発中のTzWatchの画面\n\nコメント by so:\nおおう\n便利そうなものが！\n是非うちの居酒屋にも取り付けたいです、はい。\n\nコメント by kiyoka:\nsoさんご無沙汰です。\n最近soさんの居酒屋にいってないですが、時計ができたらお土産に持っていきます。^_^\nしばしお待ちを。\n\nコメント by Gyobani:\nA bit surprised it seems to smlipe and yet useful.\nコメント by so:\nおおう\n便利そうなものが！\n是非うちの居酒屋にも取り付けたいです、はい。\nコメント by kiyoka:\nsoさんご無沙汰です。\n最近soさんの居酒屋にいってないですが、時計ができたらお土産に持っていきます。^_^\nしばしお待ちを。",
    "url": "/2006/11/5/2006-11-05-post/"
  },
  {
    "id": "2006-11-14-post",
    "title": "Schemeが流行ってほしいかどうか",
    "date": "2006-11-14",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-11-14-post.md",
    "content": "最近LingrというチャットサイトでGaucheとScheme言語の話題に参加しています。\nそこで出た話なのですが、『Schemeがもっと流行って欲しいか？』という質問に対して、そこにいた人達は『そこそこ流行ってほしいけどRubyほどにははやって欲しくないなぁ』という意見でした。\n理由としては、みんながScheme使ってしまうと、今Schemeを使っている開発スピードのアドバンテージが無くなってしまうからです。\nPaul Grahamも言っていますが([1]|[2])、わざとLisp(Scheme含む)を使っている事を内緒にしてアドバンテージを維持しつづける。というのが戦略ですね。\nここで書いても私に影響力無いので問題ないですよね。^_^;",
    "url": "/2006/11/14/2006-11-14-post/"
  },
  {
    "id": "2006-11-20-post",
    "title": "KOFで『なでしこ』のクジラ飛行机さんと会う",
    "date": "2006-11-20",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2006-11-20-post.md",
    "content": "KOFでブースに立寄っていろいろお話しさせて頂きました。クジラ飛行机さんと言えば、日本語プログラミング言語『なでしこ』、『葵』等の作者の方です。\nやはり、面白い物を作られている方は自分と同じような空気を持っていらっしゃる方が多いと再認識しました。\nまだ世の中に無い物、技術的に新しいものには自然と引き寄せられてしまうサガの様なものでしょうか。\n今回は、直接お会いできたのでJoy programming languageというのがありますよ、と紹介させて頂きました。\n『これを使えば、日本語で関数型プログラミング出来るんじゃないでしょうか』なーんて生意気にも進言させて頂きました。\n短い時間でしたが『それは面白い』『かっこいいですねー』と言いあいながら楽しい時間を過ごさせて頂きました。\nクジラ飛行机さんはご自分の技術を使って、『なでしこ』、『葵』という形で『これからプログラミングに挑戦する人』に向けてプログラミング言語を提供されています。\nつまり、ターゲットがGeekではない人たちなんですね。\n考えてみれば、私もマニアックな技術をGeekではない人たちにわかりやすい形で提供するという事に高い満足を覚える人間です。クジラ飛行机さんを見習って行きたいと思います。\n技術的には結構なことをやっているんだけど、それを誰にでもわかりやすい形でシンプルに見せていく。\n難しいですが、挑戦しがいのあるテーマです。これからも負けない様にがんばって行こうと思いました。",
    "url": "/2006/11/20/2006-11-20-post/"
  },
  {
    "id": "2006-12-04-post",
    "title": "『算法少女』を読む",
    "date": "2006-12-04",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-12-04-post.md",
    "content": "は1973年に出版された本ですが、オープンソースのエッセンスを伝える良い本だと思います。\nこの本を読むと、なぜオープンソースプログラマはコードを書きつづけるのか、という理由が説明ができるんじゃないかと思います。\nちょっと算法(数学)とは違うかも知れませんが、十分共通する部分があると思います。\n最近復刊した様ですし、一度読んでみて下さい。さわやかな読了感があります。私は図書館で1973年のオリジナル(ハードカバー)のやつを借りて読みました。\nレビューや、復刊した経緯は[1]や[2]で読めます。",
    "url": "/2006/12/4/2006-12-04-post/"
  },
  {
    "id": "2006-12-06-post",
    "title": "RubyのまつもとさんのPodCastingを聞く",
    "date": "2006-12-06",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-12-06-post.md",
    "content": "まつもとさんのプレゼンのPodCastingを聞きました。\n英語ですが大変わかりやすいプレゼンですね。音声だけでも会場の笑い声からどんなスライドが出ているのかだいたいわかるのが不思議です。\nここではこんなPerlコードが表示されているんだろうなとか。\nこのプレゼンではどんな哲学でもって言語をデザインすれば良いかが語られています。\nプログラミング言語のユーザビリティーとは、という内容ですが、言語のデザイン以外にも使える本質的な話なので一度聞いてみてはいかがでしょうか。",
    "url": "/2006/12/6/2006-12-06-post/"
  },
  {
    "id": "2006-12-10-post",
    "title": "負のデザイン: 森本 武",
    "date": "2006-12-10",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-12-10-post.md",
    "content": "この本はすばらしいです。\nこの本は過去の私の記事kiyoka日記:デザインは引き算にて、ヤマケンさんに教えてもらった本です。ヤマケンさんありがとうございます。\nあまりに素晴らしいので引用させて頂きます。\n負のデザイン:11ページ『マイナス創造の自覚が負のデザインである』\n量的にも質的にもバランスを失った今日の社会において、デザインの最も重要\n な役割は、人間の暮らしを『本来の姿』に戻す調整機能にあると考える。プラ\n ス思考への偏重がプラス創造の超過となり、ごみを増やし、狭隘の住処に暮ら\n しを押し込めることになってしまったのだ。こうしたプラスへの偏向を是正す\n るためには、まず、マイナス創造という概念の存在を鮮明に自覚するところか\n ら始めなければならない。そこで、『負のデザイン』なのだ。それは、『止め\n る』『減らす』『小さくする』『省略する』『放置する』などの方向を強く意\n 識したデザイン行為である。\n負のデザイン:89ページ『創造とは、つくらない部分を決定づけていく行為である』\n創造とは、つくらない部分を決定づけていく行為である、ともいえる。また、\n 止め時を知ることが習熟の目安になるのも、つくらない部分に対する適切な評\n 価が可能になったことを意味するからである。\nどちらも、ソフトウェアをデザインしていて、なんとなくうまく行かないなと思っていた原因を鋭く突かれた気がしました。\n特に経験が少ない人がプロダクトをデザインする場合、その機能が必要かどうか判断できないので、全て追加してしまう(プラス思考)傾向があると思います。\n負のデザインとひと口に言っても簡単そうで実は難しいのです。でも、意識して負のデザインをしていくことは人生において必ずプラスに(笑)なるはずです。\nというわけで、この本を読んでいてつい思いついてしまったので、早速sourceforge.jpにプロジェクトを申請してしまいました。(注意:まだ中身は空っぽです)\n中身は少しづつこのブログでも紹介していきます。\nkiyoka流の負のデザインの始まりです。\n\nコメント by ヤマケン:\nkiyokaさんの趣味に合ったようでよかったです。この本は今は亡きbit誌の書評で知ったんですが、固定観念を破るよいきっかけになったと思っています。物事はシンプルな方が良い、というのは当時もお題目としては念頭に置いていたんですが、後ろ向きに全力疾走するなんて発想はありませんでしたから。\n\nコメント by kiyoka:\nヤマケンさん、コメントありがとうございます。\nこの本にはすっかりはまりました。\nところで、『後ろ向きに全力疾走する』というキーワード面白いですね。\n一瞬、Predocのロゴをそういう絵にしたら面白いかもと思いました。^_^\nコメント by ヤマケン:\nkiyokaさんの趣味に合ったようでよかったです。この本は今は亡きbit誌の書評で知ったんですが、固定観念を破るよいきっかけになったと思っています。物事はシンプルな方が良い、というのは当時もお題目としては念頭に置いていたんですが、後ろ向きに全力疾走するなんて発想はありませんでしたから。",
    "url": "/2006/12/10/2006-12-10-post/"
  },
  {
    "id": "2006-12-16-post",
    "title": "『負のデザイナー』憲章",
    "date": "2006-12-16",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-12-16-post.md",
    "content": "負のデザイン: 森本 武を図書館に返却しちゃうので、『負のデザイナー』憲章(心得みたいなもの)を書いておきます。\nこの憲章に従えば自動的に多くの人に使われるソフトウェアができるわけではないのですが、私がデザインで迷った時にはこれに従うつもりです。\n特にプライベートで作るソフトウェアでは開発リソースも限られるので、開発者とユーザーの両方を幸せにするにはよい戦略だと思います。\nJoel on Softwareの『シンプルさ』に反対意見の記事がありますが、この記事ではその肥大化した機能の『取り除きかた』の上手さには言及していません。\nそれとは、気づかれないように取り除く方法を学べばみんな幸せになれると思います。機能を削って我慢するのではなく、同じことをシンプルなやりかたで置き換えたりする。マイナスハックですね。\n負のデザイン:12ページ『負のデザイナー』憲章\n - 負のデザイナーは、それとわかる業績を残そうとしてはならない。\n - 負のデザイナーは、容易にデザイナーであることを悟られてはならない。\n - 負のデザイナーは、生命の自然な営みを最優先する人間として、創造に関わらなければならない。",
    "url": "/2006/12/16/2006-12-16-post/"
  },
  {
    "id": "2006-12-17-post",
    "title": "プログラミング中に聞く音楽(1)",
    "date": "2006-12-17",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2006-12-17-post.md",
    "content": "プログラマーの皆さんはコードを書いている最中に音楽を聞きますか？\n私はJazzとかHip Hop、それにクラシックを聞くことが多かったのですが、最近『波』の音を収録したCDを聞きながらコードを書いています。\nHip Hopとかは、ノッている時には良いのですが、ときどきしんどいと感じる事があります。\nそんな時は、『波』の音がいいですよ。\n私の聞いているCDを紹介します。\nニューカレドニアの波の音を聞きながらコードを書くと、Schemeの丸括弧がさざなみに見えて来る...かも知れません。(笑)\n冗談はさておき、再帰的なプログラムを書いている時など、瞑想しているような落ちついた状態で取り組めます(迷走していることも多いのですが;笑)。一度おためしを。",
    "url": "/2006/12/17/2006-12-17-post/"
  },
  {
    "id": "2006-12-20-post",
    "title": "Gaucheをもっと気軽に使おう",
    "date": "2006-12-20",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2006-12-20-post.md",
    "content": "Matzさんところ、Danさんところの関連エントリーを読んで。\n私も、Lisp系方言の一つSchemeでプログラミングをする『にわかな奴』です。さらに、Common Lispに至っては使ったことがありません。\nSchemeとEmacs LispばっかりなのでLisp選民ではなく、落ちこぼれに分類されると思われます。\nでも、こう感じてしまうLispという言語はなんなんでしょうね。\n皆が皆、ジェダイマスターになる必要はないのです。( ジェダイマスターで無くても作れるSumibi.org。)\nそういえば、Schemeの人達とチャットをしていると『にわか』な人はあまりいません。\n私の様に読解いやな法則: にわかな奴ほど語りたがるに該当する人にもっと頻繁に出会えてもいいのになぁ。",
    "url": "/2006/12/20/2006-12-20-post/"
  },
  {
    "id": "2006-12-22-post",
    "title": "お金で買えない物『好奇心』について",
    "date": "2006-12-22",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2006-12-22-post.md",
    "content": "江島さんのブログエントリを読んで、再度『好奇心』の価値について考えます。\nグーグルが無敵ではないことはエンジニアだけが知っている:江島健太郎 / Kenn's Clairvoyance - CNET Japan\n 技術論やイノベーションを語る上で、エンジニアの士気や好奇心やモチベーショ\n ンほど重要なものはない。てごわい大きな機能を実装するときには、まず関係\n のない小さなバグを２つ３つ潰したりして準備体操し、乗ってきた勢いにまか\n せてワーッと書く。文章を書くときだって、音楽をつくるときだって、グッと\n くる言い回しがひらめいたり、かっこいいリフが頭に浮かんだり、そういうと\n きの嬉しさに乗じて一気に書き上げてしまうもんじゃない？エンジニアにとっ\n ては最も素朴な意味での好奇心がダントツに重要で、いったん好奇心が失われ\n たら研究費を1000億積もうがどんな手を打とうが無駄なんだ。どこぞの研究所\n の所長さんゴメンね、でもこれが現実なんだ。\n私も数々の半分ネタ・半分本気のプロジェクトを生みだして来ましたが、ノリって大事だと思います。作曲家が一晩で名曲を書きあげるエピソードをよく聞きますが、それにも似ていますね。\n江島さんのおっしゃる様に好奇心は何ものにも代えがたい価値あるものです。お金で買えない物の代表ですね。いくらゴールドのマスターカードを持っていても買えません。\nどうしても実現可能か試してみたくなった好奇心。プライスレス。\nグーグルが無敵ではないことはエンジニアだけが知っている:江島健太郎 / Kenn's Clairvoyance - CNET Japan\n まず、「ワタシはこの技術が絶対に次にくると思う」っていう言明には意味が\n ない。ビジョナリーぶって色々なところにツバつけておいて、将来に「ほら\n ね」って言いたいだけだ。悪いけど、それがどんなに先鋭的な専門分野であれ、\n 口には出さずとも同等以上にわかってる奴はつねに100人はいる。それを論文\n にまとめたりブログに書いたりできるやつが10人ぐらいいて、本気でそれの実\n 現に自分の人生を賭けるやつは1人しかいないっていうだけのことさ。\nというわけで、とにかく行動を起こしたもんがエライ、さらには実装したもんがもっとエライという世界なんですね。\n面白いアイデアを思いついたけど、実装してちゃんと使える形にまで持っていける人というのはなかなかエライと思います。\nそして、その行動の源というのはやっぱり好奇心なのでは無いでしょうか。\n生まれた好奇心を壊さない様に大切に扱いながら、なおかつ完成形に持っていく為に全力疾走することができる。\nずっと、そういうエンジニアを目指して行きたいと思います。\n関連エントリ\n- [kiyoka.2006_01_24]創作心理創作にいたるまのでステップ(1)\n- [kiyoka.2006_02_06]創作心理創作にいたるまのでステップ(2)\n- [kiyoka.2006_07_04]創作心理 思えば原点は『ひとりでに賢くなるマシンを作りたい』だった",
    "url": "/2006/12/22/2006-12-22-post/"
  },
  {
    "id": "2006-12-24-post",
    "title": "『グーグル - Google 既存のビジネスを破壊する』",
    "date": "2006-12-24",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2006-12-24-post.md",
    "content": "を読みました。\nいろんな所で書評されているので、あまり書く必要は無いのかも知れませんが...\nこの本では、どんな業界が破壊されてどんな業界が生まれるか事例を挙げて説明されています。\n結局、大企業と個人の力が検索エンジンの力によってフラット化され、同じ土俵で戦える時代が来たということが説明されています。\nそれによって、当然良い影響を受ける人と悪い影響を受ける人が出てくる。\nGoogleはその速度を速めて、既存のビジネス(特に広告収入で成立っている既存メディアなど)に対して兵糧攻めを浴びせるという戦略なのですね。\n最初から最後まで一般の人にも分かる言葉で書かれているのが、好感が持てました。\nエンジニアでない方も安心して読めます。\nさあ、個人としてはどう生きるべきなのか。気になるので今各所で引用されている『フラット化する世界』も読む予定です。",
    "url": "/2006/12/24/2006-12-24-post/"
  },
  {
    "id": "2007-01-02-post",
    "title": "今年の抱負",
    "date": "2007-01-02",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2007-01-02-post.md",
    "content": "今年もいろんなモノを作っていきたいと思います。\nまずは、Schemeの腕をもっと上げる事。そしてシンプルで強力なソフトウェアやサービスを作り出して行きたいです。\nこれまではモノを作る事に集中するあまりエレガントなコードを書く為のスキルアップがおろそかになっていたと思います。\nデザインは『負のデザイン』を指向してシンプルに、実装は力のある言語でエレガントに、が目標です。\nところで、私は毎年1つ新しい言語を習得するということをしてきたのですが、今年はまだまだSchemeで行きます。\n今年からSchemeのマクロをどんどん使ってDSL(Domain Specific Language)をデザインする練習をしていく方向に切りかえます。\n他の言語で新しい概念を学習するよりも学習効率が良い気がしているからです。\nそもそも、新しい言語を習得する目的は新しい概念を習得する事にあるのですから、わざわざ遠まわりをする時間がもったいと感じています。\n(Lisperのみなさん、この考えかたは極端過ぎますか？ そんなことないですよね。)\n今年もオープンソースソフトウェアの活動を通じてスキルアップをしていければと思っています。",
    "url": "/2007/1/2/2007-01-02-post/"
  },
  {
    "id": "2007-01-04-post",
    "title": "プログラミング中に聞く音楽(2)",
    "date": "2007-01-04",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2007-01-04-post.md",
    "content": "([kiyoka.2006_12_17] プログラミング中に聞く音楽(1)) の続きです。\n結局、これをAmazonで買いました。\nなかなかいいですね。最初は鳥の鳴き声とかが聞こえてきて邪魔になるかなと思ったのですが、自然音だからなのか、集中するとそうでもありませんでした。\nところで、立体音響の自然音を聞く時は、ちゃんとしたヘッドフォンがおすすめです。\n私が愛用しているのは、このヘッドフォンです。\n実際にヨドバシカメラでいろいろ聞き比べてみてから買ったのですが、その際に自分の聴力の限界を知ってしまいました。\nある値段まで達すると、どのヘッドフォンを使っても同じでした。\n幸か不幸か、これ以上の値段の物を買っても良さが分からないのですね。^_^;\nそんなわけで、長時間使っても疲れにくいオープンエアータイプで、かつコードが断線しにくそうな太い物を選びました。\nなんだか今日のエントリは珍しく普通のブログ風になってしまいました。(笑)",
    "url": "/2007/1/4/2007-01-04-post/"
  },
  {
    "id": "2007-01-10-post",
    "title": "図書館について",
    "date": "2007-01-10",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2007-01-10-post.md",
    "content": "図書館についての議論が活発になってきたので、私も参加してみたいと思います。(例えば、404 Blog Not Found:図書館の費用対効果、図書館の公共性をめぐる論争と経済学。など)\n私も図書館にお世話になっている一人であることは、過去の日記にも書いた通りです。([kiyoka.2006_05_30]Life 図書館2.0、[kiyoka.2006_08_10]Life 続図書館2.0)\n私が感じる図書館の問題を、アルファブロガーの皆さんが書かれているような広い視点ではなく、個人的な視点から書いてみたいと思います。\n- ベストセラーの本の予約待ちが長い。\n- したがって、上下巻がある場合、下巻が手に入るまで時間が空く(2ヶ月から3ヶ月とか)\n私は大阪府に住んでいますが、私の市の図書館には、『フラット化する世界』は上巻2冊、下巻2冊となっています。\n上巻の予約を入れたのは約半年前だったのですが、最近やっと順番が回ってきて借りることができました。\n下巻が借りれるのは、このままいけば 3ヶ月後です。\n実は、問題はそれくらいのもので、メリットの方は計り知れません。やはり無料である事が大きいです。\nビジネス書やマーケティング関連の本は一度読めば事足りる事が多く、図書館を最大限利用しています。\nまた、Sumibi.orgのアルゴリズムの参考書として必要な数学関連の本は内容を良く吟味した上で買うことができます。\nその中でも一番のメリットは、無料なので大量に借りて拾い読みできるということです。\n私は、図書館は必要だと思いますし、公共性は非常に高いと感じています。\nですので、『読み終わった本はブックオフに売りにいく』よりも、『読み終わった本は図書館に寄贈する』をしています。\n先の『フラット化する世界』などの様に価値があって、人気の高い本は既に数冊あっても寄贈を受けつけてくれるそうです。",
    "url": "/2007/1/10/2007-01-10-post/"
  },
  {
    "id": "2007-01-14-post",
    "title": "SF小説もたまにはいいかも",
    "date": "2007-01-14",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-01-14-post.md",
    "content": "図書館で予約していたSF小説が届きました。\n最近、予約本が大量に届いて大変です。\n本を沢山読んでいるので、プログラミングをあまりしない日が続きます。(本当は色々やりたいのですが...)\n昔は大量にSF小説を読んだものです。\n意外とSFとプログラミングは関係ないと思われる方もいらっしゃると思いますが、突拍子も無いアイデアを思いつく為にはある程度読んでおく必要が有るのかも知れません。\nSF小説の中にはかなり妄想的な話が多いですが、技術の進歩が早い現代に於いては、数年もすれば『あながち妄想ではなかったのね。』というような事もあります。\nSF小説に出てくる人々の生活をユースケースとして利用する面白い物を思いつくかも。\nそんなわけで少しの間、読書とブログが中心の生活が続く予定です。",
    "url": "/2007/1/14/2007-01-14-post/"
  },
  {
    "id": "2007-01-18-post",
    "title": "『フラット化する世界(上)』を読む",
    "date": "2007-01-18",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-01-18-post.md",
    "content": "最初は『そうか、世界のアウトソーシングの現実はこんなに進んでいるんだな』と思って読んでいたんです。もうSF気分で楽しく読んでおりました。\nしかし、読み進むに従って、ここまで進んでいるとは認めたく無くなって来ます。一種の恐怖ですね。\n最近になって少し前に出版された近未来的SFに書かれた内容が一部実現していたりして、本当に技術の進歩が速い時代だなーと思い知らされます。\n(携帯電話でGPS・テレビ電話とかね。 ネットフォースではウァージルと呼ばれていましたね。)\n逆説的ですが、だから近未来的SFが面白いのかも知れません。\n私達は長生きしなくても技術の進展が面白い様に感じ取れる時代に生きています。しかし、だからこそこの変化の激しい時代にどうやって楽しく生きるかという方が重要になってきている気がします。\nうかうかしていると、変化を楽しむ余裕も無く、逆に変化に押しつぶされる立場になってしまう可能性が大きいのです。\n手遅れになってから右往左往しないで済む様に、常に創造的な仕事ができるレベルにスキルアップしないといけないということを教えてくれる本です。\n人生は楽しむには短かすぎ、苦しむには長すぎます。\nあなたはこの本を読んでエキサイトできる人ですか？それとも恐怖を感じる人ですか？\n上巻には下巻への続きとなる章が最後に設けてあるのですが、それを読むと、ちゃんと準備すればフラット化の波は別段恐れることは無さそうに思えます。\nまた下巻を読んだら感想を書きます。(3ヶ月後ですけどね^_^;)",
    "url": "/2007/1/18/2007-01-18-post/"
  },
  {
    "id": "2007-01-22-post",
    "title": "『神は沈黙せず』読了",
    "date": "2007-01-22",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-01-22-post.md",
    "content": "読了しました。なるべくネタバレしないように書きます。\n昔、人口生命に興味を持って、GAとか使って色々やっていたことが懐かしくなりました。\nもういちどやってみようかなと思わせるSF小説です。\n筋金入りのリチャード・ドーキンスファンにはオススメです。\nこれ以上は言えません。小飼弾さんもおっしゃるように、読んどいて損はないSFです。",
    "url": "/2007/1/22/2007-01-22-post/"
  },
  {
    "id": "2007-01-28-post",
    "title": "Joyベースのシェルスクリプトなんかどう？",
    "date": "2007-01-28",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-01-28-post.md",
    "content": "再びOverview of the language JOY関連のチュートリアルやFAQを読み直しました。\n今度はちゃんと理解できたと思います。\nさて、以前これを『なでしこ』の様に日本語プログラミングに応用したら良いんじゃないかと書きましたが、撤回します。\n日本語プログラミング言語の想定ユーザーとしては、『これからプログラミングを覚えたいという人』に設定するのが良いと思いますが、Joyはそういう人たちにとって難易度高すぎです。\n関数型言語として設定されており、手続き型言語でおなじみのforループなどがなくmapやfilterというコンビネーターを使うことが前提となっています。\nJoyの構文を日本語の文脈にうまく当てはめたとしても、プログラミングの初学者に向けて易しい解説をする自信はありません。^_^;\nむしろ、もっとハッカー向けの用途に適用したほうがいいと感じました。(ハッカーには日本語プログラミングは必要無さそうですので。日本語変換するのめんどくさそうとか言いそう。)\n例えば、shellスクリプトなんかに適用すると良いのではないかと思います。\n下記は、Joyで未定義の関数を外部コマンドから探して実行することを想定したコードになっています。\n# bash\nfind . -name '*.c' | xargs wc -l\n\n-- 同じものを Joy風 shellスクリプトで書いた場合\n'.' '-name' '*.c' find\n*'-l' wc* map\nprint\n\n-- こんな事もできます。\n# bash\nlst=`find . -name '*.c'`\nwc -l ${lst}\ngrep keyword ${lst}\n\n-- 同じものを Joy風 shellスクリプトで書いた場合\n'.' '-name' '*.c' find dup\n'-l' wc\n'keyword' grep\n\nもしかして、mapの実行をCPUの数だけ並列実行するなんてことも許されるのかも。(mapに渡す関数に副作用が無いことを前提にすればOK？)\nライブラリはUNIXのコマンドツールをめいいっぱい利用することにすれば実用レベルに持っていくのもたやすいかも。\nこの言語もそういう悲しい運命をたどるのか、それとも使えるのか。\nそれは、結局どれだけ短いコードで問題を記述できるかがにかかかっているのだと思います。\n実際に作ってみないと分かりませんが、いい線行っていると感じます。自分で作ろうと思うところまでは行きませんが...\nそういえば、私はscshをインストールしたけど、結局お手軽感が無くて使わなかったりします。\n今迄、こういう妄想系アイデアを思いついてもlocalでメモするだけだったり、あるいは忘れてしまったりしていたので公開していくことにします。",
    "url": "/2007/1/28/2007-01-28-post/"
  },
  {
    "id": "2007-02-04-post",
    "title": "『負のデザイン』と『Getting Real』",
    "date": "2007-02-04",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2007-02-04-post.md",
    "content": "Vista とか Office 2007とか、新しくリリースされるソフトウェアはどんどんリッチになっていきますね。\n一方で、ユーザとしては複雑になる一方のソフトウェアにウンザリしている人もいるでしょう。\nそんな中、いろんな人が逆の考えかたで差別化しようと挑戦しています。\n37singalがそんな哲学を持っているのは有名ですが、reddit.comで『Getting Realの日本語訳』が有るのを知りました。\n『負のデザイン』にも通じるこの考えかた。\n\n物事をシンプルに保つことで競争に勝つという考えかたです。\n世の中の流れをよそに、トップスピードで逆走してみましょう。\nまた違った風景が見える事でしょう。\nシンプルを実践しているサービス、プロダクトを紹介しておきましょう。\n言わずと知れた37signalsの製品群\nUIEngineのデザイン・プリンシプル\nGoogle\nそして手前味噌ながら、Predocです。\n私は今もバリバリ逆走中です。一足お先に行ってます。",
    "url": "/2007/2/4/2007-02-04-post/"
  },
  {
    "id": "2007-02-08-post",
    "title": "バベル案内",
    "date": "2007-02-08",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-02-08-post.md",
    "content": "バベル案内について。\nこのエッセイは、C、C++、Lisp、Java、Perl、Ruby、Pythonの言語の紹介になっています。\n多少乱暴だけど、言っていることは説得力があり概ね賛同できます。\nバベル案内\n Lispを学ぶのは簡単ではない。大きな飛躍がいるのだ。Cみたいなプログラム\n をLispで書けるというのでは十分でない。そんなのは無意味だ。CとLispはス\n ペクトルの反対の端に位置している。他方が上手く扱えない領域で大きな力を\n 発揮するのだ。\n Cがコンピュータがどう動作するかのモデル化に最も適した言語とすると、\n Lispは計算というものがどう振る舞うかをモデル化するのに最も適した言語だ。\nそう、Lispはスペクトルの反対側に位置しているんです。\nだからこそ、C言語とLispの両方を学ぶ必要があると思います。\nここで言っていることは私の経験と大体一致しています。\nただ、気になる所もあります。\n\nRubyを持ち上げすぎ(この著者は最初にRubyが好きと書いていますが)\nRubyは言語仕様が安定しないという部分でビジネスに使えないという事実があります。\nその辺は適用範囲によっては結構問題になります。\nPHPが紹介されていない。\n取りあげるに足らないということでしょうか...(笑)\n\n私のまわりでは本当にLispユーザーのサンプル数が少ないので実態が良く分からなかったのですが、\nこれを読むと、Lispという言語が日本国外においてもあまりに特殊のようですね。\nAmazonの初期のメンバーのほとんどがLispを使っていたというのは、輝かしい過去の出来事として語られています。\nこれは、オールドタイプがどうこうとか、世代間のギャップが関係しているわけではなさそうです。\nすごいエンジニアは大抵、Lisp『も』使っているということでしょうか。\nそんなわけで、私は仕事ではPythonを関数型言語として使いながら、いつかLispに優しい世の中がくることを願いつつLispのマクロの練習をコツコツやる日々です。",
    "url": "/2007/2/8/2007-02-08-post/"
  },
  {
    "id": "2007-02-19-post",
    "title": "Gimpでスクリーンショットを加工するテク",
    "date": "2007-02-19",
    "categories": [
      "コンピュータ"
    ],
    "file_path": "_posts/2007-02-19-post.md",
    "content": "私がオープンソースソフトウェアのマニュアルに使っているスクリーンショット加工テクを紹介します。\nちょっとした工夫でユーザー視点のドキュメントになります。\n逆に言うと私の様に文章で説明するのが得意では無い人にもおすすめです。\nスクリーンショットを使えば、百聞は一見にしかずで、文章で色々説明しなくても済むことが増えます。\nそう、オープンソースソフトウェアのドキュメントは意外と重要です。\nいくらソフトウェアの品質が良くても使う前にドキュメントの取っ付きやすさで、試用するかしないかが決まります。(実際自分の行動を振りかえって見ると、そうなので)\n私が使うテクニックは、こんなやつです。\n sumibiで検索すると最初に表示されます。\n\n『Googleで 'sumibi' で検索すると最初に表示されます。』という説明で使えばぴったりですね。\n注目してほしい所にスポットライトが当たっています。\nこれは、NHKスペシャルで公文書の注目してほしい箇所を写しだす時によく使われているテクを真似たものです。\n次回は、この画像をGimpを使って作る手順について解説します。",
    "url": "/2007/2/19/2007-02-19-post/"
  },
  {
    "id": "2007-02-27-post",
    "title": "ブログとJazzの類似点",
    "date": "2007-02-27",
    "categories": [
      "ブログ"
    ],
    "file_path": "_posts/2007-02-27-post.md",
    "content": "Jazz好きなのでかなりバイナスがかかっていると思って読んで下さい。\nブログとJazzは、ある類似点を持っていると思います。\nそれは、自分の思う所を一方的に表現するという表現者-対-受け手(読者 or リスナー)の関係性においてです。\nブログは文章を使って思っていることを、それに対してJazzはインプロビゼーションで瞬間のフィーリングを音楽に組み立てます。\nJazzは他の音楽と違って、リスナーに迎合せず自分のスタイルを貫きます。(あるJazzプレイヤーがインタビューでそう言っていました。)\nブログのほうも、とりあえず自分一人の考えを一方的に書いてみて、どうだったかはコメント、トラックバックとして受けとります。\nブログを書くことで、Jazzを演奏しなくても心理的にはJazz奏者と同様の心理体験ができているんじゃないかと思っています。\n一つもコメントが付かなかったりすると、受けないJazz演奏をやったミュージシャンと同じ寂しさを覚えたりもできます... orz\nちなみに、何回聞いてもいいなというCDはこれです。高校生の頃に買ったやつです。\n特に『Blue In Green』が美し過ぎです。\nパーソネルは、マイルス・デイビスとジョン・コルトレーンとビル・エヴァンスという惑星直列級となっております。",
    "url": "/2007/2/27/2007-02-27-post/"
  },
  {
    "id": "2007-03-06-post",
    "title": "『イノベーションのジレンマ−技術革新が巨大企業を滅ぼすとき』を読む",
    "date": "2007-03-06",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-03-06-post.md",
    "content": "『顧客の意見に熱心に耳を傾け、新技術への投資を積極的に行い、常に高品質の製品やサービスを提供している業界トップの優良企業。ところが、その優れた経営のために失敗を招き、トップの地位を失ってしまう。』\nその理論を実証して見せてくれる本です。\n一見逆説的なこのコンセプトなのですが、読み進むうちに納得する、というより、結構心当たりがあるぞという思いにさせられます。\nもしこの理論が本当なら、意識して避けなければならない事象です。\n私は数年前から、いかにイノベーションを継続的に生み出すかという事に興味があって、『ドラッカー』の本なども読んでいますが、私と同じ興味をお持ちの方は読んでみてはいかがでしょうか。\nドラッカリアンの人にもこんな補足的な視点があるということで、いい刺激になるのではないでしょうか。",
    "url": "/2007/3/6/2007-03-06-post/"
  },
  {
    "id": "2007-03-12-post",
    "title": "個人の中のイノベーションのジレンマ",
    "date": "2007-03-12",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-03-12-post.md",
    "content": "前回の続きで『イノベーションのジレンマ』の応用編です。\nこれを読んでいて、これは個人の中にも同様のジレンマが存在するのでは無いかと思うようになったので書いておきます。\nうまくまとめられるか自信がありませんが。\n『優秀な人が、なぜ突然破壊的技術が必要なプロジェクトにおいて、その優秀さ故、見当違いのデザインをしてしまうのか。』\n『イノベーションのジレンマ』の話は、個人のリソース割当問題と考えると、個人にも適用できるコンセプトなんでは無いのでしょうか。\nここでは、リソースとは個人がスキルアップに使える時間と考えてください。\nまず、優秀な技術者は顧客の要望する技術、つまり市場価値の高い技術を習得する事に一番時間を使ってきたはずです。またそれが正しいとされています。\nそして、どんどん多くの顧客に頼られる技術者となっていきます。やがてそれが連鎖して仕事のリピート率は上がり、その顧客と技術者の関係は強固に成っていきます。\n当然、その関係が強固になればなるほど、信頼関係も大きくなり、ビジネス的な金額も大きくなるため良好なサイクルが形成されます。理想的なWin&amp;Winの関係です。\nその結果、より要望にあった技術を習得するモチベーションが上がり、個人はよりブラッシュアップを続けて行きます。\n供に成長でき、どこから見ても問題は無さそうに思えます。\nそれ以外の、これまでの延長線とは違う破壊的技術への備えは重きを置かれる事はありません。\nしかし、技術者として長期的に見た場合、これが正しいと言えるかは疑問が残ります。\nそれがこのエントリーのテーマです。\nここで言う破壊的技術とは、オープンソースのミドルウェアやライトウェイトな言語環境などをイメージしていただけるといい思います。\n全てを作りこむのではなく、これらをまるでテコの原理のように利用して、問題を自分の脳味噌に入る範囲、自分の使える時間の範囲に縮小します。\nしかし、問題なのはこの技術を習得するには時間がかかるため、要望されてから習得するようでは間にあいません。\n日頃顧客から信頼され、優秀と思われているが故にそれが仇となってしまいます。\nテコを使わずとも解決できる場合は多いし、成功してきたはずです。\nしかし、それがある一定の臨界点を越えると完全に問題に直面したり、ライバルに出し抜かれます。\nライバルから見ると優秀かも知れないけれど、過剰品質なものができ、しかも一番重要な『柔軟性』が失われた物になります。\nこれは、品質の定義が変わってしまった市場では完全に出し抜かれているのに、本人たちはその古い定義の上での優秀さで目が曇ってしまい、失敗した事に気づくのに遅れます。\n優秀な人が、その優秀さ故に陥るジレンマです。\nでは、どうすればよいのでしょうか。\n私の提案です。\n今すぐにお金になりそうな技術以外にも目を向ける。あるいは目を向ける理由を見つけることです。\n一つは自分自身が顧客になってしまうことです。\n自分が使う物を一番コンパクトに美しく作る方法を探し続ける事です。\nそれは、結果的に破壊的技術(＝イノベーション)であることが多いはずです。それによって、破壊的技術を習得してしまうという連鎖を続けます。\nこれでイノベーションのジレンマをいくらか回避できるのではないかと思っています。\n但し、前述の本『イノベーションのジレンマ』とも共通することですが、どれが次の破壊的技術かはあらかじめわかりません。\nそれは、早々に諦めることですね。全く何もしない『ゼロ』よりは確実に一歩前へ行っている筈です。\nあとは、時間をどれくらい破壊的技術に配分するかという問題があるので、別のジレンマもあるわけですが...\n自分は優秀で前途洋々と思っている人ほど、気を付けてくださいませ。ちなみに、私は優秀ではありませんのでテコの原理を使うわけです。\n追記: 中島聡氏のエントリに図解、イノベーションのジレンマを見つけたので、リンクしておきます。",
    "url": "/2007/3/12/2007-03-12-post/"
  },
  {
    "id": "2007-03-18-post",
    "title": "日本語の『原因』、『リスク』という言葉は英語の意味とは異なる？",
    "date": "2007-03-18",
    "categories": [
      "コラム"
    ],
    "file_path": "_posts/2007-03-18-post.md",
    "content": "原因とリスク、どちらも良い事よりも悪い事に対して使う場合が多いと思います。\n例えば、『その問題が起きた原因は？』『失敗するリスクを回避するには？』等のように。\n『その利益が増えた原因は？』とか、『納期が延期されるリスクは？』という使いかたをする場面は殆どありません。\n本当は英語では後者の使いかたも言葉の用法としては正しいのにも関わらずです。\nそれだけ、世の中の出来事は良いほうに転ぶことがまれだということでしょうか。\nそれとも、日本ではうまく行った時の備えや分析には価値が無いということなのでしょうか。たぶん、こちらが正しそうですね。\nはたまた、心配性のマインドセットを持つ国民性から来るものかも知れません。\nしかし、英語から日本語に翻訳された本には、そういう、結果として成功する場合の文脈についても『原因』や『リスク』という言葉が使われていることが多いように思います。\nやっぱりこれも、『責任』も『自己責任』と言い直さないとresponsibilityの意味が表現できないのと同じ様に、日本語になってしまっているということでしょうか。\n\nコメント by じょりちょこ:\n大橋巨泉が、週刊現代の連載の中で「英語では、dangerは可能な限り避けなければならないものだが、riskはチャレンジには付き物であって、対策をこうじれば良いとされている。日本語ではどちらも『危険性』という意味であり、きちんと対策をこうじれば良いはずのriskも回避する方向で検討されがちだ」という意味の話を書いていました。\nPaul Grahamが「私が初めてプログラムを書き始めたころ、それはBasicで書いていたのだが再帰を使いたいなどとは考えなかった。そんなものがあるとは知らなかったのだ。私はBasicで考えていたのだ。私は反復アルゴリズムしか知らなかったのだから、再帰を使いたいなんて考えられるわけがない」という指摘が、ここでも当てはまるのでしょうか。\n\nコメント by kiyoka:\nじょりちょこさん、いつもコメントありがとうございます。\n大橋巨泉もそんな事を言っておりましたか。\n英語を勉強すると、単に英語が役に立つだけでなく視野が広がるというメリットがありますね。\n日本語の意味の狭さを実感しつつ日本語を使うことができるようになります。\n\nPaul Grahamが「...」という指摘が、ここでも当てはまるのでしょうか。\n当てはまるんじゃないでしょうか。\n私はLispをやるようになってから、RubyやPythonでも、ここぞというところで関数型プログラミングを使える様になりました。\nそのちょっとした視野の広さのマージンが有るのと無いのとでは、次の更なるマージンを獲得出来るかどうかに影響する気がします。\nそして、そのマージンはどんどん雪だるま式に増えていくんだと思います。\n最初のマージンがゼロだと、視野が広がるきっかけが運まかせになってしまう気がします。\nかなり感覚的な話ですが...\n\nコメント by じょりちょこ:\n日本語には日本語の良いところがあって、英語では表現できない部分もたくさんありますけど、技術的な文章や、契約的な文章など、物事と物事の関係をハッキリと表現したいとき、日本語は不自由だなあと感じることは多いですね。（逆に、物事をふわっと表現したいときには便利。）\n最近、困ったこととしてはriskをidentifyするというときのidentifyがうまく日本語にできなかったことがあります。この文脈では、その特定のriskを他のriskから識別し、そのriskについて話題にしたいときに「それ」と特定できるように識別子を与えることを言っているのですが、日本語の「識別する」にはそこまでの意味はないですよね。「特定する」でも違いますし、せいぜいのところ「リスクの存在を確認し、個別化する」とでも訳すしかありません。同僚相手ならidentifyするで済みますけどね...\nコメント by じょりちょこ:\n大橋巨泉が、週刊現代の連載の中で「英語では、dangerは可能な限り避けなければならないものだが、riskはチャレンジには付き物であって、対策をこうじれば良いとされている。日本語ではどちらも『危険性』という意味であり、きちんと対策をこうじれば良いはずのriskも回避する方向で検討されがちだ」という意味の話を書いていました。\nPaul Grahamが「私が初めてプログラムを書き始めたころ、それはBasicで書いていたのだが再帰を使いたいなどとは考えなかった。そんなものがあるとは知らなかったのだ。私はBasicで考えていたのだ。私は反復アルゴリズムしか知らなかったのだから、再帰を使いたいなんて考えられるわけがない」という指摘が、ここでも当てはまるのでしょうか。\nコメント by kiyoka:\nじょりちょこさん、いつもコメントありがとうございます。\n大橋巨泉もそんな事を言っておりましたか。\n英語を勉強すると、単に英語が役に立つだけでなく視野が広がるというメリットがありますね。\n日本語の意味の狭さを実感しつつ日本語を使うことができるようになります。\n\nPaul Grahamが「...」という指摘が、ここでも当てはまるのでしょうか。\n当てはまるんじゃないでしょうか。\n私はLispをやるようになってから、RubyやPythonでも、ここぞというところで関数型プログラミングを使える様になりました。\nそのちょっとした視野の広さのマージンが有るのと無いのとでは、次の更なるマージンを獲得出来るかどうかに影響する気がします。\nそして、そのマージンはどんどん雪だるま式に増えていくんだと思います。\n最初のマージンがゼロだと、視野が広がるきっかけが運まかせになってしまう気がします。\nかなり感覚的な話ですが...",
    "url": "/2007/3/18/2007-03-18-post/"
  },
  {
    "id": "2007-03-27-post",
    "title": "機械学習の将棋プログラムBonanza",
    "date": "2007-03-27",
    "categories": [
      "コンピュータ"
    ],
    "file_path": "_posts/2007-03-27-post.md",
    "content": "Bonanzaが強いらしいです。\nついにコンピューター将棋にも機械学習の時代が来るのでしょうか。\nTVで見たんですが、過去の対局データを大量に読みこんで学習しているそうです。\nGoogleの自然言語翻訳も機械学習でしたよね。\n今後もいろんな機械学習の応用が目に見える形で登場してくると思います。楽しみです。",
    "url": "/2007/3/27/2007-03-27-post/"
  },
  {
    "id": "2007-04-03-post",
    "title": "On Lispを買う",
    "date": "2007-04-03",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-04-03-post.md",
    "content": "野田開さん出版おめでとうございます。\n出版前に誤字脱字修正パッチを野田さんにお送りさせて頂いたりしたので思い入れがある本です。\n製本された物を手に取るとなんだか嬉しいです。\n後1/3ほど読んでいないのでじっくり読みたいと思います。",
    "url": "/2007/4/3/2007-04-03-post/"
  },
  {
    "id": "2007-04-11-post",
    "title": "驚愕、元LiperのPythonコード",
    "date": "2007-04-11",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-04-11-post.md",
    "content": "Spelling Corrector\nこのコードすごいですね。集合演算使いまくりですね。\nオブジェクト指向でさえないし...\n私の普段のPythonコードも徐々にこれに近づいているんですけど。\nリスト内包表記の嵐です。\nこれ以上lambdaとか内包表記を使いすぎるとチームメンバに読んでもらえないコードが量産されそうです。\nやりすぎに気を付けよう。\n早速、Shiroさんが同じものをGaucheで書かれていますね。これです。\n同じく内包表記使いまくりですね。",
    "url": "/2007/4/11/2007-04-11-post/"
  },
  {
    "id": "2007-04-15-post",
    "title": "『デザイニング・インターフェース』を読む",
    "date": "2007-04-15",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-04-15-post.md",
    "content": "第二章だけでも読む価値があります。\n特に、有名サイトがそうなっているからという理由で漠然とユーザーインターフェースを決めている人には読んで頂きたいです。\nアプローチが全然変わると思います。\nこの本の良いところは、各ユーザーインターフェースのデザインパターンになっており、各パターンには、そのパターンを選択した場合に予想されるユーザーの心理状況や選択するメリットなどが細かく書かれているところです。\nちなみに、私は図書館に買ってもらい、日本語で読みました。\n次にユーザーインターフェースを検討する時は、Safari Bookshelfで参照するという作戦です。",
    "url": "/2007/4/15/2007-04-15-post/"
  },
  {
    "id": "2007-04-18-post",
    "title": "機能が少ない安心感",
    "date": "2007-04-18",
    "categories": [
      "デザインポリシー"
    ],
    "file_path": "_posts/2007-04-18-post.md",
    "content": "最近の私のトレンドは、機能が少なくシンプルなもの、いわゆる『 [kiyoka.2006_12_10] 負のデザイン』なのですが、\n関連記事を見つけたので紹介させて頂きます。\n 小野和俊のブログ:スリムなソフトウェア\n 使い慣れていた Office の機能をほぼすべての機能を持った ThinkFree では\n なく、機能が少ない Google Spreadsheets。Google Spreadsheets を使ってい\n ると、ずいぶん昔、まだソフトウェアにたくさんの機能が備わっていなかった\n 頃に感じていたような安堵感を感じることがある。\n機能が少ないおかげで生まれる安心感というのは確かにあると思います。\n少ない機能で柔軟性が高く、応用もきくというのが理想です。でも、そういう良い物を作るのは難しいです。\n常に挑戦していきたいと思います。",
    "url": "/2007/4/18/2007-04-18-post/"
  },
  {
    "id": "2007-04-23-post",
    "title": "Lispの真実",
    "date": "2007-04-23",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-04-23-post.md",
    "content": "Lispの真実を読んで極端過ぎる意見だとは思いながら、Lispを一度も試したことが無いというのはあまりに残念なプログラミング人生だと思います。\n Lispの真実\n Lispを学ぶことはあなたの人生を変える。\n あなたの脳はすごく大きくなり、そんなに大きくなるものだとは思わなかったほどになるだろう。\n あなたは自分のアプリケーションをすべて、ほんの一握りのコードで書き換えるだろう。\n 社会はあなたを避けるようになる。あなたも社会を避けるようになる。\n あなたは自分のまわりの物やまわりの人すべてに不満を感じるようになる。\n人にもよりますが、こんな感じでLispをやるとLisp脳とも呼ぶべき状態になります。\n一度Lisp脳になると、他の言語が複雑に見えるようになります。\n複雑な構文を覚えるのが面倒臭くなります。\n良くも悪くも真実なのだからしかたがありません。\nもし、同時にEmacsを使いこなしていたら自体はもっと深刻です。\nEmacs以外のIDEを避ける様になります。\nその後、Lispから離れる人もいますが、きっと無駄にはならない体験だと思っているでしょう。\n食わず嫌いにならずLispも試してみてください。",
    "url": "/2007/4/23/2007-04-23-post/"
  },
  {
    "id": "2007-04-24-post",
    "title": "『郷に入れば郷に従え』とPredocのプレゼン",
    "date": "2007-04-24",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-04-24-post.md",
    "content": "プログラミング 郷に入れば郷に従え\nEmacsLispをGaucheの方言にあわせたい。\n単なる思いつきです。\n例えば、map、 filter、string-catなどの関数は頻繁に使うので同じ関数名であればコードを書くときにストレスが無いだろうなと思います。\n思うだけで実際にはやりません。\nそんな変な方言で書いたソースコードはEmacsLispに慣れた人にとってはメリットが薄いだろうと思うからです。\nあなたも、Perlっぽい記述ができるLispマクロを作ったり、Pascalっぽい構文をCプリプロセッサで定義する等、一度はやった事があるはずです。\nしかし、そんなことをしなくてもある程度人間が慣れてしまえばどうってことは無くなります。\nこの場合は『郷に入れば郷に従え』という諺通り行動したほうがよさそうです。\nPredocLife Predocについてしゃべる予定\n4月のLMSでしゃべります。\n簡単なデモもやる予定です。\n関西にいらっしゃる方は参加してみては？",
    "url": "/2007/4/24/2007-04-24-post/"
  },
  {
    "id": "2007-04-27-post",
    "title": "イノベーション＝エンジニアの士気",
    "date": "2007-04-27",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2007-04-27-post.md",
    "content": "本 『フラット化する世界(下)』を読む\nフラット化する世界(上)\nさて、下巻のキーワードは『無敵の民』ですかね。無敵の民とは、簡単に言うと『かけがえの無い人材』と説明されています。フラットな世界では企業と個人を問わず、誰もが同じツールを使って同程度の生産性の仕事をこなすことができます。そして、その環境がアウトソーシングに拍車をかけます。フラットな世界には『代替可能な仕事と代替不可能な仕事の二つ』に収斂していきます。そこで、先進国にする私達はどうすればいいのか。当然、答えは代替不可能な仕事をする能力を身に付けるということになります。平均的に優秀な技術者ではインド人技術者に仕事を取られてしまいます。要するに代替可能なわけです。無敵の民になるためには自分の得意な事を見つけてスキルを磨き続けるしかありません。\n梅田さんのエントリの様に自信を持って好きな道に進み続けるしか無いのだと思います。『神は自ら助ける者を助ける』です。大変な世界がやってきます。フラットな世界で生きることを楽しめる様になりたいものです。\n創作心理 イノベーション＝エンジニアの士気\n続き。代替不可能な仕事を手に入れるための一つの方法として信じたことに賭けてみるということかな？信じたことに賭けられる人はそう多くないはずです。日本でも少しづつそういう考えかたをする人が増えてきたかも。\nいや、そういう環境が整って次々成功者が出てこないと、いずれ日本は希望もなく、そして先進国でさえ無くなってしまうと思います。\nグーグルが無敵ではないことはエンジニアだけが知っている:江島健太郎 / Kenn's Clairvoyance - CNET Japan\n さて、ぼくがグーグルの成功から学んだ教訓はこういうことだ。\n まず、「ワタシはこの技術が絶対に次にくると思う」っていう言明には意味が\n ない。ビジョナリーぶって色々なところにツバつけておいて、将来に「ほら\n ね」って言いたいだけだ。悪いけど、それがどんなに先鋭的な専門分野であれ、\n 口には出さずとも同等以上にわかってる奴はつねに100人はいる。それを論文\n にまとめたりブログに書いたりできるやつが10人ぐらいいて、本気でそれの実\n 現に自分の人生を賭けるやつは1人しかいないっていうだけのことさ。",
    "url": "/2007/4/27/2007-04-27-post/"
  },
  {
    "id": "2007-05-06-post",
    "title": "OSSのプレゼン資料はブログ記事を整理するだけでできる",
    "date": "2007-05-06",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2007-05-06-post.md",
    "content": "私の場合、日々感じた事、それによって、出てきた疑問や問題を解決する過程の記録としてもブログを使っています。\n『何が問題か？解決方法は？そのポリシーは？』という感じで日々メモしているため、作ったソフトウェアのプレゼン資料を作ろうと思い立ったら、そこからは案外短時間で完成まで持って行けます。\nそうすると、プレゼン資料はブログ記事の寄せ集めなので、ブログを読んでいる人からすると繰り返し同じことを聞かされていることになるのでは？という心配もごもっともです。\nしかし、幸か不幸か実際のプレゼン当日のオーディエンスはブログを読んでいる人とオーバーラップしないので問題ありません。\nオープンソース開発をやっている人は、ブログで自分の動機や問題点と解決策を恥ずかしがらずに書いておく事をおすすめします。\nほとんどの記事が手前味噌に成りがちで、なんと厚顔なと思われる事を書く必要があるので抵抗がある人もいるかも知れませんが、『そんなに大量の人が読んでいるわけではない』と思えば書けるものです。\nブログは文字どおり日々のログを、プレゼン資料で振返り・まとめをという位置付けです。",
    "url": "/2007/5/6/2007-05-06-post/"
  },
  {
    "id": "2007-05-07-post",
    "title": "ソーシャルウェア・ユーザビリティ",
    "date": "2007-05-07",
    "categories": [
      "ユーザビリティ"
    ],
    "file_path": "_posts/2007-05-07-post.md",
    "content": "一人で使う時のソフトウェア・ユーザビリティよりもコミュニティーで使う時のユーザビリティ、つまりソーシャルウェア・ユーザビリティの感覚が求められる様になってきたというおはなしです。\n 小野和俊のブログ:ソーシャルウェア・ユーザビリティ\n これまで長い期間に渡って、ソフトウェアは一人で使うためのものだった。\n ここで言う「一人で使う」ということの意味は、自分以外にも家族も使うかど\n うかというような意味ではない。例えばテキストエディタは他の PC の前に座っ\n ている誰かとリアルタイムで共同編集するものではなかったし、ゲームはネッ\n トに接続せずに自分一人で遊ぶものだった。そういう意味でソフトウェアはこ\n れまで長い期間に渡って一人で使うためのものだった。\n だからこれまで私たちは、ユーザビリティのことを考えるとき、まず自分が一\n 人で使うときに使いやすいかどうかを考えてきた。\n 従来のユーザビリティをソフトウェア・ユーザビリティと名付けるとすれば、\n ここ数年で、もう一つのユーザビリティとして、ソーシャルウェア・ユーザビ\n リティとでも呼ぶべき感覚が求められるようになってきているように感じる。\nこれを読んでいて、私が以前から興味を持っている『いつかは自分でWikiエンジンを作る』というテーマになかなか踏みだせない原因として、この『ソーシャルウェア・ユーザビリティの改善プロセス』を構築するノウハウがないことにあるということに気が付きました。\n私が作りたいWikiエンジン(もしくはCMSかも知れません)は、一人で使う場面とコミュニティーで使う場面の両方でストレスが無い様にしたいと考えています。\n問題は、コミュニティー(もしくはチーム)で使う場面において、ストレス無く使えるかどうか確かめる場合、試しながら改善する環境が必要で、それを手にいれる方法です。グループウェアなどの開発ってどうやってやっているのかを知りたい今日このごろです。サイボウズさんあたりは、このへんのノウハウが潤沢にあるんだろうなと思います。\nところでWikiって、むかしから大量に既製品が有るのに、いまだに新しい実装が出現しつづける原因は何なのでしょうか。選択肢が多すぎて評価する前に作ってしまうのか、それとも、ユーザーの視点で見るとそれぞれの評価基準に合っていないのか。ソーシャルウェア・ユーザビリティにも、ユーザーの視点によって評価基準が何通りもあって、評価できないのが現実なんでしょうか。",
    "url": "/2007/5/7/2007-05-07-post/"
  },
  {
    "id": "2007-05-08-post",
    "title": "『考える方法―解決の思考・創造の思考・思考なき思考』を読む",
    "date": "2007-05-08",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-05-08-post.md",
    "content": "ゴールデンウィークに読みました。Amazonランキングで見てもあまり売れていないため、あまり知られていないと思いますが、いい本なので紹介します。ちなみに著者は、『負のデザイン』を提唱している森本武氏です。\n『考える』ことについて、ありとあらゆる方向から、ノウハウや技術、さらには人間の思考の限界、思考なき思考まで分かりやすい文体で綴られています。思考なき思考の章に至っては、宗教的とも哲学的とも思える心理描写でありながら宗教を肯定しない希有な本です。\n創造的な仕事の中に喜びを感じる人、創造的な人を目指す人に読んでほしい本です。",
    "url": "/2007/5/8/2007-05-08-post/"
  },
  {
    "id": "2007-05-22-post",
    "title": "ユーザビリティに関連した本",
    "date": "2007-05-22",
    "categories": [
      "ユーザビリティ"
    ],
    "file_path": "_posts/2007-05-22-post.md",
    "content": "id:bokuno-nouさんからトラックバックをもらったので記事を読みました。\nその記事に掲載されている『誰のためのデザイン?』という本が気になったので、毎度の事ながら図書館で予約いれときました。\n最近コードを書かずにアイデアをメモしたり本を読んだりという事ばっかりしていますが、いつか絶対元が取れると信じて学習を続けています。\nid:bokuno-nouさんの記事でハッと気づかせて貰ったのは、50％ルールの事です。\n今CMSをデザインしているところですが、うっかり最初から完璧な物を作ろうとしすぎている自分がいます。\nもうそろそろ、作りながら軌道修正していくいつものパターンに入ったほうが良いかなと思いはじめています。",
    "url": "/2007/5/22/2007-05-22-post/"
  },
  {
    "id": "2007-06-18-post",
    "title": "creativeよりuseful",
    "date": "2007-06-18",
    "categories": [
      "デザインポリシー"
    ],
    "file_path": "_posts/2007-06-18-post.md",
    "content": "毎度の事ながらリアルタイムには反応できませんが、弾さんのエントリーより。\n 404 Blog Not Found:creativeよりuseful\n 誰でもcreativeになれるが、誰でもusefulになれるわけではない。そして私自\n 身も含めて、人はusefulなものにしか代価を支払わない。「頭がいいのに成功\n できない」ただ一つの充分な理由が、これ。いくら頭のいい解決法でも、他者\n がそれを使えなければ、それは文字通り「使えない」のだ。\nこれまでの私のオープンソース作品を振りかえって見ると、奇抜さでは負けない所はあるんですが、本当に『使える』物は少ないです。\nもっと使える物を作らないとなぁと反省している所です。\n広く普及するもので無くても、こっちでは役に立っているよ、というようなフィードバックがもらえるようなものを作って行くぞっ。\n『奇抜で実験的なもの』という路線をちょっと変更したいなと思う今日このごろです。",
    "url": "/2007/6/18/2007-06-18-post/"
  },
  {
    "id": "2007-06-26-post",
    "title": "『誰のためのデザイン?』を読む",
    "date": "2007-06-26",
    "categories": [
      "ユーザビリティ"
    ],
    "file_path": "_posts/2007-06-26-post.md",
    "content": "読み終わりました。\n1990年に出版された本なんですが、古さを感じない本です。\nマウスの説明とかがあったり、Internetがこのまま広がれば、データが増えつづけてほしい物が見付けだせない悪夢の時代が来ると予言されています。Googleなんてものが登場する前の本ですので。それ以外は全く古くなっていません。\nこの本を読むと、いかに世の中の電化製品や電気のスイッチなどのデザイナがユーザビリティをないがしろにしているかを思い知らされます。\nこの著書で問題提起された後も、世界は良くなっていないばかりか逆に悪い方向に向かっている気がします。\n近年の家電に内蔵されているコンピュータの性能は上がり続け、さらに開発言語も生産性が上がり続けています。その結果、簡単に機能てんこもりの製品が出来てしまいます。\n挙句の果てに、簡単なことも簡単にできない、マニュアルを見てもよく分からないというような事態が日常茶飯事です。\nこの本をじっくり読んで、丁寧にユーザービリティの高いものを作るだけで一歩抜きんでたものができそうだと感じる方も多いはず。\nさて、ユーザビリティが高い製品が評価される時代はやってくるのでしょうか。",
    "url": "/2007/6/26/2007-06-26-post/"
  },
  {
    "id": "2007-07-19-post",
    "title": "『マーケティング10の大罪』再読",
    "date": "2007-07-19",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-07-19-post.md",
    "content": "二回目流し読みしました。\n自分のためにも十戒をメモ。本書曰く、壁に掲げておけとな。\nこれは、オープンソースプロジェクトでも実践可能なのでは。\nというより、ビジネスになる前のオープンソースプロジェクトであっても、マーケティングは必要だと思います。\n フィリップ・コトラー:マーケティング10の大罪\n マーケティングを通じて高い生産性と収益性を実現するための十戒\n 1. 市場を細分化し、最も好ましいセグメントを選択したうえで、各セグメントにおいて確固たる地位を築くべし。\n 2. 顧客のニーズ、知覚、選好、行動を明確に把握し、すべての関係者が顧客への奉仕と顧客満足のために邁進するよう動機づけよ。\n 3. 主要な競合他社の動向を把握し、相手の強みと弱みを把握せよ。\n 4. 関係者の中からパートナーとなるべき相手を見出し、手厚く扱うべし。\n 5. 機会を見出し、機会に優先順位をつけ、最も優れた機会を選択するためのシステムを構築せよ。\n 6. マーケティング計画を策定するためのシステムを管理し、長期的にも短期的にも優れた計画を立案せよ。\n 7. 製品ミックスならびにサービス・ミックスを厳しく管理せよ。\n 8. もっとも費用対効果に優れたコミュニケーション・ツールとプロモーション・ツールを活用して強力なブランドを構築せよ。\n 9. 企業はマーケティング部門にリーダーシップを発揮させ、マーケティング部門と他部門がチームとして行動するように働きかけよ。\n 10. 競争優位性の源泉となるテクノロジーを継続的に導入せよ。",
    "url": "/2007/7/19/2007-07-19-post/"
  },
  {
    "id": "2007-07-25-post",
    "title": "Lisperとそれ以外の人とが見ているものの違い",
    "date": "2007-07-25",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-07-25-post.md",
    "content": "このイメージよく出来てます。\n\nそうなんです。\nまわりの non-Lipserと話しをするとみんなこんなイメージを持っているようです。括弧ばっかりやん。と。\nでも、いつのまにか括弧は見えなくなります。(↑のイメージと同じように括弧が薄くなる感じ)\nなので、PythonとLispの両方をやっている私にはPythonのコードとLispのコードはかなり近い見た目に思えるのです。\nLispをやったことないPythonプログラマの方がいらっしゃったら、この意見に賛成されるんでしょうか。その辺が知りたいです。",
    "url": "/2007/7/25/2007-07-25-post/"
  },
  {
    "id": "2007-07-27-post",
    "title": "スクロールリングの回転方向はどっちが標準？",
    "date": "2007-07-27",
    "categories": [
      "ユーザビリティ"
    ],
    "file_path": "_posts/2007-07-27-post.md",
    "content": "iPod nanoをもらった事がきっかけで自分が ケンジントンのトラックボールのスクロールリングの回転方向とは逆だと気が付きました。(実は私がデフォルトとは逆の設定に変更したのです)\niPodは時計回りにリングをなぞるとカーソルは下方向に動きます。\niPodは設定変更できない様なので、ケンジントンのトラックボール側をiPodと同じ回転方向に戻しました。\nこの回転方向の標準って有るんでしょうか。\niPodがこれだけ普及している今では、『iPodの時計回りが下方向がデファクトスタンダード』と言い切っても問題無いのかも知れませんね。\n ケンジントン\n\niPod nano",
    "url": "/2007/7/27/2007-07-27-post/"
  },
  {
    "id": "2007-07-30-post",
    "title": "一つの言語を習得しても，やはり他の言語を学ぶのは難しい",
    "date": "2007-07-30",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-07-30-post.md",
    "content": "一つの言語を習得しても，やはり他の言語を学ぶのは難しい - カレーなる辛口Javaな転職日記\n 言語を知らない人ほど「井の中の蛙」になりやすく，「他の言語は簡単にマス\n ターできる」なんて暴言を吐くのではないだろうか．\n同意見です。\nC/C++/Java/C#/D/PHP とかをやっているうちは、まあそういう感覚を持ってしまっても無理はないと思います。\nいわゆる Fortranを祖とする言語だけを見ているうちは、です。\nしかし、いざLisp/Haskellを習得しようとした途端に、その考えが浅かったということを思い知ります。\nいわゆる Lispを祖とする、Fortranとはスペクトルの反対側にある関数型言語達です。\nさらには RubyとPython 等はそのミックスが可能になので、オブジェクト指向プログラミングと関数型プログラミングの両方の抽象化技法をミックスしたプログラミングによって抽象度を更に上げることができます。\n『習得』を『使いこなす』という意味で使うなら、『簡単ではない』と言っておくのが正解だと思います。",
    "url": "/2007/7/30/2007-07-30-post/"
  },
  {
    "id": "2007-08-16-post",
    "title": "On Lisp読書会#1に参加する予定",
    "date": "2007-08-16",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-08-16-post.md",
    "content": "On Lisp読書会#1に参加します。日程は8月19日(日曜日)です。\n関西の隠れLisperを探しに行くという別の目的もあります。\nOn Lispを持っているけど読めてない方は参加してみてはいかがでしょうか。",
    "url": "/2007/8/16/2007-08-16-post/"
  },
  {
    "id": "2007-08-19-post",
    "title": "On Lisp読書会#1に参加した",
    "date": "2007-08-19",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-08-19-post.md",
    "content": "On Lisp読書会#1に参加しました。\n新しい隠れLisperの方は見つかりませんでしたが、これからLisperになりそうな方はいらっしゃいましたよ。個人的にはGauche本が出ればLisperが増えそうな予感です。(ちなみに、以前からLisperだった方は一人来られてました。)\nところで、Extreme Readingはいいですね。一人で読むよりもいろいろな疑問点が挙がるので勉強になります。\n今回の収穫は『複数言語を扱うメンバーの共通語(公用語？)はRubyが良い』こと、『Rubyの関数をfirst classにしたければ lambda で関数定義すればいい』こと、『関数型プログラミングのメリットは体験してみないと本の説明だけでは伝わりにくい』ことです。\n特に、最後の件はSumibiの開発を例に補足させてもらいました。\n興味のある方は是非次回から参加してみて下さい。もちろん、私は次回も参加する予定です。\n追記: 中本さんがまとめをブログ記事にされています。ありがとうございます。本当に助かります。",
    "url": "/2007/8/19/2007-08-19-post/"
  },
  {
    "id": "2007-09-02-post",
    "title": "Schemeのlambdaがようやく分かってきた",
    "date": "2007-09-02",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-09-02-post.md",
    "content": "なんでもλを前に何度も読んだけど、自分のモノになってなかったようです。\n最近、named letと継続渡しオンパレードなWiLiKiのパーサをいじることで、ようやく全部同じだという感覚が掴めました。\n何なんでしょう。こういう質の高いチュートリアルを読んでも掴めなかった感覚が実際に自分でやってみると掴めるというのは。\nなんでも経験ですね。\n誰か『なんでも経験』ていう文章書いて下さいませ。",
    "url": "/2007/9/2/2007-09-02-post/"
  },
  {
    "id": "2007-09-05-post",
    "title": "RubyのリハビリでFizzBuzz問題",
    "date": "2007-09-05",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-09-05-post.md",
    "content": "同僚からRubyの質問を受けることが多くなりました。\nというわけで、RubyのリハビリがてらにFizzBuzz問題をやってみました。\nええ？Rubyに見えないって？\nRuby on Railsやる人はこれくらいのコードは書けないといけないようです。^^\nP.S. 関係ないですが、それにしてもtDiaryのソース貼りつけは落とし穴いっぱいですね。空行はダメなんですね。ちょっとハマりました。\n#!/usr/local/bin/ruby\n\nfizzbuzz_in_range = lambda { |range|\n fizzbuzz = lambda { |x|\n (0 == x % 15) ? 'FizzBuzz' :\n ((0 == x % 3 ) ? 'Fizz' : \n ((0 == x % 5 ) ? 'Buzz' : x.to_s)) }\n range.map( &amp;fizzbuzz ) }\n\nprint fizzbuzz_in_range.call( (1..100) ).map { |x| x + ' ' }, &quot;\\n&quot;",
    "url": "/2007/9/5/2007-09-05-post/"
  },
  {
    "id": "2007-09-30-post",
    "title": "RubyかHaskellのバイリンガルが迷うとき",
    "date": "2007-09-30",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-09-30-post.md",
    "content": "sshi.Continual - 「同一のもの」をつかんだ気になれる記述ができるかどうか？より\n rubyとhaskellを双方手足のように扱える人にとって、ある問題を解くときにrubyで書くかhaskellで書くかを選ぶ基準を考えてみると思考実験になるだろうか？\n (略)\n 双方を使えるんだから、その人は双方の脳内モデルのスイッチはできる。ではその人はその問題をどちらで解こうとするのか？\n 個人的にはある問題、作ろうとしているプログラムを考えた時に、「あ、これはRubyのほうが書きやすそうだ」とか「あ、これはhaskellだと楽だな」とか思うことはある。\nこれを読んで思いだしたが、OnLisp読書会に出た時に、同様にRuybとHaskellのバイリンガルな人がけっこういた。\nどちらも一部では流行の言語ではあるが、理由はそれだけでは無いだろう。\nそれぞれ、オブジェクト指向と関数型の脳内モデルをコードで表現するのには現存する言語では、おそらく一番理想に近い言語だと思う。\nOCamlのユーザーとGaucheのユーザーは、それには同意せず、これ一つだけ覚えればOKだよというかも知れない。\n私もそのGacuheユーザーの方だ。\nもっとも、Gaucheでコードを書いている間も、局面次第で手続き型、オブジェクト指向型、関数型の脳内モデルをスイッチしているわけではあるが。\nRuby+Haskellの二刀流とGaucheの1刀流と最終的にどちらがパフォーマンスが良いのかに興味がある。\nもっとも、人生は1度きりなので両方経験することはできないんだが。",
    "url": "/2007/9/30/2007-09-30-post/"
  },
  {
    "id": "2007-10-02-post",
    "title": "[配列ベースプログラミング言語「ざぼん」](http://d.hatena.ne.jp/ha-tan/20070926/1190805421)",
    "date": "2007-10-02",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2007-10-02-post.md",
    "content": "趣味的にっき - 配列ベースプログラミング言語「ざぼん」より\n LispにS式があってマクロがあるように。\n Rubyの配列を使ってプログラミング言語を書いてみました。Ruby本体を使ってプログラム(= 配列)を操作することで、Lispのマクロのようなことができます。言語の名前は「ざぼん」です。「ざ」をいただきました。\n面白い。Lisp慣れしている人は簡単にはじめられそう。\nライブラリはRuby標準が使えるので、ライブラリに不足は無し。\n但し、関数型プログラミングの為のライブラリが無いと実用的には使えないかも。(ネタにマジレス？)",
    "url": "/2007/10/2/2007-10-02-post/"
  },
  {
    "id": "2007-10-12-post",
    "title": "[WIRED VISION / 「ゲーマーの後悔」は終わらない](http://wiredvision.jp/news/200710/2007100221.html)を読んで",
    "date": "2007-10-12",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2007-10-12-post.md",
    "content": "たしかにゲームを長時間した後の後悔は大きい。\n私は、それが怖くて10年ほどRPGなどの時間がかかりそうなゲームはやっていないし、据置型ゲーム機も一台も持っていない。\nちょっと寂しい人生のような気がしないでもないが、結果としてその時間をオープンソース開発にあてることが出来たと勝手に解釈している。\nオープンソース開発に使った時間は膨大だが、なぜか後悔しない。\nそれはなぜか。\nオープンソース開発も複数の人間でコラボレーションして或る種のゲームのような楽しさも持っている。でもゲームでは無い。\nこの記事に答えに近づけるヒントがある。( WIRED VISION / 「ゲーマーの後悔」は終わらないより引用 )\n クロスワードパズルの専門家、Will Shortz氏は以前、人が紙とペンを使うパ\n ズルを愛する理由は、「人生には答えが1つではない問題が山ほど存在するが、\n クロスワードでは答えは1つと決まっていて、それを見つけ出すことができる\n からだ」と私に話したことがある。だが、クロスワード中毒と同様、ゲームが\n 終わった後、われわれに何が残されるのか？達成感だろうか？確かにそれはあ\n るだろうが、われわれが成し遂げたことは、この上もなく独断的で、非生産的\n な仕事でしかない。ゲームが終わったときに私が感じる喜びにはいつも、少し\n のむなしさが付きまとうもっと生産的で、難しくて、やりがいがある何かをし\n た方がよかったのではないか？\nオープンソースソフトウェア開発が後悔しない理由を一言で言い表すとこういうことかなと思う。\n『ゲームはあらかじめ誰かが答えを用意してくれているが、オープンソース開発のようなものづくりには答えは用意されていない。』\nつまり、自分が通ってきた道がありふれたものか、それとも自分だけのものかという事ではないかと思う。\nそんなわけで、オープンソースソフトウェア開発はやめられない。",
    "url": "/2007/10/12/2007-10-12-post/"
  },
  {
    "id": "2007-10-15-post",
    "title": "音楽産業と日本のテレビ放送業界",
    "date": "2007-10-15",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2007-10-15-post.md",
    "content": "TechCrunch Japanese アーカイブ &gt;&gt; YahooのIan Rogers、音楽産業に苦言― 「不便の押し付けはいいかげんにしろ」\n 最後にIanは音楽産業の現在の欠陥だらけのビジネスモデルをこれ以上サポートする気はないと断言した。\n 私はYahoo!にもうこれ以上ユーザーに不便をかけるだけのサービスには投資\n させないつもりだ。私はYahoo!本社に、すばらしいメディア・アプリケーショ\n ンを作るための予算はもっと後にとっておいて、今はYahoo!Mailとか\n Answersとか役に立つ事業に投資したほうがいいと勧める。私自身の見解と\n しても、消費者の利益を無視して自分勝手な制限を課そうとするような試み\n にこれ以上付き合う時間も予算もない。人生は短い。私は消費者に喜んでも\n らえるようなサービスを作りたい。消費者をコケにするような仕事は御免だ。\n日本のテレビ放送業界もデジタル情報のコピー10回制限というような面倒をユーザーに課する様だが、いずれユーザーにそっぽを向かれてしまい、終焉を迎えると思う。\nいつの時代もユーザーの方を向いている新興企業が出てきて、古い企業はついていけず苦言を呈するという図式のような気がする。\nはやく、このような面倒はビジネス的に淘汰されてしまうことを願う。",
    "url": "/2007/10/15/2007-10-15-post/"
  },
  {
    "id": "2007-10-27-post",
    "title": "全生物の8割が昆虫、全プログラムコードの8割がループ",
    "date": "2007-10-27",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-10-27-post.md",
    "content": "『全生物の8割が昆虫』これは事実かどうかは不明だが、よく言われる。\n『全プログラムコードの8割がループ』は私が勝手に作った言葉だ。\n最近、業務向けアプリケーションのコード(JavaとかPHP)を読むことが多い。\n関数型スタイルのプログラミングに慣れた脳味噌で見るとほとんどがイテレータを回すループだと気づいた。\n特に、コレクションやリストなどを操作するループが至るところにある。ループ、ループ、ループのオンパレード。\nさらに、残念なことにイテレータのインスタンスやループ変数の宣言もループの数だけある。\n全て高階関数に置き換えたらどんなに読みやすく簡潔になることか...\n未来のC#、C++、Pythonが関数型スタイルをサポートする様だが、そうすれば業務向けコードの風景も様変わりしていくのだろうか。\n個人的にはそう思う。\n後はそれをどのくらい早めることができるか、かな。",
    "url": "/2007/10/27/2007-10-27-post/"
  },
  {
    "id": "2007-11-17-post",
    "title": "bashで高階関数のアイデア",
    "date": "2007-11-17",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-11-17-post.md",
    "content": "bashで高階関数が使えたらどんだけプログラミングが楽になるか。最近そう考えるようになった。\n欲しい高階関数は、こんな感じかな。\n\nmap ( xargs のaliasでも良い？)\nfilter ( grep のaliasでも良い？)\nfold\nmap_with_index\n\nついでに関数型プログラミングっぽいコードを書く為に必要そうな関数(コマンドで実装する？)\n- take\n- atoi (名前はPythonに習ってrangeでも良い)\nところで何でbashにこだわるの？という疑問が当然発せられると思う。\nそれはbashから呼びだす関数(というかコマンド)が一番豊富だと思うから。かつ実装系が枯れている。\n例えば、画像の変換を行ないたいと思えばImageMagikのconvert関数を呼べばよい。\nファイルを圧縮したいと思えばgzipコマンドを呼べば良い。\nファイルリストを取りたいと思えばfindを呼べば良い。\nさらには、メールを送りたいと思えばmailを呼べば良い。\nもし、高階関数があればこんなコーディングができるかも。\n f() { echo -n $1; md5sum $2 }\n find . | map_with_index f\n\nfがbashの関数である限り、map_with_indexはbashの関数で書かざるを得ない。\n使うのは簡単だけど作るのはちょっと厳しいかな。\nもしかしたらもっと強力な言語(RubyとかPythonとか)でbashスクリプトを生成してから\n実行するスタイルにするほうがうまく行くかも。\nでも、そうするとbashのお手軽さは無くなっちゃうし。うーん。バランスが難しい。\nこんなの(Es: A shell with higher-order functions)があるが、新しい言語を実装するのは大袈裟すぎる。\n枯れた実装系であるbashをそのまま使いたいよね。\nできればbashで100から200行程度でできて source でファイルを読みこむだけで使えるものが良い。\n[OldType]実装ついでに良いものが出来たら分離してリリースするかも。",
    "url": "/2007/11/17/2007-11-17-post/"
  },
  {
    "id": "2007-11-20-post",
    "title": "今更ながらDynamicMacro",
    "date": "2007-11-20",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2007-11-20-post.md",
    "content": "第14回 繰り返しの効用 | WIRED VISIONを読んだことがきっかけで、今更ながら増井さんのDynamic Macroをインストールした。\n結構いいね。これでいちいちキーボードマクロにキャプチャーする操作が減りそう。\nこういうインターフェースものは作っていても使っていても楽しい。",
    "url": "/2007/11/20/2007-11-20-post/"
  },
  {
    "id": "2007-11-23-post",
    "title": "『ボナンザVS勝負脳―最強将棋ソフトは人間を超えるか』を読む",
    "date": "2007-11-23",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-11-23-post.md",
    "content": "ボナンザは[Sumibi.org]と同じ機械学習を使った将棋ソフトウェア。\nこの本ではプロ将棋棋士の渡辺 明氏との対談もあって非常に面白い。\n保木さんの開発秘話の様子は、私にとってすごく親近感がわいた部分だった。\n私が[Sumibi.org]を開発している最中に、SumibiがWikipediaの文章食って毎日賢くなって行くのを見て\n驚き、興奮していた自分に重なる所が沢山ある。\n自分が作ったものが自分の理解を超えて賢くなっていく様は見ていて本当にワクワクするものだ。\nこの本はそれが伝わってくる貴重な本だと思う。\n渡辺 明氏のプロ将棋としての将棋との向き合いかたも純粋で心打たれる。\nこの本には二人の『Just for fun』が溢れていると思う。",
    "url": "/2007/11/23/2007-11-23-post/"
  },
  {
    "id": "2007-12-02-post",
    "title": "[LiveCoding#5](http://livecoding.org/)に参加した",
    "date": "2007-12-02",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-12-02-post.md",
    "content": "LiveCoding#5に参加した。参加と言ってもオーディエンスとしてだけど。\noxyさん凄かったね。C++のコード書くの早っ！『世界』を見れた気がする。\n次回はLiveCoderになれる様にネタを考えておこう。\n見栄えのするプログラムが作れた方が良いのでJavaScriptとかを練習しとくかな。\nそうそう、こういうイベントで実際に手を動かして何かを作りだしている人達から創作の力をもらう事が多い。\n関西でもこういうイベントを企画してくれた氏久さん(rubyneko)に感謝。",
    "url": "/2007/12/2/2007-12-02-post/"
  },
  {
    "id": "2007-12-03-post",
    "title": "[Amazon.co.jp： バベル17 (ハヤカワ文庫 SF 248): 本: サミュエル R.ディレーニイ,岡部 宏之](http://www.amazon.co.jp/%E3%83%90%E3%83%99%E3%83%AB17-%E3%83%8F%E3%83%A4%E3%82%AB%E3%83%AF%E6%96%87%E5%BA%AB-248-%E3%82%B5%E3%83%9F%E3%83%A5%E3%82%A8%E3%83%AB-R-%E3%83%87%E3%82%A3%E3%83%AC%E3%83%BC%E3%83%8B%E3%82%A4/dp/4150102481)を読む",
    "date": "2007-12-03",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2007-12-03-post.md",
    "content": "出版された時期を見るとかなり古く、1977年07月だそうだ。\n私は図書館で借りて読んだが、ページが色褪せ、茶色がかっている。\n自然言語を題材にしているせいかストーリーは全然古くなっていなくて驚く。\nただ、コンピューター言語への喩えとして『フォートランかアルゴルの様だ』というくだりを読むと、さすがに書かれた時期が分かって良い。\nネット上にわかりやすい書評 BABEL-17 を見つけた。興味を持った方は読んでみては？",
    "url": "/2007/12/3/2007-12-03-post/"
  },
  {
    "id": "2007-12-07-post",
    "title": "Haskellも面白そう",
    "date": "2007-12-07",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-12-07-post.md",
    "content": "LiveCoding#5に参加して、実際にHaskellをコーディングしている所を見るとHaskellも面白そうに感じた。\nコーディングをしてコンパイルが通ればほぼ動く、型安全なプログラミングというものを体験してみたいと思った。\n私は実際にHaskellで実用的な物を作った事が無いのでまだ、Haskellの良さが分からないレベルだ。\n日本語処理に問題があるとか、ライブラリが足りないとか処理系はまだまだこれからと聞いているが今からやっとくのもいいだろう。",
    "url": "/2007/12/7/2007-12-07-post/"
  },
  {
    "id": "2007-12-16-post",
    "title": "quack.elのλの字形が気にいらないので変更した",
    "date": "2007-12-16",
    "categories": [
      "Emacs"
    ],
    "file_path": "_posts/2007-12-16-post.md",
    "content": "quack.elの defconstを次の様に変更するとよい。\n(defconst quack-lambda-char (string-to-char &quot;λ&quot;))\n\nオリジナルは半角で表示されるが、これで全角のラムダが表示されるようになる。\n注意点としては、iso-2022-jpで保存しないといけない。\n忘れるといけないので2行目に次の様なコメントを入れておいた。\nEmacsがこのファイルを開くときに確実にエンコードをiso-2022-jpと認識してくれるので一石二鳥。\n;;; quack.el --- enhanced support for editing and running Scheme code\n;;; λの表示文字の為、このファイルはiso-2022-jpで保存してください。 (kiyoka)",
    "url": "/2007/12/16/2007-12-16-post/"
  },
  {
    "id": "2007-12-27-post",
    "title": "kahua.elに機能追加した",
    "date": "2007-12-27",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-12-27-post.md",
    "content": "kahua.elの改善パッチを[Kahua]プロジェクトのメーリングリストに送った。\n久々にオープンソースプロジェクトにコードをフィードバックした。\nオープンソースを自分の作りたいものに利用させてもらっているのでもっと貢献しないとね。\nもっと[Kahua]フレームワーク本体も改善したい所があるが、ちょっとレベル高いので手が出そうにない。\n今一番欲しい機能は、高階タグでエラーが出た時にバックトレースを表示してくれる機能かな。\n[Kahua]はまだまだデバッグの為の機能が不足している。",
    "url": "/2007/12/27/2007-12-27-post/"
  },
  {
    "id": "2007-12-28-post",
    "title": "flymakeでPHPのリアルタイム文法チェック",
    "date": "2007-12-28",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2007-12-28-post.md",
    "content": "ブログではいつも関数型言語の記事ばっかり書いているが、実は仕事ではPHPを使うこともある。\n言語は自分では選べないというのはITの世界ではもはや常識である。\n言語選択の自由を唱えるRubyのまつもとさんでもその辺は御存知でしょう(笑)\nというわけで、少しでもPHPの開発効率の悪さを軽減すべく、flymake modoの設定をおこなってみた。\nいろんな所でEmacsのflymakeモードの設定が書かれているが、うまく動かなかった。\n例えば、このサイトのコードも動かない。\n Syntax checking for PHP in Emacs at Blik.it - Web, Technology and Code\n動かない理由は『バックスラッシュが全て消えている』のが原因だと思われる。\n恐らく、HTML化する時に失敗しているんだろうと思われる。\n試しにHTMLソースを見るとちゃんと必要な所にバックスラッシュがちゃんと入っていたよ。\nというわけで、これを試してみられたし。\n私はCentOS4.4, PHP4, GNU Emacs 22.1.1, php-mode-1.2.0の環境で試した。\n(このページのテキストをコピペする場合は、ページタイトル右のPLAIN TEXTというアイコンをクリックして欲しい)\n(when \n (string-match &quot;22&quot; emacs-version)\n (progn\n ;; Flymake PHP Extension\n (require 'flymake)\n\n (defconst flymake-allowed-php-file-name-masks '(\n (&quot;\\\\.php3\\\\'&quot; flymake-php-init)\n (&quot;\\\\.inc\\\\'&quot; flymake-php-init)\n (&quot;\\\\.php\\\\'&quot; flymake-php-init))\n &quot;Filename extensions that switch on flymake-php mode syntax checks&quot;)\n\n (defconst flymake-php-err-line-pattern-re '(&quot;\\\\(.*\\\\) in \\\\(.*\\\\) on line \\\\(*0-9*+\\\\)&quot; 2 3 nil 1)\n &quot;Regexp matching PHP error messages&quot;)\n\n (defun flymake-php-init ()\n (let* ((temp-file (flymake-init-create-temp-buffer-copy\n 'flymake-create-temp-inplace))\n (local-file (file-relative-name\n temp-file\n (file-name-directory buffer-file-name))))\n (list &quot;php&quot; (list &quot;-f&quot; local-file &quot;-l&quot;))))\n\n (defun flymake-php-load ()\n (setq flymake-allowed-file-name-masks (append flymake-allowed-file-name-masks flymake-allowed-php-file-name-masks))\n (setq flymake-err-line-patterns (cons flymake-php-err-line-pattern-re flymake-err-line-patterns))\n (flymake-mode t)\n (local-set-key &quot;\\C-cd&quot; 'flymake-display-err-menu-for-current-line))\n\n (add-hook 'php-mode-user-hook 'flymake-php-load)))",
    "url": "/2007/12/28/2007-12-28-post/"
  },
  {
    "id": "2008-01-05-post",
    "title": "] will never be A Ghetto.",
    "date": "2008-01-05",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2008-01-05-post.md",
    "content": "スラッシュドット ジャパン / Ruby on Railsはゲットーだを読んで。\nTechCrunchの記事Zed Shaw Puts The Smack Down On The Rails Communityも参考に。\nZed Shaw氏の原文はちゃんと読んでいないけど、Ruby/Railsコミュニティーからはもう手を引くとのこと。\n要するにPHPコミュニティー見たいに『A bunch of half-trained former PHP morons』が押し寄せてきてひどい状況になっているということらしい。\n私もちょっとの間PHPメーリングリストを読んでいて、質の低さにウンザリした記憶があるので多少は納得できる。\n一方の[Kahua]コミュニティーには、良くも悪くもS式暗号(過去のkiyoka日記より)という高い参入障壁があるので、そうは成りそうにない。\n要はバランスで、WebフレームワークのコミュニティーにはPHPコミュニティーからSeaside.stコミュニティーまでいろいろあるが、ちょうど中間地点がいいと思う。\n[Kahua]はどちらかというと、Seasideよりだと思うので、もうちょっと中間地点側に寄せた方がいいと思う。\nどうやって寄せるかは、キラーアプリを作って見せるのが一番だが、言語がSchemeだということもあって、それだけでは駄目なのかも知れない。\n去年あたりから関数型言語の人気は(局所的には)高まっていると思われるので、Schemeだからという部分は多少緩和されるのかな。\n[Kahua]関係者の皆様、今年は何とかしたいよね。",
    "url": "/2008/1/5/2008-01-05-post/"
  },
  {
    "id": "2008-01-12-post",
    "title": "『決断力 (角川oneテーマ21): 本: 羽生 善治』を読んで",
    "date": "2008-01-12",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-01-12-post.md",
    "content": "読んだのはこの本。\nウェブ時代をゆく ─いかに働き、いかに学ぶかの梅田 望夫さんがよく羽生さんのことを書かれているのでその関連で読んでみた。\nこの本が書かれる前に、『高速道路論』という言いかたがされていたかどうかは不明だが、それに通じる話が沢山でてくる。\n将棋に限らず、一生勉強すべき職業に就ている人は参考になるに違いない。プログラマも同じだと思っている。\nちょっと引用してみる。\n第四章『「選ぶ」情報、「捨てる」情報』より\n 私は、今の時代は、いろいろなことが便利になり、近道が非常に増えた時代だと思っている。\n 何かをやろうと思った時に、さまざまな情報があり、安易な道、やさしい道が目の前に数多くある。\n 楽に進める環境も充実している。\n 昔は遠い、一本の道しかなかった。\n略\n しかし、遠まわりをすると目標に到達するのに時間はかかるだろうが、歩みの過程で思わぬ発見や出会いがあったりする。\n略\n 自分の力で吸収した考える力とか未知の局面にであったときの対処の方法とか、さまざまな事を学べたと思っている。\n 私は、自ら努力せずに効率よくやろうとすると、身につくことが少ない気がしている。\n 近道思考で、簡単に手に入れたものは、もしかしたらメッキかもしれない。\n メッキはすぐに剥げてしまうだろう。\n最近関数型言語をやっていて、理論的側面が不足しているせいで、なかなか答えに辿りつけないことが多い。\n手続き型プログラミングの世界では、騙し騙しコードを書くことができるが、関数型の場合はそうはいかないことがある。\nモナドや、継続をベースとするAPIがあったりした場合、理論的背景が分かってないといくらドキュメントやソースコードを読んでも自然に分かったりしない。\n毎日コツコツ勉強を続けて行くことで、『未知の局面』が来たときにも、解決方法が思いついたり、前に苦労してつかんだ理論が応用出来たりする。\n高速道路の先の渋滞を抜けることができるのは、どこかの時点でじっくり腰を据えて努力をした人のみなんじゃないかと思う。",
    "url": "/2008/1/12/2008-01-12-post/"
  },
  {
    "id": "2008-01-13-post",
    "title": "『プロとアマの垣根』について",
    "date": "2008-01-13",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-01-13-post.md",
    "content": "を読んで。\nNHK プロフェッショナル 仕事の流儀では無いけれども、『プロとアマの垣根』について触れている。\n- 以下第五障『才能とは、継続できる情熱である』より引用。\n 将棋の世界にかぎらず、今、プロとアマの垣根が低くなっている。\n(略)\n プロらしさとは何か？と問われれば、私は、明らかにアマチュアとは違う特別なものを持っており、その力を、瞬間的ではなく持続できることだと思っている。\n 私が大事にしているのは、年間を通しての成績である。\n(略)\n どの世界においても、大切なのは実力を維持することである。\n そのためにモチベーションを持ち続けられる。\n 地位や肩書は、その結果としてあとについてくるものだ。\n 逆に考えてしまうと、どこかで行き詰まったり、いつか迷路にはまり込んでしまうのではないだろうか。\n- そういえば、Shiroさんも同じことを書かれていた気がする。以下引用。\n プロとアマの違いは何だろうかと時々考えるのだけれど、ひとつ確実に言えるのは、プロはどんな場合でも仕事の質がある下限以上であることが期待されているということだ。\n フィールドによっては、アマチュアがプロよりも良い仕事をする場合がある。\n ただ、それは上のピークを見た場合。どんな人でも長く続けてれば波はあるもので、プロかどうかを分けるのは山の頂きではなく谷底の標高が一定の高さをクリアしていることではないかと思う。\n納得。\n持続するためには、仕事が好きでないといけないということがある。\nしかし、好きなことでも続けてやっているとそうでもなくなってくるし、好きな対象も知らず知らずのうちに徐々にシフトしていく。\n私は仕事ではそんなに超絶技巧は要求されないので(逆に言うと、チャレンジングな技術使用を許可されにくいので)、それだけやっているとモチベーションが維持できない。\nそこで、プライベートでは自分が本当に面白いと思った技術で遊んだりしてバランスを取っている。\nその遊びは、結果的に理論や概念の部分で、役に立ったことが多い。\nそんな工夫をしながら仕事のパフォーマンス安定性とモチベーション維持を両立するのはプロとしての務めではないかと思う。",
    "url": "/2008/1/13/2008-01-13-post/"
  },
  {
    "id": "2008-01-14-post",
    "title": "Dave Thomasの講演を観て思ったこと",
    "date": "2008-01-14",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2008-01-14-post.md",
    "content": "この有名な講演を、Gaucheユーザから見て思うことを中心に。\nプログラミング関連のブログをグルっとひと巡りしてみるとRubyを愛している人は多いことに気づくだろう。\nこの講演の中で、(Haskell and Ruby) or (Ocaml and Python) という話が出てくる。\n真中が 'or' ではなく 'and' の人は少数で、これは何でだろうという話。\nDave Thomasは、これはペットの趣向で例えると犬派、猫派が有るようなものでRuby派、Python派が有ると説明している。\nなんか分かる気がする。\nさて、無理矢理ここにLisp系を入れてみよう。\n『(Haskell and Ruby) or (Ocaml and Python) or (CommonLisp and Scheme)』(笑) ということにしておこう。\nLisp系を使う人は、全部Lisp系でやってしまう感じを表現してみた(笑)\nところで、Rubyがプログラミング言語としてここまで愛されているのはPerl以来かもしれない。\nDave Thomasは自分の脳味噌の動きに近いという言いかたをしていし、周辺でもRubyが好きな人はだいたい同じような事を言っている気がする。\nちなみに私は、Scheme言語のなかでもとりわけGaucheを愛している。\n残念ながら普及率は今ひとつだけど、今のところ問題ない。\nもし、Dave Thomasのような熱い人がGaucheコミュニティーに出てきたらどんな感じなんだろうと想像してみたが、ちょっと有りそうにないよね。\nGauche本が出たあたりから、少しはコミュニティーが大きくなったりすればいいなと期待している。\n RubyKaigi2007 / Dave Thomas 1/4\n RubyKaigi2007 / Dave Thomas 2/4\n RubyKaigi2007 / Dave Thomas 3/4\n RubyKaigi2007 / Dave Thomas 4/4",
    "url": "/2008/1/14/2008-01-14-post/"
  },
  {
    "id": "2008-02-04-post",
    "title": "最もタメになる「初心者用言語」はScheme!",
    "date": "2008-02-04",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2008-02-04-post.md",
    "content": "これおもしろいね。\n日記を書くはやみずさん:最もタメになる「初心者用言語」はScheme!\n半分ネタ、半分本気な空気感がいい。\nこの部分は本気で共感出来るよ。\n Schemeは勉強したがりなみんなの見方だね！\n他にもいろんな人がいろんな主張を続けている。\n最もタメになる「初心者用言語」は JavaScript。 - IT戦記\n最もタメになる「初心者用言語」は Python！ - 西尾泰和のはてなダイアリー\n私は意外とPythonは悪くないとおもってるよ。\n特にPython 3000になると関数型スタイルで書きやすくなるとか、かなり満足いく仕様になると思う。",
    "url": "/2008/2/4/2008-02-04-post/"
  },
  {
    "id": "2008-02-12-post",
    "title": "Ruby1.9とVMの状況",
    "date": "2008-02-12",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2008-02-12-post.md",
    "content": "最近Rubyの1.9とVMの情報を追いかけて無かったので、ささださんのプレゼンを探して観てみた。\nLingrでささださんとshiroさんがVMの最適化について議論されているのを読んで興味が出たのもキッカケになった。\nちょっと古いけどRuby会議2007の時のプレゼンだ。\n日本 Ruby 会議 2007 プログラム / Ruby 1.9実装の現状と今後 1/3\n日本 Ruby 会議 2007 プログラム / Ruby 1.9実装の現状と今後 2/3\n日本 Ruby 会議 2007 プログラム / Ruby 1.9実装の現状と今後 3/3\nこういうビデオが残っていると、現場に行けなかった場合でも見返せるので非常によい。\nもうちょっとVMの中身の詳細について紹介しているプレゼンも観てみたくなった。\nあるのかな。",
    "url": "/2008/2/12/2008-02-12-post/"
  },
  {
    "id": "2008-02-16-post",
    "title": "Gauche 0.8.13[リリース](http://practical-scheme.net/gauche/index-j.html)がされた",
    "date": "2008-02-16",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-02-16-post.md",
    "content": "私としてはこれが一番うれしい。Gauche:Translationより\n 本体の改良点\n apply での引数の扱いが改良された。以前は引数リスト中の各引数をすべて\n VM スタック上にプッシュしていたため、VM のスタックに載らない長い引数\n リストを apply すると失敗していた。現在は、引数リストを必要なだけ展開\n する。これにより、ほとんどすべての場合で引数リストの長さが無制限になっ\n た。例えば次のようなことができる。\n (apply list (iota 50000)) \n\n実は、[OldType]のバックエンドにはGauche付属のsxmlライブラリを利用していて、巨大なXMLノードを突込むと VM stackが足りないというエラーが出ていたのだ。\n仕方が無いので、[OldType]のサイトではGauche 0.8.12の vm.hのスタックサイズを10倍にして運用していた。\nこれで、変なパッチを当てなくて良くなるよー。うれしい ^_^。\nKahuaの最新版と一緒には使えないので、Kahua側で対応したものがリリースされるまで待ちだね。\n参考リンク\n [http://mlarchive.kahua.org/mlarchive/kahua-dev/msg01366.html|[kahua-dev 1367 Gauche-0.8.13 and Kahua-1.0.7.1]]",
    "url": "/2008/2/16/2008-02-16-post/"
  },
  {
    "id": "2008-02-19-post",
    "title": "見ため重要、マーケティング重要",
    "date": "2008-02-19",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2008-02-19-post.md",
    "content": "この記事は必読。デベロッパーズ・サミット2008で講演するジョエル・スポルスキー氏の講演\n すばらしいソフトを作るには、カリスマが講演 − ＠IT\n(thumb http://www.atmarkit.co.jp/news/200802/14/joel.html)\n私が以前から思っている事を分かりやすく言ってくれている。\nそう、『見ため重要、マーケティング重要』\n技術が凄い、深いっていうだけでも分かる人には分かる。でも、分かる人は少ない。\nそのソフトウェアはコミュニティーが濃いので価値は高いという考えかたもある。\nでも、それだけではNo1にはなれない。ここではNo1とは知名度、ブランド、マインドシェアで見た場合のNo1の事を指す。\nRubyとかRuby on Railsはそのへんうまくいっている例だと思う。\nRubyは楽しくプログラミングするというマーケティングがうまく成功している。\nRuby on Railsはかっこ良さと生産性の高さがうまく合わさって(必要以上に)うまくいっている。\n[Sumibi.org]はそのへんマーケティングとかにはかなり頑張ったんだけど、[OldType]でも頑張ってみる価値アリだと思った。",
    "url": "/2008/2/19/2008-02-19-post/"
  },
  {
    "id": "2008-02-25-post",
    "title": "Schemerにとって理想のRubyとは(1)",
    "date": "2008-02-25",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2008-02-25-post.md",
    "content": "Schemerはこんなコードを書きたいと思うはず。defとlambdaは同じであるべきだ。\n\ndef func1( x )\n x + 1\nend\np *1,2,3*.map( func1 )\n\nなんでdefは内部でlambdaに置換されないんだろうか。えっ？class/moduleとの整合？私はそんなの知らない。\nところで、Ruby1.8.6ではクロージャをmapに渡すためにはこう書くしかない。\n\nfunc1 = lambda {|x|\n x + 1\n}\np *1,2,3*.map {|x|\n func1.call(x) \n}\n\n-- せめてこれくらい書ければいいなぁ。\nfunc1 = lambda {|x|\n x + 1\n}\np *1,2,3*.map( func1 )\n\n-- でもエラーとな...残念だ。\nbash-3.2$ ruby ./t.rb\n./t.rb:5:in `map': wrong number of arguments (1 for 0) (ArgumentError)\n from ./t.rb:5\n\n私が知らないだけで本当はもっと簡潔に書く方法があるのかな？",
    "url": "/2008/2/25/2008-02-25-post/"
  },
  {
    "id": "2008-03-04-post",
    "title": "Schemerにとって理想のRubyとは(2)",
    "date": "2008-03-04",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2008-03-04-post.md",
    "content": "[kiyoka.2008_02_25]の続き。\nRubyにnamed letみたいなのが欲しい\n再起でレキシカルアナライザが自然に書けるよ。\ndef lexer( f )\n tokenList = * *\n let loop { |ch = f.readchar, prev, token = &quot;&quot;| \n case ch\n when f.eof?\n else\n # トークンの蓄積\n case ch\n when ' ' '\\t'\n tokenList &lt;&lt; token\n token = &quot;&quot;\n else\n token += ch\n end\n loop( f.readchar, ch, token )\n end\n end\n tokenList\nend\n\n本物のRubyにはないコーディングは、たぶん次の三つだけだと思う。\nブロック構文の引数の初期値指定\nlet構文\nProcオブジェクトを.call()を付けなくても呼出せる\n要するに、Schemerは何でもλに見えてしまうので、Rubyにもそれを期待してしまう。\nもしこれが出来てもRubyの構文自体はあまりくずれないと思うけどなぁ。",
    "url": "/2008/3/4/2008-03-04-post/"
  },
  {
    "id": "2008-03-09-post",
    "title": "第二回[gauche.night](http://practical-scheme.net/wiliki/wiliki.cgi?gauche.night)に出演してきた",
    "date": "2008-03-09",
    "categories": [
      "Gauche"
    ],
    "file_path": "_posts/2008-03-09-post.md",
    "content": "ふー、疲れたー。\nスタッフの皆さん、出演者の皆さん、そして、遠路はるばる見に来てくれた方々、ありがとうございました。\n私は初めての参加でしたが、こんなに濃いイベントだとは。予想を超えていました。\nShiroさんにもお会いできたし、錚々たる出演者の方々とお話しすることができました。\nyharaさんとか[hayamiz]さんひげぽんさんなど、ブログで良く知っていた人に裏話など聞かせてもらいました。\n今日はオールナイト飲み会の後のフライトで疲れたので、イベントの詳しい感想などはまた後日書きます。\n本 プログラミングGaucheがAmazonで予約できるようになった\ngauche.nightに行けなかった人はコチラから予約できるよ。",
    "url": "/2008/3/9/2008-03-09-post/"
  },
  {
    "id": "2008-03-11-post",
    "title": "[gauche.night](http://practical-scheme.net/wiliki/wiliki.cgi?gauche.night)の感想",
    "date": "2008-03-11",
    "categories": [
      "Gauche"
    ],
    "file_path": "_posts/2008-03-11-post.md",
    "content": "イベント全体の印象はS式一色。S式への愛が溢れたイベントでした。\nLL関係のイベントではS式!S式!と叫んでいると、かなりaway感が醸しだされるんだけど、\ngauche.nightではS式が正統派、S式でないとオカシイとまで思われかねないほどのS式傾倒ぶり。\nが出たことに対する皆の喜びもいったんかんのある空気の中に感じられた。\nそれと、Shiroさんがイメージ通りのいい方だったので安心したよ。\n少しづつGaucheがメジャーになってくれることを願う一日だった。\nこれからも私は[OldType]をハックしながら、Gauche/Kahuaの発展に貢献できればと思う。",
    "url": "/2008/3/11/2008-03-11-post/"
  },
  {
    "id": "2008-03-27-post",
    "title": "Python 3.0について",
    "date": "2008-03-27",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-03-27-post.md",
    "content": "Python Conference 2008 - Day1 — TRIVIAL TECHNOLOGIES 2.0より\n Pythonが目指す変化の方向性は，「よりコンパクトなコア」。誰が使っても「た\n った一つのすばらしい方法」にたどり着けるように，曖昧さを排除し，例外を少\n なくしてハマりどころを取り除くことによって，よりながく，正しい方向に進化\n しつづけられるはずです。\nとうとうPythonも3.0で後方互換性を犠牲にしても進化するという方針を打ち出した。\nPHP、Rubyは(多分)元から互換性をそんなに重要視していないし、PerlはPerl 6で後方互換性を犠牲にした。\n最後に残ったPythonも例外では無かった。\nコンパクトなコアという方向性は賛成。\nSchemeが好きな私はコアはコンパクトで有れば有るほどいいと思うけど、あまりにやりすぎると、普及しずらい。\nそのへんのバランスが重要だと思う。\nPython 3.0ではそのバランスが調整されて良くなりそうな期待がある。\nところで、私はPythonのインデント構文は好きなので、SchemeのスキンとしてPythonライクな構文を採用するという妄想を捨てきれずにいる。\nPythonとSchemeは水と油のような気もするが、だからこそPythonライクにすることでS式に抵抗がある人用のインターフェースとして機能するんじゃないかと思う。",
    "url": "/2008/3/27/2008-03-27-post/"
  },
  {
    "id": "2008-03-28-post",
    "title": "2冊同時読み:日本の雇用システムとモチベーション関連",
    "date": "2008-03-28",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-03-28-post.md",
    "content": "最近、同種の本を2冊同時に読む様にしている。\n間を空けずに、同時に読むと、比較できて楽しい。\n有名な(1)より(2)のほうが、はるかに内容が上だ。\n(2)を読むと、(1)が薄っぺらに思える。\n(2)は日本人独特の屈折した承認欲求の心理からモチベーションを説明していて、非常に納得できる。\n日本人コミュニティーのなかでは承認欲求がないかのように謙遜することが、実は最大の承認を得るための方法だと解説してある。なるほど。\nそれに比べて、残念ながら(1)では単に誰かを悪者にして愚痴っているだけに思う。\n2冊同時読みは、1冊だけ読んだ時間に比べて、それぞれを客観的にちょっと引いた視点で読めるのでいい。\n一つの意見を盲信する危険性が減る。おすすめの読みかただ。",
    "url": "/2008/3/28/2008-03-28-post/"
  },
  {
    "id": "2008-03-30-post",
    "title": "2冊同時読み:スーパーコンピュータ開発関連",
    "date": "2008-03-30",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-03-30-post.md",
    "content": "最近、同種の本を2冊同時に読む様にしている。\n間を空けずに、同時に読むと、比較できて楽しい。\n(1)が自分の解きたい問題にフォーカスすることで世界一安価手作りスーパーコンピュータを作る物語だ。\n一方、(2)は世界で一番規模の大きな汎用スーパーコンピュータの使命について熱く語っている。\n両方の本を読むと、予算規模と問題設定の大きさは無関係であり、数人規模の仕事でも世界に衝撃を与えることはできるという気がする。\nまた、両方とも、関わっている人はシミュレーションはワクワクする科学の分野であり、本当に楽しみながら、且つ価値を生みだしているという自負を持って取りくんでいるということ。\nコンピュータ開発の人間ドラマを読みたい人は(1)を、人類の未来の姿を垣間見たい人は(2)をおすすめする。",
    "url": "/2008/3/30/2008-03-30-post/"
  },
  {
    "id": "2008-04-02-post",
    "title": "パラダイス鎖国",
    "date": "2008-04-02",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-04-02-post.md",
    "content": "海部さんの本が出たので、早速買って読んだ。(後で、図書館に寄贈しときます)\n日本国内のエンジニアが冷遇される問題や、国内ビジネスの鎖国状態について以前から興味があったので\n海部さんのブログを追っ掛けていた。\n関連エントリはたぶんこのリストで全部だと思う。\nパラダイス的新鎖国時代到来？ - いいのかいけないのか？（その１） - Tech Mom from Silicon Valley\nパラダイス的新鎖国時代到来（その２） - 「ホテル・ルワンダ」vs.「亡国のイージス」 - Tech Mom from Silicon Valley\nパラダイス的新鎖国時代到来（その３）- なお超えがたき言語の壁 - Tech Mom from Silicon Valley\nパラダイス的新鎖国時代到来（その４）- 産業編・携帯電話端末のケーススタディ - Tech Mom from Silicon Valley\nパラダイス的新鎖国時代到来（その５）- 北カリフォルニア風アジアン・フュージョンにおける寿司の地位 - Tech Mom from Silicon Valley\nアンチ・パラダイス鎖国　（その６）---　日本製アニメは「東洋の魔 - Tech Mom from Silicon Valley\nアンチ・パラダイス鎖国　（その７）---　頑張れ、日本映画 - Tech Mom from Silicon Valley\nアンチ・パラダイス鎖国（その８）--- 問題は大企業のパラダイス鎖国 - Tech Mom from Silicon Valley\nパラダイス鎖国に関する補足 - Tech Mom from Silicon Valley\n最近対談をされた様なので、こちらも見た。中島聡さんの話も興味深い。\n 中島聡×海部美知トークイベント01\n短く編集してあり、内容が濃いので観て損は無いよ。",
    "url": "/2008/4/2/2008-04-02-post/"
  },
  {
    "id": "2008-04-06-post",
    "title": "不寛容な日本が進行",
    "date": "2008-04-06",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2008-04-06-post.md",
    "content": "していると思う。日本の閉塞感と関係あると思うよ。もしかして日本だけじゃ無いのかしれないけど。\nみんな余裕が無いんだよね。たぶん。\nまずは人の事批判する前に自分の事やろうよ。\n- 糸井さん、うまいこと説明しているね。\n「屁尾下郎」氏のツッコミが世の中を詰まらせる (「公私混同」原論)：NBonline(日経ビジネス オンライン)\n- 村上龍氏も分かりやすい例を持ってきている。\n YouTube - 村上龍Ｘ中田英寿 vol.5／5 世の中もっと寛容になったらいい",
    "url": "/2008/4/6/2008-04-06-post/"
  },
  {
    "id": "2008-04-07-post",
    "title": "関数型プログラミングの用語を使わずに関数型のメリットを説明する",
    "date": "2008-04-07",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2008-04-07-post.md",
    "content": "この記事にはラムダ式というキーワード以外は関数型プログラミングの専門用語は出てこない。\n第1回　ラムダ式 − ＠IT\n(thumb http://www.atmarkit.co.jp/fdotnet/csharp30/csharp30_01/csharp30_01_01.html)\nこの記事で言いたいことは、『ラムダ式はリスト内包表記、高階関数と組み合せるとコードが驚くほど簡潔になる』という一言で表現できると思う。\nところで、川俣氏は関数型プログラミング言語でコードを書かれたことがあるんだろうか。\nもし有るなら、確信犯的によく書かれた記事だと思う。\n逆に、もし無いならかなりお気の毒な記事だと思う。さすがにプロのライターの方なので前者であると思うけど。\nこれくらい分かりやすい記事が書けないと仕事として成立しないんだなぁ。",
    "url": "/2008/4/7/2008-04-07-post/"
  },
  {
    "id": "2008-04-08-post",
    "title": "RESTベースの関数型言語ライブラリ",
    "date": "2008-04-08",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2008-04-08-post.md",
    "content": "を[Kahua]と見比べながら読んだり、ricollab Web Tech Blog &gt;&gt; REST 入門(1 Web アプリケーションのアーキテクチャ)を読んだりした。\nそうすると、なぜか頭の中で変な風に配線が繋がった。関数型言語でいうところの関数なら、1関数=1URLで表現できるんじゃないか。\nRESTの基本はステートレスサーバ、つまりクライアントの状態をサーバーが管理せず、サーバが計算するために必要な全ての情報を毎回クライアントからもらう。\nこれって、関数型言語のimmutableな関数の考えかたじゃないか。\nREST APIを数珠つなぎにすれば関数型プログラミングもできる。\nRESTでSchemeの関数を実装した例\n例えば、S式のリストをソートする関数は次のURLで実行できるとすれば、\nhttp://func.example.com/lib/sort\n\n次のようなコードが書けると面白いのでは？\n(use-rest-function &quot;http://func.example.com/lib&quot;)\n(sort '(1 5 2 4 7 6 8 9 3))\n\n結果\n(1 2 3 4 5 6 7 8 9)\n\nRESTにしてうれしい物としては、英語の辞書とか、大きなデータベースを必要とするため\nローカルに置いておくよりも、皆で共有したほうが良いものとかかな。\n他にも、画像処理などの重たい処理を簡単に分散処理・並列処理を実現する手段としても使えそう。",
    "url": "/2008/4/8/2008-04-08-post/"
  },
  {
    "id": "2008-04-14-post",
    "title": "Firefox 3 Beta 5にした",
    "date": "2008-04-14",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2008-04-14-post.md",
    "content": "とりあえず気づいた点\nページをレイアウトする速度が速い\nページ全体のズームがサポートされた\n以下Mozilla Japan - Firefox 3 Beta 5 リリースノートからの引用\n - ページ全体のズーム:\n 表示 メニューとキーボードショートカットから、新しいズーム機能によっ\n てページ全体をズームイン・ズームアウトして、レイアウトテキストおよび\n 画像、またはオプションで文字サイズのみを拡大・縮小することができます。\n ここでの設定はサイトごとに記憶され、再びそのサイトを訪れると復元され\n ます。\n[OldType]でこの機能をJavaScriptを使って実装しようと思っていたが、やっぱりやめた。\nブラウザでサポートされるんだったらもういいや。",
    "url": "/2008/4/14/2008-04-14-post/"
  },
  {
    "id": "2008-04-15-post",
    "title": "Gaucheのsvnバインディング:調査編1",
    "date": "2008-04-15",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2008-04-15-post.md",
    "content": "をO'Reilly - Safari Books Onlineで読みながら、svnのバインディングの書きかたを調査中。\nこのブログにコメントを付けたいというのが、一番の動機。\n本当は、svnコマンドをGaucheから子プロセスで起動すれば良いのだけど、\nこの本には、バインディングを書かないとちゃんとしたエラー処理はやりにくいよ、と書いてあったので\n真に受けて調査してみている。\n世間には、既にPythonとRubyのバインディングが存在するようだが、それにとらわれず、\nGaucheらしいバインディングが作れれば良いのだけど。\n手始めに、もっと簡単なバインディングを書いて練習してみようかな。",
    "url": "/2008/4/15/2008-04-15-post/"
  },
  {
    "id": "2008-04-16-post",
    "title": "Gaucheのsvnバインディング:調査編2",
    "date": "2008-04-16",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2008-04-16-post.md",
    "content": "[kiyoka.2008_04_15]の話に続き、Pythonのbindingを調査してみた。\npysvn: Downloadsからダウンロードできる。中身を見てbindingを真面目に作るのは大変そうなことが分かった。\nメソッド数が半端じゃない。\n以下、psvn_client.cppのクラス定義部分の引用。\n\nvoid pysvn_client::init_type()\n{\n behaviors().name(&quot;Client&quot;);\n behaviors().doc( pysvn_client_doc );\n behaviors().supportGetattr();\n behaviors().supportSetattr();\n\n add_keyword_method(&quot;add&quot;, &amp;pysvn_client::cmd_add, pysvn_client_add_doc );\n add_keyword_method(&quot;annotate&quot;, &amp;pysvn_client::cmd_annotate, pysvn_client_annotate_doc );\n add_keyword_method(&quot;cat&quot;, &amp;pysvn_client::cmd_cat, pysvn_client_cat_doc );\n add_keyword_method(&quot;checkin&quot;, &amp;pysvn_client::cmd_checkin, pysvn_client_checkin_doc );\n add_keyword_method(&quot;checkout&quot;, &amp;pysvn_client::cmd_checkout, pysvn_client_checkout_doc );\n add_keyword_method(&quot;cleanup&quot;, &amp;pysvn_client::cmd_cleanup, pysvn_client_cleanup_doc );\n add_keyword_method(&quot;copy&quot;, &amp;pysvn_client::cmd_copy, pysvn_client_copy_doc );\n add_keyword_method(&quot;diff&quot;, &amp;pysvn_client::cmd_diff, pysvn_client_diff_doc );\n#ifdef PYSVN_HAS_CLIENT_DIFF_PEG\n add_keyword_method(&quot;diff_peg&quot;, &amp;pysvn_client::cmd_diff_peg, pysvn_client_diff_peg_doc );\n#endif\n#if defined( PYSVN_HAS_CLIENT_DIFF_SUMMARIZE )\n add_keyword_method(&quot;diff_summarize&quot;, &amp;pysvn_client::cmd_diff_summarize, pysvn_client_diff_summarize_doc );\n add_keyword_method(&quot;diff_summarize_peg&quot;, &amp;pysvn_client::cmd_diff_summarize_peg, pysvn_client_diff_summarize_peg_doc );\n#endif\n add_keyword_method(&quot;export&quot;, &amp;pysvn_client::cmd_export, pysvn_client_export_doc );\n#if defined( PYSVN_HAS_WC_ADM_DIR )\n add_keyword_method(&quot;get_adm_dir&quot;, &amp;pysvn_client::get_adm_dir, pysvn_client_get_adm_dir_doc );\n#endif\n add_keyword_method(&quot;get_auth_cache&quot;, &amp;pysvn_client::get_auth_cache, pysvn_client_get_auth_cache_doc );\n add_keyword_method(&quot;get_auto_props&quot;, &amp;pysvn_client::get_auto_props, pysvn_client_get_auto_props_doc );\n add_keyword_method(&quot;get_default_password&quot;, &amp;pysvn_client::get_default_password, pysvn_client_get_default_password_doc );\n add_keyword_method(&quot;get_default_username&quot;, &amp;pysvn_client::get_default_username, pysvn_client_get_default_username_doc );\n add_keyword_method(&quot;get_interactive&quot;, &amp;pysvn_client::get_interactive, pysvn_client_get_interactive_doc );\n add_keyword_method(&quot;get_store_passwords&quot;, &amp;pysvn_client::get_store_passwords, pysvn_client_get_store_passwords_doc );\n add_keyword_method(&quot;import_&quot;, &amp;pysvn_client::cmd_import, pysvn_client_import__doc );\n add_keyword_method(&quot;info&quot;, &amp;pysvn_client::cmd_info, pysvn_client_info_doc );\n\n#ifdef PYSVN_HAS_CLIENT_INFO\n add_keyword_method(&quot;info2&quot;, &amp;pysvn_client::cmd_info2, pysvn_client_info2_doc );\n#endif\n#if defined( PYSVN_HAS_WC_ADM_DIR )\n add_keyword_method(&quot;is_adm_dir&quot;, &amp;pysvn_client::is_adm_dir, pysvn_client_is_adm_dir_doc );\n#endif\n add_keyword_method(&quot;is_url&quot;, &amp;pysvn_client::is_url, pysvn_client_is_url_doc );\n#ifdef PYSVN_HAS_CLIENT_LOCK\n add_keyword_method(&quot;lock&quot;, &amp;pysvn_client::cmd_lock, pysvn_client_lock_doc );\n#endif\n add_keyword_method(&quot;log&quot;, &amp;pysvn_client::cmd_log, pysvn_client_log_doc );\n#if defined( PYSVN_HAS_CLIENT_LIST )\n add_keyword_method(&quot;list&quot;, &amp;pysvn_client::cmd_list, pysvn_client_list_doc );\n#endif\n add_keyword_method(&quot;ls&quot;, &amp;pysvn_client::cmd_ls, pysvn_client_ls_doc );\n add_keyword_method(&quot;merge&quot;, &amp;pysvn_client::cmd_merge, pysvn_client_merge_doc );\n add_keyword_method(&quot;mkdir&quot;, &amp;pysvn_client::cmd_mkdir, pysvn_client_mkdir_doc );\n add_keyword_method(&quot;move&quot;, &amp;pysvn_client::cmd_move, pysvn_client_move_doc );\n add_keyword_method(&quot;propdel&quot;, &amp;pysvn_client::cmd_propdel, pysvn_client_propdel_doc );\n add_keyword_method(&quot;propget&quot;, &amp;pysvn_client::cmd_propget, pysvn_client_propget_doc );\n add_keyword_method(&quot;proplist&quot;, &amp;pysvn_client::cmd_proplist, pysvn_client_proplist_doc );\n add_keyword_method(&quot;propset&quot;, &amp;pysvn_client::cmd_propset, pysvn_client_propset_doc );\n add_keyword_method(&quot;relocate&quot;, &amp;pysvn_client::cmd_relocate, pysvn_client_relocate_doc );\n add_keyword_method(&quot;remove&quot;, &amp;pysvn_client::cmd_remove, pysvn_client_remove_doc );\n add_keyword_method(&quot;resolved&quot;, &amp;pysvn_client::cmd_resolved, pysvn_client_resolved_doc );\n add_keyword_method(&quot;revert&quot;, &amp;pysvn_client::cmd_revert, pysvn_client_revert_doc );\n add_keyword_method(&quot;revpropdel&quot;, &amp;pysvn_client::cmd_revpropdel, pysvn_client_revpropdel_doc );\n add_keyword_method(&quot;revpropget&quot;, &amp;pysvn_client::cmd_revpropget, pysvn_client_revpropget_doc );\n add_keyword_method(&quot;revproplist&quot;, &amp;pysvn_client::cmd_revproplist, pysvn_client_revproplist_doc );\n add_keyword_method(&quot;revpropset&quot;, &amp;pysvn_client::cmd_revpropset, pysvn_client_revpropset_doc );\n#if defined( PYSVN_HAS_WC_ADM_DIR )\n add_keyword_method(&quot;set_adm_dir&quot;, &amp;pysvn_client::set_adm_dir, pysvn_client_set_adm_dir_doc );\n#endif\n add_keyword_method(&quot;set_auth_cache&quot;, &amp;pysvn_client::set_auth_cache, pysvn_client_set_auth_cache_doc );\n add_keyword_method(&quot;set_auto_props&quot;, &amp;pysvn_client::set_auto_props, pysvn_client_set_auto_props_doc );\n add_keyword_method(&quot;set_default_password&quot;, &amp;pysvn_client::set_default_password, pysvn_client_set_default_password_doc );\n add_keyword_method(&quot;set_default_username&quot;, &amp;pysvn_client::set_default_username, pysvn_client_set_default_username_doc );\n add_keyword_method(&quot;set_interactive&quot;, &amp;pysvn_client::set_interactive, pysvn_client_set_interactive_doc );\n add_keyword_method(&quot;set_store_passwords&quot;, &amp;pysvn_client::set_store_passwords, pysvn_client_set_store_passwords_doc );\n add_keyword_method(&quot;status&quot;, &amp;pysvn_client::cmd_status, pysvn_client_status_doc );\n add_keyword_method(&quot;switch&quot;, &amp;pysvn_client::cmd_switch, pysvn_client_switch_doc );\n#ifdef PYSVN_HAS_CLIENT_LOCK\n add_keyword_method(&quot;unlock&quot;, &amp;pysvn_client::cmd_unlock, pysvn_client_unlock_doc );\n#endif\n add_keyword_method(&quot;update&quot;, &amp;pysvn_client::cmd_update, pysvn_client_update_doc );\n}\n\nこれだけでも結構気が遠くなる。\nまずは、svnコマンドを使ってKahuaからsubversionアクセスするようにしてみて\n限界を感じたら必要なメソッドだけを実装する方針でいこう。",
    "url": "/2008/4/16/2008-04-16-post/"
  },
  {
    "id": "2008-04-19-post",
    "title": "My Job Went To India オフショア時代のソフトウェア開発者サバイバルガイド",
    "date": "2008-04-19",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-04-19-post.md",
    "content": "タイトルからすると、もっと危機感を煽る本だと思ったが、そんな事はない。\n現実的なアドバイスが書かれた、いい本だった。\nでも、ベンチャー気質の人にはちょっと物足りないだろうと思う。\n梅田望夫のように『これから、ベンチャーや個人の力が強くなる』というような未来の話ではなく、現在の多数の人に当てはまる内容になっている。\nなので、それなりに大きな組織でプログラマとして働いている人は向いているだろう。\n読んだ後のインパクトは強くないが、まあ納得感はある。\nでもなぁー、やっぱり何か物足りない。\n変化はそんなになだらかなではない気がする。\n未来はもっと激しく変化するんじゃないかと思っているので、それに答え切れてない。\nこれを手始めにもっと他の本も読んでみよう。",
    "url": "/2008/4/19/2008-04-19-post/"
  },
  {
    "id": "2008-04-22-post",
    "title": "おもてなしの経営学 アップルがソニーを超えた理由: 中島 聡",
    "date": "2008-04-22",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-04-22-post.md",
    "content": "WindowsとInternet Explorerの設計者の中島 聡の本だ。ブログはLife is beautifulが有名だ。\nかなりの部分、ブログからの記事と対談が占めるが、全体として一貫して『おもてなし』の重要性についての話が綴られている。\n中島さんのブログにUser Experienceに対する日本語が思い浮かばないと書いたところ、次のようなコメントが入ったそうだ。\n User Experienceは『おもてなし』だと思っています。\nなるほど、いい訳語だと思う。\n私も、この本の『おもてなし』がこれからの時代に成功するプロダクトの要になるという意見には、賛成。\nでも簡単に真似できないのが、この『おもてなし』であることも確か。\nYouTubeにも関連動画がある。こちらも面白い。\n YouTube - 3.11 中島聡×海部美知トークイベント02：『おもてなしの経営学』執筆について",
    "url": "/2008/4/22/2008-04-22-post/"
  },
  {
    "id": "2008-04-23-post",
    "title": "[anything.el](http://www.emacswiki.org/cgi-bin/wiki/anything.el) is everything!",
    "date": "2008-04-23",
    "categories": [
      "Emacs"
    ],
    "file_path": "_posts/2008-04-23-post.md",
    "content": "今更ながら、anything.el を使いはじめた。\nすごいすごいとはいろんなブログで読んでいたけど、これは本当にすごいわ。\nいままでバッファを切りかえる際、バッファ一覧を C-xC-b で出して C-xC-o してバッファ一覧からインクリメンタル検索していたのが、\nC-; してインクリメンタルするだけになった。\nこれは、Emacsの標準機能になるのも時間の問題だと思う。\nrubikitchさんところの2007-07-25 - ’(rubikitch wanna be (a . lisper))が参考になる。\nちなみに、私の設定はこんな感じ。これでどんな状態からでも C-;でanythingが起動するぞ。\n(iswitchb-mode 1)\n\n(require 'anything-config)\n(setq anything-sources (list anything-c-source-buffers\n anything-c-source-bookmarks\n;; anything-c-source-recentf\n anything-c-source-file-name-history\n anything-c-source-locate))\n(define-key anything-map (kbd &quot;C-p&quot;) 'anything-previous-line)\n(define-key anything-map (kbd &quot;C-n&quot;) 'anything-next-line)\n(define-key anything-map (kbd &quot;C-v&quot;) 'anything-next-source)\n(define-key anything-map (kbd &quot;M-v&quot;) 'anything-previous-source)\n(global-set-key (kbd &quot;C-;&quot;) 'anything)\n(anything-iswitchb-setup)\n\nこの設定を動かすには、EmacsWiki: anything.elとEmacsWiki: anything-config.elの両方のインストールが必要。\nEmacs使っている人はぜひanything.el を使おう。",
    "url": "/2008/4/23/2008-04-23-post/"
  },
  {
    "id": "2008-05-05-post",
    "title": "「空気」の研究",
    "date": "2008-05-05",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-05-05-post.md",
    "content": "日本人の気質について研究した本。\nなぜ日本人が『空気』に支配されてしまうのかという事について、かなり踏みこんで解明しようとしている。\n身近な例を挙げて、空気とは何か、どんな性質があるかに言及されているが、\nその中でも私が、普段の生活で空気に支配されそうになった時に、それに対処する上で\n役に立ちそうだと思える事柄を箇条書きにしてみた。\n論理やデータと空気では空気の方が強い。\n-- いくら専門家が論理的過程を得て結論を出しても、『あの空気ではそうせざるを得なかった』で空気の勝ちとなる。\n空気のせいにしてしまえば、誰も責任をとらなくても良い\n-- その決断をしたトップに『なぜあんな決断をしたのか』と後で聞いても、『あの空気では...』という具合に空気のせいにできるし、それが許されてしまう。\n空気に支配された組織が起こす間違った活動は、取りかえしがつかないレベルにまで到達するまで方向転換できない。\n-- 戦艦大和の出撃を中止できなかった例がある。\n空気の大きいヤツのことを『ブーム』というのではないか\n結局日本人が、なぜ空気に支配されやすいのかは宗教的な側面が大きいという話だが\nその辺はちょっと小難しいので、ここではパスする。\n(参考に書いておくと、神の数が1なのかnなのかの違いによるものだそうだ)\nとりあえずは空気というものの存在と、まずはそれが何者かということを把握できるという点だけでも一読の価値があると思う。\nところで、この本が書かれたのは1983年ということで、もう20年以上が経過している。\nにもかかわらず、言説が全然古くなっていないのには驚く。今日でも全くもって通用する内容だ。\nそれは結局のところ日本人の方が全く変化していないということだろう。\n最近の思考停止している政治も結局、空気に支配されていて水を差せない状態に成るのではないか。\n『地方格差は悪、平等は善』という言葉とか、『世代で医療に差をつけるのはもってのほか、あってはならない』とか\n空気が邪魔して論理的なトレードオフができない状態にはまりこんでいるのではないか。と思う。\nたぶん、日本に鳥インフルエンザウィルス(H5N1型)が広まったとして、ワクチンが全国民に\n行きわたらないことが分かった時、どんな決断ができるか。\n論理的に考えれば、将来がある若い世代を優先して、ワクチンを配るか、体力の弱い高齢者を優先するかなど\n議論の余地があると思うが、日本の政府はどうなんだろう。マスコミに煽られて数が足りないという現実はうやむやのままに、\n平等に配布しないなんてありえないという空気に支配されるという恐ろしい結末もあながち無いとも言えない。\n最後に日本人がこの空気の支配からどのように脱出して来たかは別の機会に記したいと書かれているので、\nその本を探し出せたら、また感想を書いてみようと思う。",
    "url": "/2008/5/5/2008-05-05-post/"
  },
  {
    "id": "2008-05-09-post",
    "title": "] 1.0.7.3 が[リリース](http://www.kahua.org/show/info/Release%20Note)された",
    "date": "2008-05-09",
    "categories": [
      "Kahua"
    ],
    "file_path": "_posts/2008-05-09-post.md",
    "content": "私の書いたコードも取りこまれた。\nといってもGaucheではなく、Emacs Lispなんだけど。以下、Release Note の引用。\n 2. kahua.elにおいて、kahua-shell モードのバッファが表示されていない\n 時、kahua-shellにて評価された結果をミニバッファに表示するようになり\n ました。この機能は、Kiyoka Nishiyamaさんによって実装されました。\n今後も、開発者のユーザビリティ向上にもっと貢献して行きたい。",
    "url": "/2008/5/9/2008-05-09-post/"
  },
  {
    "id": "2008-05-15-post",
    "title": "図書館の本棚をMy本棚とすることの限界",
    "date": "2008-05-15",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2008-05-15-post.md",
    "content": "私が読んだ本は、余程の事が無いかぎり図書館に寄贈している。\nでも、そのやりかたでは梅田さんの様に本棚を前にして『自分の写し絵』を眺めることはできないなぁと思った。\n以下引用。\n- 2008-05-09 - My Life Between Silicon Valley and Japan:グーグルに淘汰されない知的生産術\n ちなみに自宅と会社には、本が合計一万五〇〇〇冊ほどありますが、本の整理\n についても、どういう配置にすると必要な本に辿り着くまでのアクセス時間を\n 短縮できるか、いつも考えています。\n(略)\n 本棚はその時々の自分の写し絵だと考えています。だから、年に一度くらい、\n 大規模な配置替えを行いますね。果たして配置替えの時間を投資するほど、自\n 分の関心は変わっただろうかと常に注意していて、あるとき見極めて、一気に\n 取り掛かります。配置替えが終わった本棚を俯瞰して眺めることで、自分のテー\n マが浮かび上がってくることもあります。本棚というのは、そもそも大量の本\n を俯瞰して眺める道具でもあるわけですから。\n最近図書館に行って、本棚の前に立っても、自分が納得したレベルの本だけが集められているわけでは無いし、自分の都合とは無関係に列んでいるのでなんかスッキリしない。\n俯瞰して眺めることができるMy本棚が欲しくなってきた。\nやっぱりバーチャルで検索したり、小さい画面でスクロールして見れるのとでは、着想という点で大きな差が出るんだろうな。\n(thumb http://www.hondana.org/) 本棚.org\nは使った事無いんだけど、これをもっと進化させることが出来たら、本棚を俯瞰してみたり出来るのかな。\nそれともやっぱり物理的に本を手に取って配置替えなどをする事に意味が有るんだろうか。",
    "url": "/2008/5/15/2008-05-15-post/"
  },
  {
    "id": "2008-05-17-post",
    "title": "ウェブ時代 5つの定理を読む",
    "date": "2008-05-17",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-05-17-post.md",
    "content": "とにかく力をもらえる本だ。\nプライベートな時間にコードを書くとか、デバッグするとか、いろんな事が面倒臭くなった時に読むと自然と力が湧いてくるんだよねぇ。\nロッキーのテーマを聞きながら腹筋すると軽々できる気がするのと同じ効果かも(笑)",
    "url": "/2008/5/17/2008-05-17-post/"
  },
  {
    "id": "2008-05-21-post",
    "title": "『海辺のカフカ』",
    "date": "2008-05-21",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-05-21-post.md",
    "content": "久々に村上春樹の小説を読む。\n村上春樹の小説はほとんど読んでいるはずだけど、カフカはまだだった。\nところで、こんなに村上春樹の文体は極端だったっけかと思う。どんどん村上春樹のモノマネみたいになっているような。\n実際的にもプラグラマティカルにも。\nというか\"実際的\"と\"プラグラマティカル\"は同じ意味だと思っていた。調べたらやっぱり同じだった。春樹に騙されるところだったぜ。\nまあそういうのは、『村上春樹の鼻毛問題』と呼ばれていて、春樹好きの私にはとりあえず気にしない。\n 参考:〒カワチ日手紙〒:俺には『補助線』しかない - livedoor Blog（ブログ）\n話は変わるが、ストーリーの中にいろんな音楽が出てきて面白い。形而上学的にも。\n実際にYouTubeで検索して聞いてみたり。そういう楽しみかたもあったか。\n二倍楽しめた。\n最近は読まなくなったけど、たまには小説も読んでいきたい。",
    "url": "/2008/5/21/2008-05-21-post/"
  },
  {
    "id": "2008-05-26-post",
    "title": "Kansai.pm勉強会参加予定",
    "date": "2008-05-26",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-05-26-post.md",
    "content": "久々に、Kansai.pmに出席してみる予定。\n イベント/第9回ミーティング告知 - Kansai.pm\n今回は人数多いよ。\n Kansai.pm第9回ミーティング参加登録\n私は、HadoopとMooseの話に興味があるので参加するんだけど、\nいつもより多いのは、やっぱり伊藤直也さん効果かな？\n久しぶりにKtatさんにも会えそうだし楽しみ。",
    "url": "/2008/5/26/2008-05-26-post/"
  },
  {
    "id": "2008-06-16-post",
    "title": "文字コードを自動認識するgrepが欲しい",
    "date": "2008-06-16",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2008-06-16-post.md",
    "content": "LVというフリーソフトウェアに複数の日本語エンコードを自動認識するlgrepというプログラムが付属している。\nが、-r ( --recursive ) オプションをサポートしていない。\nzshの \"*/.java\" 形式のワイルドカードを使えば -r を代用できるが、展開後のファイル数が爆発すると問題が発生する。\n (1行の長さ制限に捕まると、エラーが出てgrepの実行前に止められる)\nGaucheでgrepを書いてみようかなとも思うが、そこまでするほどでも無い気がするんだよな。\nこういうのを許容時間内に書けるスキルが必要だなーと思う今日この頃。\n\n[ktat]さんからコメントをもらったので、追記。\n lgrep ですが、 find -print0 -type f | xargs -0 lgrep 'hoge' とかどうでしょうか。\nいつもこのコマンドで実行しています。何回もコマンドを打ちこみ直すのが大変なんです。\n alias lgrep='find -print0 -type f | xargs -0 lgrep ' とか。パス渡せませんが。\nそうか。aliasか...\nこのアドバイスでbashのfunctionを使えば実現できそうな気がしてきたぞ。\nうまくいったらまた記事を書きます。\n\n[ktat]さんのコメントをヒントにスクリプトを作ったので追記。\n結局このスクリプトで運用開始した。この程度で十分使えることが判明した。\n-- lgrep-rのソースコード\n\n#!/bin/bash\n\nif * &quot;&quot; = &quot;$1&quot; * ; then\n echo &quot;usage 'lgrep-r *pattern*'&quot;\n exit 1\nfi\nfind . -print0 -type f | grep -z -Z -v '.svn' | xargs -0 lgrep -n $1\n\n出力をUTF-8に揃えたい場合は、最後の行を次の様に変更すればOK。\nfind . -print0 -type f | grep -z -Z -v '.svn' | xargs -0 lgrep -Ou8 -n $1\n\n-- lgrep-rの動作\n--- カレントディレクトリから再帰的に '日本語検索パターン' でgrepする。\n--- ファイルの日本語コードは自動判別する\n--- Subversionの管理ディレクトリ.svnは除外する\n--- grepの結果には行番号も含む ( grep -r '日本語' * の結果に合わせてある )\n-- 使いかた\n--- コンソールから\nlgrep-r '日本語検索パターン'\n\n--- Emacsから\nカスタマイズ変数grep-commandを '/usr/local/bin/lgrep-r 'に設定しておけば\nM-x grep で日本語エンコードを自動認識したgrepが使える。",
    "url": "/2008/6/16/2008-06-16-post/"
  },
  {
    "id": "2008-06-21-post",
    "title": "ルパン三世のJAZZ CD決定版を見つけた",
    "date": "2008-06-21",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2008-06-21-post.md",
    "content": "私は、もともとJAZZピアニストは好きで、ビル・エヴァンスや、キース・ジャレットのCDはかなり持っているのだが、\nAmazonを徘徊している間に、ルパンのテーマや挿入曲の作曲者がJAZZピアニストだったということを知った。\nさっそく、大野雄二のCDの中で一番ルパンの曲が多く入っているこのCDを買ってみた。\nこれは当たりだよ。ルパンのタイトルが付いているCDが沢山ある中で迷ったらコレを選べばOK。\nどの曲も原曲を聞いたことある曲ばかりなので、どうアドリブ展開しているかが分かりやすい。\nかなり抑制され、落ちついた演奏で、アドリブもそんなに飛躍した部分は少ない。\nJAZZを初めて聞く人にもオススメできるし、JAZZに詳しい人でも十分楽しめる内容だ。",
    "url": "/2008/6/21/2008-06-21-post/"
  },
  {
    "id": "2008-06-22-post",
    "title": "]",
    "date": "2008-06-22",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2008-06-22-post.md",
    "content": "[perl.TMTOWTDIの謎を探る]について\nオリジナルは2002/05/10に書いた文書を[OldType]に移してリンク切れ等をメンテナンスした。\n実は、このエントリはPerlの話かと思えば[Gauche]の話に終始している。Perl Loveの人はごめんなさい。\nLarry Wallは深い\n私は、2005年に[Sumibi.org]を開発したあたりから、Perlは使わなくなった。\n久しぶりにこの文書を自分で読んでみたが、Larry Wall深いなーと思った。(この文書では多くのLarry Wallの文章の引用をしている)\n特に、Larry Wallが現実が複雑(乱雑)だということに目をつぶるのではなく、むしろそれに対応した言語を設計することによって、現実を単純化することができるということを解ってやっているというところが凄い。その事を知らずにPerlのソースが汚いと言っている人は浅いのでご注意願いたい。\nPerl的な、あまりにもPerl的な\n[Gauche]の作者のShiroさんもおそらくその辺は意識的にも無意識的にも狙っているはずで、それは[Gauche]という名前にも表現されている。\nSchemeという、本来は乱雑さを嫌う設計思想の素材を使って、現実の乱雑さにも対応できるツールの構築に挑戦されている。\nGaucheプログラミング(立読み版):Gaucheの設計思想や誕生の背景から引用させて頂く。\n Scheme言語の設計思想の一つに\"Right Thing\"という考えがあります。物事を\n 実現するやり方として正しいやり方 をとるべきだ、という意味です。\n(略) \n Schemeの設計思想は、言語を強化するために機能を追加していくのではなく、\n 後から機能追加が必要になるような 弱点を削っていくというものです。この\n 考えはまさに\"Right Thing\"(正しいやり方)に根ざしています。\n Gaucheとはフランス語で\"左\"という意味です。つまり\"Right\"(右)に対する\n \"Left\"(左)です。\nそんなに厳密に“正しく”やらなくても、実用に使えるならいいじゃん\n\nといったところでしょうか。名前からも分かるように、Gaucheの設計思想には\n こうしたユーモアが隠れています。\nこのPerl的な設計思想の傾倒は、日常の仕事でのGaucheの使いやすさに直結していて、非常にうまく行っていると感じている。\nPerlというかLarry Wallの影響力はやっぱり絶大なのだと再認識した日だった。",
    "url": "/2008/6/22/2008-06-22-post/"
  },
  {
    "id": "2008-06-29-post",
    "title": "Rubyの構文が柔軟すぎる(複雑すぎる)件",
    "date": "2008-06-29",
    "categories": [
      "プログラミング言語"
    ],
    "file_path": "_posts/2008-06-29-post.md",
    "content": "ちょっと思う所があって、Rubyの構文を調べてみた。\nそんな中Rubyソースコード完全解説がWebで公開されているのを知った。\nこんなものが公開されているとは...青木峰郎さんに感謝。\nさて、話をRuby構文に戻す。\n第10章 パーサのrubyの文法（概要）のあたりを読むと、すごいことが分かってくる。\n以下引用\n Rubyに存在するあらゆる構文は括弧で囲むと primaryになってしまう、即ちメソッドの引数にも代入の右辺にもできるということで\n ある。これはとんでもない事実だ。実際に確かめてみよう。\np((class C; end))\np((def a() end))\np((alias ali gets))\np((if true then nil else nil end))\np((1 + 1 * 1 ** 1 - 1 / 1 ^ 1))\n\nこのファイルを-cオプション付きでrubyにかける。 -cは構文チェックをするオプションだ。\n% ruby -c primprog.rb\nSyntax OK\n\n実に信じ難いことだが、本当に通ってしまった。どうやら勘違いではないようである。\nなぬー。\n実際は、後で構文木の構築を行う際にエラーになるパターンもあるだろうが、このパーサのルールはトンデモない。\nPythonと比べてRubyがPerlの如き柔軟性を感じさせる理由はこのへんかもしれない。\nYARVのプレゼンで、ささださんがRubyは何でも式に成ってしまうので最適化という面では\n非常に苦労するという話をされていたが、どうやら、このことだったのか…\nちょっと実験でRubyっぽいサブセット構文のパーサを試作してみようと思ったが、\nRubyっぽいだけで結局Rubyの本質が抜け落ちたものに成りそうで、やめた。\n練習としてはいいと思うけど。\nRubyソースコード完全解説の他の章も読んでみるといい。Rubyの奥行きはかなり深い。",
    "url": "/2008/6/29/2008-06-29-post/"
  },
  {
    "id": "2008-07-04-post",
    "title": "URLで取得したHTMLのタイトル文字列を取得する関数",
    "date": "2008-07-04",
    "categories": [
      "Emacs"
    ],
    "file_path": "_posts/2008-07-04-post.md",
    "content": "[oldtype-mode]でURLをリンク書式に変換する機能をサポートした。\nこの関数はURLで取得したHTMLのタイトルを取得して、書式に埋めこんでいる。\nといっても、HTMLの解析部分はw3mにおまかせ。\nなぜならEmacsLispだけでは、到底実現できないからだ。\nNet上に存在する現実のHTMLは、文字コードが多様すぎるのと、タグの対応がデタラメすぎるのとで、ロバストな処理を実現するのは不可能に近い。\nこういう場合は外部のプログラムを使うのが一番。\n;;\n;; *fetch command*\n;; w3m -no-graph -halfdump -o ext_halfdump=1 -o strict_iso2022=0 -o fix_width_conv=1 URL\n;; | awk '-F&quot; nil (point-min) (point-max))\n (buffer-substring-no-properties (point-min) (point-max))))\n (t\n &quot;No Title&quot;)))\n\nこのコード、もしよければ使って下さい。\nこの関数を呼ぶと、グローバルのmatchデータが破壊されるので、そこだけ注意するべし。",
    "url": "/2008/7/4/2008-07-04-post/"
  },
  {
    "id": "2008-07-06-post",
    "title": "BOSE QC3を試す",
    "date": "2008-07-06",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2008-07-06-post.md",
    "content": "うめだ阪急店 / セレクトショップ / Bose ボーズに行ってきた。\n 梅田でも、BOSE QC3を試せる店が出来たので行ってきた。\n前から気になっていたノイズキャンセリングヘッドホンを試してみた。\n\nまわりのお店はバーゲン中の紳士服の販売のフロアなのでかなりザワザワしている。\nおもむろにヘッドホンをかけ、あんまり期待しないまま、店員さんに電源ONしてもらった。\nな、なんと... まわりの雑踏が消えた。静寂と言ってもいいくらい。\n期待以上だったよ。こんなにノイズキャンセリングが効くとは知らなかった。\nもう買うことに決めたぞ。\n後はamazonで買うか、店で買うかを決めるだけ。",
    "url": "/2008/7/6/2008-07-06-post/"
  },
  {
    "id": "2008-07-07-post",
    "title": "突然コンパイラの勉強を始める",
    "date": "2008-07-07",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-07-07-post.md",
    "content": "10年前に熱心に読んだきり、本棚の肥やしになっていたコンパイラの本をひっぱりだしてきた。\n昔、行実行プロファイラを作った時にC言語のパーサをひととおり書いたことがあるのだ。\nその時にこの本を何度も読んだ。初めて読む本としても、実用的なものを作る時にもかなりオススメの本。\nところで、まだ売ってあるのかな？\nうわっ、amazonで買えないみたい。中古でなら10000円であるみたいだけど。\nyaccによるCコンパイラプログラミング (C STEP UPシリーズ): 近藤 嘉雪\n持ってて良かったー。\nなにを作るかは、まだ内緒。たぶん面白いオモチャができると思う。\nとりあえず四則演算のインタプリタを作るところからリハビリしてみるよ。",
    "url": "/2008/7/7/2008-07-07-post/"
  },
  {
    "id": "2008-07-18-post",
    "title": "BOSE QC3を買った。クラッシックが楽しくなった。",
    "date": "2008-07-18",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2008-07-18-post.md",
    "content": "早速試してみた。噂通り驚愕の性能だ。\n音楽なしで電源を入れると、どんな雑踏の中でもプールに潜った時みたいに静寂が訪れる。\n自分の心臓の音とか、関節の動く音とかが聞こえる。\n BOSE QuietComfort3 ノイズキャンセリングヘッドホン\nそして、iPodにつないで音楽を再生すると、フルオーケストラの小さい音まで全部聞こえる。\n早速、ウィーン・フィル演奏のラクリモーサを聞いてみた。\nそんなに大きな音にしなくても細かいところまではっきりわかる。\n凄いよーこれ。値段も凄いけど。",
    "url": "/2008/7/18/2008-07-18-post/"
  },
  {
    "id": "2008-07-20-post",
    "title": "ビョークのDVD",
    "date": "2008-07-20",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2008-07-20-post.md",
    "content": "ビョークはCDでかなり頻繁に聞いているのだが、このDVDを見てビョークの音楽の奥行の深さを知ることができた。\nこのライブに使われた楽曲の多くは、世界中の小さな音を大量に集めて、それを上手く混ぜ合せて音楽にしている。\n例えば、椅子を人差指で叩く様なプツッっというような音や、トランプを机の上でコツコツと揃える音や、砂利の上をザクッザクッと歩く足音なんかがリズムに使われている。\nライブでは実際に砂利の上を歩いて音をマイクで拾っている。\nオーケストラが途中入ってきても絶妙なバランスで両方の音を壊すことなく共存している。\n音楽好きの人は一度は聞いてみてほしい。\nまた、音楽DVDにしては珍しくTSUTAYAでレンタル可能なので、何かのついでに借りて見てもらえればとおもう。\n\nそういえばアンカテの人もビョークを絶賛していたのを思いだした。\n-- bjorkとzawinul、民衆の音楽と地球の音楽 - アンカテ\n\nYoutubeで見つけた代表曲を貼っておくよ。\n YouTube - Björk - Jóga\n\nYouTube - bjork-hyper ballad",
    "url": "/2008/7/20/2008-07-20-post/"
  },
  {
    "id": "2008-07-23-post",
    "title": "パーサの勉強のつづき",
    "date": "2008-07-23",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-07-23-post.md",
    "content": "パーサの勉強のため、本を読みつづけている。これも10年前位に買った本。\n以前勉強していたのと、Schemeプログラミングをやって再起を理解する脳味噌ができあがっているためか、スラスラ読める。\n昔は擬似コードを読む度にすごく時間がかかっていたのに… 不思議だ。\n久しぶりに読んだけど、やっぱりいい本だと思う。\nパーサジェネレータはGauche trunkに入っているparse.pegを使う予定。\n本当に自分が作りたいものがpegで出来るかどうかはまだわからないけど、いろいろ試してみよう。\n参考資料は、これくらいしか見つからないけど、これで十分かも。\n- Rui:ParsingExpressionGrammar\n- Parsing expression grammar - Wikipedia, the free encyclopedia\n実際に何か動かしてみたタイミングで、またブログ記事を書く予定。",
    "url": "/2008/7/23/2008-07-23-post/"
  },
  {
    "id": "2008-07-27-post",
    "title": "7月27時点のGauche trunkをビルドした",
    "date": "2008-07-27",
    "categories": [
      "Gauche"
    ],
    "file_path": "_posts/2008-07-27-post.md",
    "content": "目的はparse.pegを動かすため。\n以下に、手順をメモしておく。\n(7月27時点のGauche trunk は 0.8.14 としてリリースされるハズのバージョンです)\nGauche-0.8.12をアンインストール\n\nアンインストールでやられる\nMacOS X leopardで Gauche 0.8.12が入っている状態からスタート。\nGauche trunkのビルドには最新のリリースバージョン(0.8.13)が必要なので、まずはアンインストール。\nGaucheに限らないけど、システムに2バージョン以上の処理系が上書きインストールされた状態で使うと正しいバージョンのライブラリがロードされないとかいろいろ問題が起きると思われる。\nそんなのでハマりたくないので、ちゃんとアンインストールする。\nで、別の問題でハマる。\nGauche-0.8.12のmake uninstallを実行すると、Boehm GCのダイナミックリンクライブラリが消えた。\nやられた。\nGaucheのリリースノートを見ると0.8.13で直っていると書いてある。\nだからといって、今回の件は0.8.12をアンインストールする段にはどうしようもない。\n同じBoehm GCを使うw3m-0.5.2が動かなくなって気がついた。\n\n気を取りなおして、Boehm GC 7.1をインストール\n前は、Boehm GC 7.0をインストールしていたが、この際最新にしてみた。\nちなみに、Gaucheのディストリビューションにはgcが内蔵してあるので、後で上書きされるかも。\nGauche trunkもBoehm GC 7.1になっているのでまあどちらでも良しとしよう。\nw3m-0.5.2が動くようになった。\nw3mとの相性としては、後方互換性が有るようだ。\n\nGauche-0.8.13をインストール\nGaucheのtrunkをビルドするにあたって、なるべく新しい方ものをベースにするほうが良さそうなので0.8.13をビルドする。\n問題なくビルド・インストールできた。\nGauche trunkをインストール\nautoconfが必要な以外は、configure &amp;&amp; make &amp;&amp; make installできた。\nちなみに、ポイントだけ書いておくと、0.8.13アンインストールもちゃんとやるほうが良いだろう。\n私の実施した手順は\n- Gauche trunk\n-- Subversionから取得\n-- ./DIST gen\n-- configure\n-- make\n- Gauche 0.8.13\n-- make uninstall\n- Gauche trunk\n-- make install\nちなみに、この時点でのGauche trunkはバージョン表示が0.8.13のままなのでtrunkをインストールしたことを忘れてしまわないこと。\n $ gosh -V\n Gauche scheme interpreter, version 0.8.13 *utf-8,pthreads*\n\ntrunkなのに勘違いして0.8.13の積もりでバグ報告すると、shiroさんが混乱されるので注意。\nparse.pegが動くかテスト\ntestに全てパスしたよ。めでたしめでたし。\n bash-3.2$ cd Gauche-trunk-20080727/Gauche/ext/peg\n bash-3.2$ gosh ./test.scm \n Testing parser.peg ... \n --------------------------------------------------------------------------\n testing bindings in # ... ok\n test rope-&gt;string, expects &quot;abc&quot; ==&gt; ok\n test rope-&gt;string, expects &quot;012abcX&quot; ==&gt; ok\n test rope-&gt;string, expects # ==&gt; ok\n -------------------------------------------------------------------\n test $return (success), expects &quot;xyz&quot; ==&gt; ok\n test $fail (failure), expects (0 &quot;error&quot;) ==&gt; ok\n test $expect (failure), expects (0 &quot;character&quot;) ==&gt; ok\n -----------------------------------------------------------------------\n test $string (success), expects &quot;abc&quot; ==&gt; ok\n .\n (略)\n .\n test calculator (success), expects 36 ==&gt; ok\n test calculator (success), expects -1 ==&gt; ok\n passed.\n bash-3.2$ \n\n参考URL\n\nGauche:VMの最適化\nGauche:VM命令セットの変更とビルド",
    "url": "/2008/7/27/2008-07-27-post/"
  },
  {
    "id": "2008-08-09-post",
    "title": "そろそろオレ言語でもやっておくか(1)",
    "date": "2008-08-09",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-08-09-post.md",
    "content": "オレ言語(いわゆる言語を自作すること)に興味が出てきた。\n自分が実際に作ってみるという観点で有名どころの言語仕様とか言語設計者のプレゼン資料とかを見ると、なかなか素人には恐ろしく高い壁に見える。\n特に、Rubyソースコード完全解説を読んだり、ニコニコ動画でトーク「幸せなRuby生活に必要なこと」を見たりすると、Rubyが様々なトレードオフの中でバランスをうまく取りながらできたシロモノだということがわかってくる。\nそんなことはとりあえず置いといて、素人なりに何ができるかを探ってみるつもり。\nまずは、1ヶ月間くらいはいろんな本を読むことに集中。",
    "url": "/2008/8/9/2008-08-09-post/"
  },
  {
    "id": "2008-08-31-post",
    "title": "そろそろオレ言語でもやっておくか(2)",
    "date": "2008-08-31",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-08-31-post.md",
    "content": "オレ言語(いわゆるプログラミング言語を自作すること)構想の続き。\nでも、いま育児真っ只中なので、実際に手を動かして何かを作る時間なんか無いのっ。\nいまは片っ端から必要っぽい資料を読んでいるところ。\n赤ちゃんは抱っこを止めた途端に泣くのでコンピュータに触ることはできない。\nでも、本を読むだけなら赤ちゃんをだっこ紐でぶら下げたままでもできるもんね。\nWebの資料も印刷すれば読める。\n(そういえば小学校に置いてあった二宮金次郎の銅像を思いだした)\nというわけで、今回は完成イメージを紹介する。今後も変わっていくと思うけど。\n完成イメージ\n自分の頭にイメージしている言語のイメージは簡単にいうとRubyとDylanを足して2で割ったようなもの。\nその言語のソースコードをパッと見た程度ではたぶんRubyに見えるだろうと思う。\n式もinfix notationで記述でき、メソッドチェーンもRubyの様に自然に書けるとうれしいだろう。\nDylanが失敗した道筋をもういちどたどることになるかも知れないが、何事もやってみないと分からないし、その過程自体が楽しいのならやってみても言いんじゃないかと思える。\nベースとなるシステムとしてはGaucheを使うことを想定している。\nCでは書かず、ArcのようにSchemeで書く。Gaucheのライブラリとして実装するのがいいかな。\n読んだもの\n\nRubyソースコード完全解説\n\n初めてのRuby: Yugui\n\nThe Dylan Reference Manual\n\n問題点\n今気づいているだけでも沢山の問題点がある\n例えば、\n\n'-' '+' 演算子とシンボルの関係\nSchemeでは '-' '+'がシンボルに使用可能。すなわち'a-b'のような変数名や関数名が定義可能。\nDylanでは '-' や '+'演算子をinfixで書けると同時にSchemeと同様'-' '+'をシンボルに使用可能。\nよって'-'演算子の前後にスペースを開けないといけない。\n 例) symbol-a から symbol-b を引き算する\n\n symbol-a - symbol-b \n\nこれはひどいよ。すぐに事故が起きそう。\n\nclassベースのオブジェクト指向とgeneric関数ベースのオブジェクト指向の折合いのつけかた\nこれは、言語デザインのポリシーとしてはDylanのようにgeneric関数ベースの考えかたで問題ないと思うが、\n構文がRubyに似ている分、Rubyから来た人は驚くだろう。\n\nコメント歓迎\n『多分それうまくいかないよ』とか『こうすれば』とか色々御意見おねがいします。",
    "url": "/2008/8/31/2008-08-31-post/"
  },
  {
    "id": "2008-09-03-post",
    "title": "そろそろオレ言語でもやっておくか(3)",
    "date": "2008-09-03",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-09-03-post.md",
    "content": "以前からRubyの構文を見たり、Gaucheのリファレンスマニュアルを見たりして妄想中。\nこんな風に書ければいいなぁ。\n 注意:全体の構文の辻褄を会わせようとはしてません。雰囲気で希望だけを書いていっています。\nFizzBuzz\nほぼRubyの様に書けるとうれしい\ndef fizzbuzz( num )\n if (0 == x % 15)\n &quot;FizzBuzz&quot;\n elsif (0 == x % 3)\n &quot;Fizz&quot;\n elsif (0 == x % 5)\n &quot;Buzz&quot;\n else\n num.to_s\n end\nend\n\nprint (1..100).map { |num|\n fizzbuzz( num )\n}\n\n関数定義\n\ndefを使って\n\ndef add1( x )\n x + 1\nend\nadd1( 5 ) # =&gt; 6\n\nブロックはそのままlambdaになる\nJavaScriptの様に代入可能\n\nadd1 = { |x| x + 1 }\nadd1( 5 ) # =&gt; 6\n\nブロック\n\n名前付きブロックはSchemeの named let(letrecでもいいかな)に置きかえられる\n\nloop { |arg|\n if eof?(arg)\n last\n else\n loop(read-char())\n end\n}\n\nRubyのブロックはSchemeのlambdaすれば良いのでは\n\nprint open( &quot;sample.txt&quot; ) { |f|\n f.readlines.map-with-index { |index,str| }\n index.to_str + str\n }\n}\n\nオブジェクト\n\nGaucheでオブジェクト定義されている型のリテラル\n\n &quot;10&quot;.to_i # =&gt; 10\n 10.to_s # =&gt; &quot;10&quot;\n\nまだまだ、多値をどう扱うとか、配列やハッシュがどう記述できたら嬉しいかとか、#t #fはどうするか、nilはどうするか、どうやったらオープンクラスにできるかなど、課題は色々ある。\n今後思いついた順に書いていく予定なので、お気楽に眺めてもらえればと思う。\nこのシンタックスでGaucheプログラミングが可能になれば、ひらがなの名前を名乗る若い方たちがGaucheやSchemeにに興味を持ってくれるんではないか。甘いかな...\nそれを目的とするなら何か方向性が間違っているかもしれないけど。\n巷で言われているようにオレ言語は自分が楽しむためにあると思うが、他にも、私にとってはSchemeのマクロまわりを深く理解する教材としての意味も大きいだろう。",
    "url": "/2008/9/3/2008-09-03-post/"
  },
  {
    "id": "2008-09-07-post",
    "title": "昔のビョーク",
    "date": "2008-09-07",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2008-09-07-post.md",
    "content": "育児中なので、赤ちゃんを抱っこしたままできる事というと、音楽DVDを見ること。\nまたまたビョークのDVDを買って、再生しっぱなしにしている。買ったのはこれ。\nこの『インサイド・ビョーク』を見るとビョークがThe Sugarcubesというバンドで歌っている昔の映像が出てくる。\nYouTubeで検索したらすぐに出てきた。便利な時代になったよねぇ。\n YouTube - The Sugarcubes - Birthday (English)\nなんだこの不思議なコードは。昔のビョークをたどると面白いものが出てきそうな予感。\n歌い方も今と違うね。",
    "url": "/2008/9/7/2008-09-07-post/"
  },
  {
    "id": "2008-09-20-post",
    "title": "Gauche Hacksの構成の参考になる本の目次を晒しておく",
    "date": "2008-09-20",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2008-09-20-post.md",
    "content": "Gauche Hacksのネタを考える時の参考にしよう。\n- [book.toc.PHPHacks]\n- [book.toc.PerlHacks]\n- [book.toc.SQLHacks]",
    "url": "/2008/9/20/2008-09-20-post/"
  },
  {
    "id": "2008-09-23-post",
    "title": "そろそろオレ言語でもやっておくか(4)",
    "date": "2008-09-23",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-09-23-post.md",
    "content": "プログラミングとはどういうものかという本質論。\n 【プログラミングとはどういうものかという本質】とは何だと思いますか？ (参考)http://q.hatena.ne.jp/1221708568 - 人力検索はてな\nムズカシイ。\nオレ言語を作ることを妄想してみると初めて分かった。そういう問題につきあたるのか。\n最近話題になったなてなアンケート\nなかでも注目すべきこのコメント(投稿者practicalschemeさんはプロフィールのSchemer兼Actorという属性からshiroさんだと推測したのだけど)\n プログラミングに詳しい人に質問です。大学でプログラミング経験の学部一年生向けにプログラミングを教えることを想定しています。週１コマ×半年程度の限られた時間で、プ.. - 人力検索はてな\n 一部抜粋\n xx言語を他人に勧めたいと思ったなら、印象以外にxx言語の何に着目してそう\n 思ったのか。その着目した点は他の言語には無いのか。他の言語に無いとした\n ら、何故他の言語はその点を採用しなかったのか。逆に他の言語にあってxx言\n 語に無いものについて、何故それはいらないと思ったのか。それらの価値判断\n をひっくるめて、自分にとってプログラミングという行為はどういう意味を持っ\n ているのか。いくらでも考えを広げてゆくことができます。「『プログラミン\n グ言語について考える』ことについて考える」という問題は、その向こうに素\n 晴らしく豊穣な世界が広がっています。\nなぜ、多くの処理系実装者が『オレ言語をデザインするのは大変なのでSchemeを言語仕様どおり実装しました』という結論になるのかという質問への答えにもなっていると思う。\nオレ言語に手を出すのは楽しいけど、あまりにハードルが高いということだなぁ。\nどうするかなぁ。\n\nコメント by shiro:\nそんなことないですよ＞あまりにハードルが高い\nそりゃ完璧なものをつくろうとしたら大変だけど (いままで多分世界中の誰も成功していない) 裾野にだっていくらでも冒険ゾーンはあるのですから。\nさっきたまたまSICPを読み返してたら、献辞のところの「コンピュータサイエンスはまず何より楽しいものなんだよ。布教活動みたいに演台から講釈たれるんじゃなくて、自分が楽しんで、計算機が目に見えるもの以上であることを見通せば、まわりの人もついてくるよ」(超訳) みたいな話にじんと来ました。\n問題の奥が深いってことは、きっとやればやるだけもっと面白くなるってことですよ。\n\nコメント by kiyoka:\nshiroさん、コメントありがとうございます。\nまずは自分が楽しむところから始めてみることでしょうね。\nとりあえず妄想中のものをちょっとづつ動かしてみてから、オレ言語の世界に飛び込んでみます。\n私の興味は RubyライクなノーテーションをGaucheにそこそこうまくマッピングできたら、Ruby使いからどう見えるだろうというところです。\n言語デザインとしてのハードルは高いですが、プログラミング量は少ないと思いますので、いろいろ試してみたいと思います。\nDylanが失敗した理由は今はわかりませんが、もし失敗してもその失敗した理由をつかめるんじゃないかと思います。\n今は、それだけでも意味があるような気がしています。\nあまり気負わずに始めてみます。\nコメント by shiro:\nそんなことないですよ＞あまりにハードルが高い\nそりゃ完璧なものをつくろうとしたら大変だけど (いままで多分世界中の誰も成功していない) 裾野にだっていくらでも冒険ゾーンはあるのですから。\nさっきたまたまSICPを読み返してたら、献辞のところの「コンピュータサイエンスはまず何より楽しいものなんだよ。布教活動みたいに演台から講釈たれるんじゃなくて、自分が楽しんで、計算機が目に見えるもの以上であることを見通せば、まわりの人もついてくるよ」(超訳) みたいな話にじんと来ました。\n問題の奥が深いってことは、きっとやればやるだけもっと面白くなるってことですよ。",
    "url": "/2008/9/23/2008-09-23-post/"
  },
  {
    "id": "2008-09-27-post",
    "title": "『実践Common Lisp』の著者の話",
    "date": "2008-09-27",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-09-27-post.md",
    "content": "驚いた。\n一番驚いた点は、本の構成でもサンプルコードのクオリティでもない。もちろん本はいいデキだ。\n一番驚いたのは、『著者の親父がLisperで、著者は子供のころからLispの利点を刷りこまれていた』こと\nメズラシすぎる。\n是非うちもやろう。今日からやろう。みんなやろう。",
    "url": "/2008/9/27/2008-09-27-post/"
  },
  {
    "id": "2008-10-03-post",
    "title": "並列処理のプログラミングの未来は純粋関数型言語にある？",
    "date": "2008-10-03",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-10-03-post.md",
    "content": "ゲームの世界でも、CPUのクロック数は頭打ちになりメニーコアの方向に行く。\n処理速度を向上させる為には、沢山のCPUコアをいかに有効に活用するか(並列化)しかない。\n最後には純粋関数型になるだろうととのこと。\n ゲームプログラミング界の巨人、Tim Sweeneyが「未来のゲーム開発テクノロジー」を語る\n Sweeney氏は純粋関数型言語のもつ並列処理安全性に着目しており、将来的に\n ゲームプログラミングはそういった処理系に移行していくべきだとした。\n Sweeney氏はそのひな形として言語“Haskell”を挙げているが、ゲームなどの\n 新情報を開発のメインストリームたり得る言語はまだ登場しておらず、将来に\n 期待しているという。\n\n私も概ね同意する。スレッドプログラミングの複雑さは最後には人間の限界を超えると思う。(もう超えている？)\n特に、画像処理やレイトレーシングなどの処理は副作用なしで記述しやすいプログラムの代表格だと思うので近いうちに関数型言語が主流になるんじゃないかと思う。",
    "url": "/2008/10/3/2008-10-03-post/"
  },
  {
    "id": "2008-10-11-post",
    "title": "革新的ソフトウェア企業の作り方",
    "date": "2008-10-11",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2008-10-11-post.md",
    "content": "この本ではソフトウェア会社といっても、請負とかコンサルタント業とかSI業者は除外されるので注意。\nなので、日本国内ではほぼ該当企業なしかも。\nとはいうものの、趣味でオープンソースソフトウェアを作っている人にもいろいろ勉強になる所はある。(OSSをやっている本人も決してビジネスには成らないと思っているハズなので)\n特に、マーケティングの章はOSSの人にも役に立つと思う。\n勿論オープンソースの話は、オープンソースでソフトウェアビジネスをするのはかなり難しいという意味合いでしか出てこないが、自分で立ちあげたオープンソースプロジェクトの社会での立ち位置を再認識できるとおもう。(\"会社での\"ではないことに注意)\nところで、オープンソースの周辺でビジネスをしている人は実際どうやっているんだろ。\n私はオープンソースをメインにした企業(一般的にはオープンソース企業と呼ばれる)で働いた事ないので分からないが、それぞれの企業で何らかの工夫がもりこまれているんだろうなぁ。\n一度、オープンソース企業を経営している人に秘密を聞いてみたい。",
    "url": "/2008/10/11/2008-10-11-post/"
  },
  {
    "id": "2008-10-16-post",
    "title": "オープンソースソフトウェアの布教活動もライブが基本？",
    "date": "2008-10-16",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2008-10-16-post.md",
    "content": "ミュージシャンの活動とOSSの布教活動の共通点に気がついた。\nOSSを黙々と作っても、なかなか使ってもらえない。\nその前にまず認知されるまでが大変。そこでライブの必要性が出てくる。\nミュージシャンがライブで新曲を披露するのと同じ。\nOSS開発者もLightning Talk等のチャンスを使ってプレゼンする必要があるし、効果は非常に大きい。\n実際に私も、Lightning Talk等をやった直後に実際にユーザが増えるということが過去に何度もあった。\nこの本に同様の事が書いてある。OSSでは無いが顧客とISVのギャップを埋めるという部分だ。\nこの本では、小さなISVは雑誌に広告を出すより展示会に出展すべきという話が書いてあるので参考になる。\nインターネットの時代になって、情報が洪水の様に人々に押し寄せる様になった。\n要するに、昔よりも人々のアテンションを得ることが難しくなっているということだと思う。\nライブはそのアテンションを得る一番有力な手段だと思う。\n最近、Lightning Talkやってないなーと自戒を込めて。",
    "url": "/2008/10/16/2008-10-16-post/"
  },
  {
    "id": "2008-10-17-post",
    "title": "私が初めて買ったCD",
    "date": "2008-10-17",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2008-10-17-post.md",
    "content": "最近音楽DVDを買いあさっているけど、思えば好みは変わってないなーと気が付いた。\n高校生の時、初めて買ったCDは多分これ。いまだに聴いている。\nもう20年弱も経っているのか。その後もStingのファンで有り続けている。\n他にもこんなCDを買ったなぁ。\nうわー、どれも今でも聞いているCDだ。\n音楽の好みってあんまり変わっていかないものなんだね。\nそういえば、Jazzが好きになった最初のキッカケもStingだった。\nまたそのうちJazzの話も書きます。",
    "url": "/2008/10/17/2008-10-17-post/"
  },
  {
    "id": "2008-10-25-post",
    "title": "世界金融危機とSF小説",
    "date": "2008-10-25",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2008-10-25-post.md",
    "content": "昔から、SF小説では政治や経済は人類には手に余る問題なのでコンピュータに任せてしまおうという思考実験が行われる。\nうまくいくか、いかないかの結論は作家の好みによって様々に分かれるけど、今回のサブプライムローンから始まった金融危機を見ていると、やっぱり人類の頭脳では扱い切れない問題なんじゃないかと思う。\n今は無理だけど、将来はコンピュータに任せてしまう(もしくはかなりの部分サポートしてもらう)方がいいのではないかな。\n久々に、そういう小説を読んでみたくなった。\nコンピュータが『人類は滅ぶしかない』という結論を出してしまうパターンと、コンピュータと人類がうまく共存している様を絶妙に描写しているパターンの両方読んでみたい。\nどんな小説があるか探してみようと思う。\n多分これを現実逃避というんだろうけど、個人にできることはあまり無いと思う。\nこの時期にそういうSFを読むのも一興だろう。\n他にも、日経平均ETFを買って値上がりを待って楽しむという方法もあるが、長期間低迷したらそれもしんどいので今回はパスしよう。",
    "url": "/2008/10/25/2008-10-25-post/"
  },
  {
    "id": "2008-11-08-post",
    "title": "ビル・エヴァンスのpianoの音",
    "date": "2008-11-08",
    "categories": [
      "Jazz"
    ],
    "file_path": "_posts/2008-11-08-post.md",
    "content": "なぜピッチベンド機能の無いpianoで1/4音階が聞こえる気がするのか。\n特にビル・エヴァンスのpianoからそんな音が聞こえる。\n半音違いの鍵盤を同時に押さえているような気もする。メロディーの途中で、時間にすると一瞬だけどキャリーンという感じで重なるタイミングがある。\nクラッシックでいうと、ショパンのpiano曲でも『別れの曲』などでそう聞こえる事がある。ピアニストにもよるのかも知れないけど。\n何かの錯覚を利用しているのかな？\nこのDVDを見ながら、改めて不思議だなあと思った次第。\n絶対マッコイ・タイナーのピアノからはそんな音は聞こえないものなぁ。\nJazzマニアがいたら理由を教えて欲しい今日このごろです。",
    "url": "/2008/11/8/2008-11-08-post/"
  },
  {
    "id": "2008-11-22-post",
    "title": "widen-window.elをインストール",
    "date": "2008-11-22",
    "categories": [
      "Emacs"
    ],
    "file_path": "_posts/2008-11-22-post.md",
    "content": "widen-window.el ver 0.1.0 リリース - 日記を書くはやみずさん\nこれは便利。さっそく使い始めた。\n最近はこういうちょっとしたプログラミングで大きな改善ができるソフトがお気に入り。\n[hayamiz]さんやるねー。\n最近めっきり無くてはならない存在になった anything.elに続くヒット。\n [kiyoka.2008_05_13]Emacs anything.elの応用: よく開くファイルを検索対象にする方法\n [kiyoka.2008_04_23]Emacs anything.el is everything!\nこういう物をすばやく作る能力というのは実はプログラミングのセンスとユーザインタフェースデザインの総合的なスキルが要求される。\nできあがった物を見れば『なあんだ』と思える様なものでもじゃあ自分でも着想出来たかというとそんなことはない。\nそういうものを作れる人になりたいと思う今日このごろ。\n\nコメント by sion:\nこれって アクティブなペインを 自動的に広げる機能でしょうか？\nそれって なんというか、すごく便利そう！\nそういう発想はなかったなぁ～\nしかし、リンク先のムービー・・・あれ、本当にEMacsの画面なの！？\n近頃は みんなあんな複雑なウィンドウ分割してるの！？\n C-x 2 と たまに C-x 3 を使うだけの僕には驚異の使いこなしだ！(^^;\n\nコメント by kiyoka:\nリンク先のムービーは確かにEmacsですね。\nそれから、あの複雑な分割はwiden-windowの挙動がわかるようにするためにわざと複雑な例を見せているだけだと思います。\n私も C-x 2 しか使いませんが、狭いterminalからリモートログインしている時とかには widen-windowは十分便利です。\nコメント by sion:\nこれって アクティブなペインを 自動的に広げる機能でしょうか？\nそれって なんというか、すごく便利そう！\nそういう発想はなかったなぁ～\nしかし、リンク先のムービー・・・あれ、本当にEMacsの画面なの！？\n近頃は みんなあんな複雑なウィンドウ分割してるの！？\n C-x 2 と たまに C-x 3 を使うだけの僕には驚異の使いこなしだ！(^^;",
    "url": "/2008/11/22/2008-11-22-post/"
  },
  {
    "id": "2008-12-07-post",
    "title": "一言要約に挑戦",
    "date": "2008-12-07",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2008-12-07-post.md",
    "content": "一言要約は難しい\n[kiyoka.一言要約]というページでいくつかやってみた。\nWebでいい記事を見つけても、半年もすれば内容を忘れてしまってもういちど読むハメになるが、もういちど読むに値するかどうか短時間で判断したい。\nというわけで、要約を残してみることにした。\nやってみると分かるが、意外と一言(ワンセンテンス)に圧縮するのは難しい。\n要約する際、著者の一番言いたい事を抜きだして他を捨ててしまうというような、かなり乱暴な行為であると思う。\n受験用の国語の試験問題で、『作者がいいたかったことは次の3つの内どれか』という問題がよくあるが、作者に聞いてみたところ3つとも不正解ということが過去にあったそうだ。\n特に、小説なんかだとそういうことは容易に起きることは想像に難くない。\nなので要約する過程で作者の意図する所を外している可能性は十分ある。それでも自分がどう受け取ったかというのが結局自分にとっての正解なのであるからして、これで良いのではないかと思う。\n一度皆さんも挑戦されたし。文章を深く読み込まないと要約できないので理解も深まる様に思う。\nhitokotoyouyaku.comというアイデア\n思いついたが、不特定多数で要約のデキを競いあうhitokotoyouyaku.comとかいうサイトを作るというアイデアもありなのかな？\n要約をするのは人間にしかできないので、いいアイデアのような気もするが、要約はかなりブレインパワーを使う行為なのであまりデータが集まりにくそうなのが問題か。",
    "url": "/2008/12/7/2008-12-07-post/"
  },
  {
    "id": "2008-12-09-post",
    "title": "『小さなインターネット』化に舵を切るmixi",
    "date": "2008-12-09",
    "categories": [
      "mixi"
    ],
    "file_path": "_posts/2008-12-09-post.md",
    "content": "を読んだ後でこのニュース記事 「mixiを小さなインターネットに」　招待制・\"18禁\"廃止の狙いを笠原社長に聞く (1/2) を見ると正しい未来の方向に舵を切ったと感じられる。\n今は昔からの古参ユーザに批判を浴びているが、数年すればあの時のオープン化の判断は正しかったと思えるようになるのではないか。\n何年後かに、ああそういうことだっのねという風に。\nオープン化することのユーザにとってのメリットはせっかくmixiで構築したソーシャルグラフをいろんなサービスにマッピングできるという事だろう。\n例えば、Videoチャットの着信制限などを手っ取り早くmixiのマイミクから設定できるなどが考えられる。\nもしオープン化しなければ、クローズドなSNSの限界と変化の乏しさが見えてどんどんオープンなSNSにユーザに移って行くだろう。\nSNSのユーザが1000万人規模になってくると、本当に舵取りが難しいだろうなと思う。\nmixiの初期から使っている人とユーザ規模が1000万人になってから使い始めた人のmixiに期待することは違うだろうし、もっと細かく言えばヘビーに人脈を広げるためにmixiを使う人と、リアルの知人だけで使うのが基本だと思っている人も期待することは違うだろう。\nこのへんで閉じたSNSからオープンソーシャルのプラットフォームに成ることでmixiユーザはみんなオープンソーシャルの世界に自然な形で移行できる。\n\nほとんどの人が後から見て納得する方向に行くべきだが、だからこそ、今回の舵取りは正しいと思える。\nまずはスタート地点には立ったと思う。\nあとは、ユーザに対して継続的にオープン化のメリットが見える形で提供しつづけて行く必要がある。\n折角のユーザ数を持っているのでなんとかがんばって欲しい。",
    "url": "/2008/12/9/2008-12-09-post/"
  },
  {
    "id": "2008-12-19-post",
    "title": "Jazzとかクラシックを聴いているけど実はミーハーだったりする件",
    "date": "2008-12-19",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2008-12-19-post.md",
    "content": "Jazzとクラシックが好きで、その辺を中心に音楽を聴いているわけだが、ふと振りかえると実は趣味が超ミーハーなんじゃないか、と思いたった。\nJazzとかクラシックを聴くことは人によるとシブイ趣味らいしいのだが、実際はシブくなんかない。\nJazzを聴きはじめたきっかけからして、Stingだし、クラシックといっても、ショパンとラフマニノフが好きだったり。\n最初、Stingのバンドメンバーがあまりに上手いのはどうしてだろうと不思議に思って調べてみると、StingがなぜかJazzミュージシャンで固めていて、じゃあそのJazzもいっぺん聴いてみるかということで、まずは手始めにStingのメンバーのブランフォード・マルサリス(sax)のアルバムから手に入れた。\n都合の良いことに同じStingのバンドメンバーのケニー・カークランド(piano)もアルバムに入っているということで話が早かった。\nそんな感じでサックス奏者をリーダーにしたアルバムをいくつか聴いていると当然ながら、ソニー・ロリンズやジョン・コルトレーンに行きつくわけだ。\nそして、コルトレーンまで行くと当然マイルス・デイビスまで到達する。\n別の方向から、坂本竜一の映画のサウンド・トラックを聴いているうちにピアノトリオにも興味が出てきてビル・エヴァンスという終着駅に辿りつく。そしてついでにキースジャレットという感じ。\n最近ではのだめ カンタービレ経由でラフマニノフ最高という感じになってしまった... 何という軟弱、ミーハーな。\n結局自分が好きなミュージシャン(作曲家)はビル・エヴァンス、キース・ジャレット、ショパン、ラフマニノフとかになるかな。\nというわけで、Jazzとかクラシックを聴いているからといって一概にシブイとか硬派とか言うわけではないよということ。\nそこんとこ気を付けるように。\n今思いつくベストだと思うCDを並べておこう。",
    "url": "/2008/12/19/2008-12-19-post/"
  },
  {
    "id": "2008-12-25-post",
    "title": "Emacs 23をビルドしてみた。shell-modeの挙動が21と同じに戻った。",
    "date": "2008-12-25",
    "categories": [
      "Emacs"
    ],
    "file_path": "_posts/2008-12-25-post.md",
    "content": "久々にEmacsネタを。\n普段からよく使っている、shell-modeの挙動がEmacs 21時代に戻っている。\n個人的にはこれだけでもEmacs 23を使う意味がある。\nEmacs 22では shell-mode中でコマンドを実行した場合、コマンドが出力した文字列は通常のテキストとは違う扱いになっていた。\n例えば、次の様な一連の連携プレーはEmacs 22で出来なくなった。\nまず、次のコマンドを実行する。\n % find . -type d\n ./dir_A\n ./dir_B\n ./dir_C\n\n次にfind コマンドが出力した ./dir_B の部分の先頭に 'cd 'を追加して\n cd ./dir_B *return*\n\nと入力した場合、Emacs 21では、cd ./dir_B が実行される。これは素直な動作だと思う。\nそれがEmacs 22では空振りする。(プログラムが出力したテキストは保護されているおり、プロンプトの直後だけをコマンドと認識するようだ)\nこれが、Emacs 23では Emacs21と同じ挙動に戻されている。\nこれはかなり嬉しい。\nEmacsユーザのみんなはどう思っているんだろう。誰かのクレームがあって戻ったんだろうか。",
    "url": "/2008/12/25/2008-12-25-post/"
  },
  {
    "id": "2009-01-18-post",
    "title": "遊びという投資",
    "date": "2009-01-18",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2009-01-18-post.md",
    "content": "共感する。これは最近思うところなんだよねぇ。\nはてブコメントでは別の部分に対するコメントが多いけど。\n 小野和俊のブログ:IT企業の経営者として、不景気だとしても守り続けたいこと\n 3.「遊び」の部分を必ず残す\n これはこの半年ほどの反省点でもあるのだが、昨年夏から年末くらいにかけて、\n 開発チーム全体がリリースの関係で忙しく、それまで週に一度開催していた勉\n 強会をしばらく延期してしまっていた。\n 目の前にある、すぐに取りかかる必要のある仕事に対して優先的に対処するの\n は良いとして、どんな忙しい状況でも、週に一度の勉強会とか、今までと違う\n やり方を検討してみるとか、新しいバージョンの開発環境を試してみるとか、\n 仕事と直接関係ない開発や研究の成果を発表する場所を用意するとか、中長期\n のプロジェクトへに取り組むとか、忙しい時や、不景気の時こそ、こうした\n 「遊び」の部分を意識的に日常の仕事の中に組み入れていく必要があると思う。\n経済状況が逼迫すると、投資に及び腰になり抑制してしまう。\n特に、仕事に直接関係無いことをウォッチしていくというのはなかなか難しい。\nじゃあどうやればいいのか。\nやっぱり基本はプライベートな時間を使うしか無いのかなと思う。(セルフパトロンシステムとか言うらしい)\nじゃあ、プライベートな時間が無かったらどうするか。育児とか家事とか大変。\n今、私の悩みはそこなんだけど。\n数年間は仕方ないかなと思っている。",
    "url": "/2009/1/18/2009-01-18-post/"
  },
  {
    "id": "2009-02-02-post",
    "title": "『クラウド化する世界』を読んだ",
    "date": "2009-02-02",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-02-02-post.md",
    "content": "最近のGoogleとかMicrosoftとかAmazonのクラウドの未来が知りたくて読んでみた。\n実は、具体的なGoogle App EngineとかAmazon S3の話題に触れられているのかと思ったが、もっと全体の大きな流れを鋭く捕えていて良い意味で裏切られた。\n(要約は[kiyoka.一言要約]に書いたので内容に興味がある人はそちらも見ておいてもらえれば嬉しい)\n間違いなく未来はクラウドコンピューティングの方に行くことは間違いないと納得させてくれる本だ。\n将来は自宅のパソコンだろうと企業の基幹システムだろうと自分でアプリケーションを入れて管理するのは少数派になっていくだろう。\n現在NetBookとかミニノートが売れているのは、単に安価だからかも知れないが、今後はパソコンはセットアップがめんどくさいからイヤだというように、別の理由で敬遠される様になると思う。\n企業内での増えつづけるサーバ管理についてもしかり。\nそうなると、ソフトウェアの開発者もクラウド上で何をどう作るかというのを考え始めた方がいいと思う。\n漠然とクラウドコンピューティングが流行りそうだから、ちょっと技術的なところを押さえておこうという人は並行してこの本も読んでおくといいでしょう。\n長期的な視野とデータセンターが遠い国にあるということはどういうリスクが有るかというような、時間軸方向と空間軸方向の両面で広い視野で世界を俯瞰させてくれる。\nでも、この点だけはちょっと納得いってない。本当にそんな事になるのかな。\n [kiyoka]による要約。\n 『ワールドワイドコンピュータにより知識労働が世界規模で取引される。その\n 結果、経済の地域格差は小さくなるどころか、コンピュータ化により知識労働\n を自動化できる特に才能のある裕福な少数の人々と、それ以外の大多数の人々\n の間で格差が広がるだろう』\nこれからは、Amazon DynamoとかWindows SDSとかについて書かれた記事とかを読んでいく予定。",
    "url": "/2009/2/2/2009-02-02-post/"
  },
  {
    "id": "2009-02-06-post",
    "title": "コマンドラインを投稿するサイト [Command-line Fu](http://www.commandlinefu.com/commands/browse) を発見",
    "date": "2009-02-06",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2009-02-06-post.md",
    "content": "一行野郎を集めるサイト。\nRedditみたいに投稿したコマンドラインをみんなで評価しあえるようだ。\n Command-line Fu &lt; The best UNIX commands on the web\n Command-Line-Fu is the place to record those command-line gems that\n you return to again and again.\n私がよく使うコマンドライン(未投稿)\n\nファイルを検索してそれぞれのmd5ハッシュ値を求める\n\n find . -type f -exec md5sum {} ';'\n\nターミナルが文字化けするとき、英語メッセージに切りかえる\n\n unset LANG\n\n私がよく使うコマンドライン(やっぱり投稿されていた)\n\n.svn ディレクトリを検索して削除する\n\n find . -type d -name '.svn' -print0 | xargs -0 rm -rdf\n\ngrepがヒットするファイル名をリストアップ\n\n find /path/to/dir -type f -exec grep \\-H &quot;search term&quot; {} \\;\n\nなるほどと思ったもの\n\n直前のコマンドをsudoする\n\n sudo !!\n\n2つのファイルをその場でソートしてdiffする\n\n diff &lt;(sort file1) &lt;(sort file2)\n\nカレントディレクトリを変更せずに他の場所でコマンド実行する\n\n (cd /tmp &amp;&amp; ls)\n\nランダムな文字列(非バイナリ)を表示する\n\ntr -dc '*:print:*' &lt; /dev/urandom\n\n結局のところ、覚えやすい程度に短く、かつ強力なコマンドラインが実用的だと思う。\n自分では思いつかなかったフレーズを仕入れるのにいいサイトだ。\n早速このサイトをRSSリーダーに登録したよ。\n\nコメント by sion:\nfind /path/to/dir -type f -exec grep -H \"search term\" {} \\;\nは しょっちゅう使ってますね。\nfind は凝りだすとかなり色々できるから、スクリプト書けばいいのに\n無理に find でがんばろうとしてしまったりする(笑)\n\nコメント by kiyoka:\nそうですね。\nfindは応用範囲が広いので下手に専用スクリプトをたくさん用意するより、\nその場その場でfindプラス -exec オプションや xargs を組み合わせるほうが柔軟性が高い気がします。\nスクリプトを準備していっても意外と帯に短し襷に長しで使えなかったりしますよね。\nfind と xargs の組み合わせは 関数型プログラミング言語でいうことろの高階関数(higher order function)だと思っています。\n再利用性が非常に高い理由はそういうところかなと思います。\nもっと凝った find コマンドが欲しいと思う時もありますが、それを作るのは暗黒面への入り口なのでやめています（笑）\nコメント by sion:\nfind /path/to/dir -type f -exec grep -H \"search term\" {} \\;\nは しょっちゅう使ってますね。\nfind は凝りだすとかなり色々できるから、スクリプト書けばいいのに\n無理に find でがんばろうとしてしまったりする(笑)",
    "url": "/2009/2/6/2009-02-06-post/"
  },
  {
    "id": "2009-02-08-post",
    "title": "セルフパトロンシステムの限界",
    "date": "2009-02-08",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2009-02-08-post.md",
    "content": "ノンプログラミングでWebアプリを作るシステムについて調べている。\n (参照:[kiyoka.調査.簡易Webアプリ作成ツール])\nその中でTuigwaaというオープンソースプロジェクトを見つけた。\n過去にIPAの未踏プロジェクトにも採択されており、可能性があるのかなと思ったのも束の間、Tuigwaaのサイトには開発終了宣言が出ていた。\n 2008/08/18 重要なお知らせ\n WebUDA Tuigwaa プロジェクトは、新機能開発を停止することとなりました。\n開発終了宣言をするオープンソースプロジェクトは珍しいので、もうちょっとだけ調べてみた。\n結果、こんな記事に辿りついた。\n 株式会社スターロジックの羽生章洋が書いてるブログ:ボランティア - livedoor Blog（ブログ）\n 実は今年の3月にTuigwaaの開発メンバーの皆さんが所属していた会社さんが\n なくなってしまいました。正確には関連会社さんに吸収されて事業の取捨選択\n がなされたということです。何はともあれ、一社に集まって会社の日常的な支\n 援を受けて頑張っていたTuigwaaチームの皆さんは散り散りばらばらになって\n しまいました。今でも最小限のサポートなどは継続してくれていますが、それ\n ぞれが別に新しい道へと進み始めたところですから以前のようにパワフルには\n 活動できません。まずは自分の人生を支えられるようになるところからだから\n です。\n OSSというのは一般的にはまだまだボランティア活動というのが大半です。\n Buriは会社の心臓部ですからBuriの開発者には相当量をBuriに割いてもOKとし\n ていますが、100%ではありません（というかBuriを中心にした周辺もやってい\n るので、Buriそのものだけに専念しているわけではありません）。ほとんどの\n 方の場合、OSS活動というのはNightly Workと呼ばれる状態であるのはいかんと\n もしがたい事実です。\n今後経済情勢が悪くなってくると組織として活動しているオープンソースプロジェクトでは同様の話がチラホラ出てくるんじゃないかと思う。\nこのあたりの話は、プライベートな時間を使ってオープンソースプロジェクトをいろいろやってきたので考えさせられる。\n最近は子供が生まれたので、新しいことを思いついても構想はするけれどもさすがに手を付けることができなくなってきて、活動は停滞気味。\nやっぱりプライベートな時間が有るか無いかは大きい。\n昼間の仕事で生活基盤を作って、夜に自分で発案したプロジェクトに投資するという仕組みから来る限界か。\n(そういえば、\nそんなこともあって、着手するプロジェクトはプロダクト自体が直接キャッシュを生む起業的なものを避け、自分のスキルアップに寄与したり、間接的に自分の今後に付加価値が付くようなものを指向することになる。\n作る過程でSchemeのような高い抽象化能力が求められる言語を使えば、平均的なプログラミング言語では得られない高度な概念を扱えるようになる。\nまた、作ったものがプロダクトとして商品レベルになっていなくても、コンセプトが斬新だったり、多少なりとも世の中の為になるものであれば、勉強会なんかで名刺代わりになってくれ、自分を覚えてもらいやすい。\n実際に[Sumibi.org]の例にとると、オープンソースコミュニティー方面では仮名漢字変換エンジンを開発されている方々から内容の濃いイベントに誘って頂けたり、海外の留学先から実際に利用して頂いている方々からは感謝のメールを沢山頂いたり、Web関連企業の方からはサーバを寄付して頂いたりSumibi Web APIを掲載いただいた書籍を献本頂いたりした。\nしかし、そんな活動もプライベートな時間が確保できてこそ。\nそれは、セルフパトロンシステムの限界だと思う。\n結論めいたことは書けないけど、短期的にはしんどいだろうけど、長期的に見ればセルフパトロンシステムは崩壊はしないと思うのでどういうプロジェクトをやるにしても、気長に続けるしか無いんじゃないかと思う。他人から決められた期限なんかないんだから。\n\nコメント by mogya:\n今日はどうもでしたー。古川です。\nなんだかオープンソースやlinuxにコミットしている人が社内にいると聞いていたものの、あんまりそういう話をする機会なく会社を辞めちゃって、まさかこんな形で再開するとは思わなかったので、挙動不審だったら失礼しました。\nセルフパトロン、興味深い話ですね。会社をやめて、自分プロジェクトにつっこめる時間は大幅に増えたのですが、思っていたほどアウトプットは増えなくて、なかなか難しいな、と感じています。\n次に会った時はこういう話が出来るといいですね。\n\nコメント by kiyoka:\n昨日はどうもでした。\n古川さんのような方が会社にいらっしゃったとは思いませんでした。\n昨日はメインの話題が別のところにあったので、あまりお話できませんでしたが、次の機会にはいろいろお話聞かせてほしいです。\n個人で仕事をされていて良い面、悪い面など詳しく知りたいです。\n今後ともよろしくお願いします。\nコメント by mogya:\n今日はどうもでしたー。古川です。\nなんだかオープンソースやlinuxにコミットしている人が社内にいると聞いていたものの、あんまりそういう話をする機会なく会社を辞めちゃって、まさかこんな形で再開するとは思わなかったので、挙動不審だったら失礼しました。\nセルフパトロン、興味深い話ですね。会社をやめて、自分プロジェクトにつっこめる時間は大幅に増えたのですが、思っていたほどアウトプットは増えなくて、なかなか難しいな、と感じています。\n次に会った時はこういう話が出来るといいですね。",
    "url": "/2009/2/8/2009-02-08-post/"
  },
  {
    "id": "2009-02-11-post",
    "title": "日本のIT業界の未来は暗い。ならば個人として準備できることは？",
    "date": "2009-02-11",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-02-11-post.md",
    "content": "簡単に感想を書きたいと思う。\n本を読まなくてもネットで前々から議論のまとになっているので、わかっている事ではあるが、明らかに日本のIT産業の未来は暗いという論調はどの本にも共通している。\n- IT産業の問題点を列挙すると...\n建設業界のような多重請負構造\nユーザ企業がSIerに丸投げ(ユーザ企業にITの専門家がいない)\nユーザ企業がパッケージに業務フローを合わせることをしない\nカスタマイズするほどSIerの売上が上がる構造\nSIerの教育投資の問題\n人月見積からくるSIerの低い利益率\nどれも、聞いたことある話ばかりだ。\nまあ、自分もこの業界に身を置いているので、何らかの準備をしないといけないなと思う次第。\n今回の金融危機でユーザ企業はIT投資の予算が減る為、スタッフ部門が使うシステムなど、他社との差別化要因に成らない部分は真っ先にオーダーメイドはやめ、海外のパッケージ製品を使ったりSaaSの利用に流れたりするだろう。\n要するに、何も特徴の無い業者は生き残れない可能性が高い。うわわわ。\nさてどうすべきか。\nこの本も図書館で借りて読んだら、未来はどっちの方向に向かうのかを教えてくれた。\nトフラーがいうのなら間違いないだろう。たぶん(^_^;)。\nまた、これまでただの消費者だったものが生産消費者となり、専門家に任せていたものを消費者が自分で生産(DIY)する傾向が強まるだろうということだ。\n特に、デジタルの世界では自宅で自分の写真をプリントアウトしたり、自分でビデオ編集したりする傾向が強まる。\nこれは、個人だけでなく、企業や役所でも同じ。\n 参考:見積もり2億円のIP電話を820万円で構築した秋田県大館市から学べること：ITpro\nそんなわけで、IT業界がどうとか言う前に自分個人でできることは無いか考えはじめてみたり。\n先日[kiyoka.2009_02_08]で書いた様に、『プログラミングなしでWebアプリを作るツール』のような方向が今後普及するんじゃないかと思って調査しはじめた。\n (参照:[kiyoka.調査.簡易Webアプリ作成ツール])\n一応自分の使ってみたい(かつ 作ってみたい)サービスのイメージはあるのだが、それに近いサービスは無さそうだ。\nかなり未踏性が高いので未踏に応募しようかな。\nまあ良いプロダクトは最初のアイデアが良いかではなく紆余曲折の末に良いものに持っていく実装能力と実行力の方が大事なので、未踏に応募した後が問題なんだけど。\n 参考: simoom's nest:ベンチャービジネスのためのアイディア(Ideas for Startupsの翻訳)\n 本当のことを言えば、ほとんどの新興企業は初期のアイディアとは似ても似\n つかないことを結局行っているんだ。こんな風に言う方が真実に近いんじゃな\n いかと思う。つまり、初期のアイディアの主要な価値というのは、それがダメ\n になるのに気づく過程で、本当のアイディアを思いつくことにあるんだ、とい\n うように。\nダメかどうかをプロトタイプを作ってみる、という段階はやって損は無いかも。",
    "url": "/2009/2/11/2009-02-11-post/"
  },
  {
    "id": "2009-02-20-post",
    "title": "いつのまにか Debian 5.0 がリリースされていた",
    "date": "2009-02-20",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2009-02-20-post.md",
    "content": "Debian GNU/Linux 5.0 \"Lenny\" リリース!!!\n 以前のリリースから約２年近くを経て、Debian GNU/Linux 5.0 コードネーム\n “Lenny” が 2009/02/14、ついにリリースされました\n\n今 Debian GNU/Linux 4.0を使っているが、特に4.0に不満が無かったので気がついたら次の5.0がリリースされていたという感じ。\nWindows XPユーザにも言えることだと思うが、どのOSもこれ以上のバージョンアップはあまり重要ではない気がしてきた。\nソフトウェア開発はWebアプリケーションにシフトしているし、OSやサーバマシンは自分で管理するよりは、Amazon EC2の様に誰かに管理してもらった方がラクだと思うようになってきた。\nもし、Amazon EC2がもっと安くなったら契約しようと思っているのは自分だけではないと思う。\nもっとも、Amazon EC2上で動かすOSは Debian GNU/Linux 5.0 \"Lenny\" を使うだろうけど。\nそれまでは差し迫ってバージョンを上げない可能性が高い。\n\nコメント by Alfredo:\nYour weibste has to be the electronic Swiss army knife for this topic.",
    "url": "/2009/2/20/2009-02-20-post/"
  },
  {
    "id": "2009-02-22-post",
    "title": "Key-Value Store勉強会に行きたかった...",
    "date": "2009-02-22",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2009-02-22-post.md",
    "content": "Key-Value Store勉強会に行ってきました - blog.katsuma.tv\n greeさんで開催されたKey Value Store勉強会に行ってきました。時間にして\n 4時間超え、内容も国内のKey-Value Storeなソフトウェアの最前線の話ばかり\n で相当なボリューム。以下、メモってたのを残しておきたいと思います。\nそれにしても、このメモすごい情報量。\n自分の興味としては、Key-Valueストレージエンジンの実装よりも、Key-Valueのデータベースの応用事例の方にある。\nリレーショナルDBなら事例は山ほどあり、論理設計、物理設計ともに設計手法も確立している。\nKey-Valueの場合はどんな分野で使えるんだろう。\n例えば、[Sumibi.org]をTokyoCabinetベースで作るとなると、どんな設計になるのかなとか。\nもしかしたら、いまMySQLにメモリ3GByteも割当てているけどTokyoCabinetなら圧縮がかかってメモリ節約出来るんだろうかとか。\nはたまた、一般的なCRMをKey-Valueで作るとどんな点に気を付けないといけないのかとか。そもそも、そういう分野には向いていないのではないかとか。\nたぶん将来はAmazonのインフラ上で作品を作りたいと思っているので、この辺勉強しないといけないなと思っていた所。\n作品を作る時は、[Kahua]のObject DBをAmazon S3とかDynamo対応する方向なのかなと漠然と思っているけど、もっと勉強すると各エンジンのトレードオフとかも肌で分かるようになるのかな。\nKVS 勉強会に出て、自分でも書いてみたいなと思ったり。 - 生駒日記\n かな漢字変換的にはやはり key-value store (hash 的なもの)ではなく Trie\n があるといい(common prefix search が使えると検索効率がよい)のだが、やっ\n ぱり自分で1回は書いておいたほうがいいのだろうなー、と思った。いつになる\n か分からないけど……。\nid:mamorukさんも書いておられるように『自分で1回は書いておいたほうがいいのだろうなー』という気持もあるけど、自分はWebアプリケーションを作るほうに時間を使いたいのでちょっとそこまで時間はかけられないかなと思ったりもする。\nちょっと自分はRDBとSQL脳に傾いているのでもっと引出しを増やす意味でもいろいろ見ておこう。\n追記:Key-Value Store勉強会については首藤さん所が、リンクが沢山で便利。\n Shudo's Notes (2009/2)",
    "url": "/2009/2/22/2009-02-22-post/"
  },
  {
    "id": "2009-02-28-post",
    "title": "そろそろオレ言語でもやっておくか(5)",
    "date": "2009-02-28",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-02-28-post.md",
    "content": "過去の記事の続き\n [kiyoka.2008_09_23]言語 そろそろオレ言語でもやっておくか(4)\n [kiyoka.2008_09_03]言語 そろそろオレ言語でもやっておくか(3)\n [kiyoka.2008_08_31]言語 そろそろオレ言語でもやっておくか(2)\n [kiyoka.2008_08_09]言語 そろそろオレ言語でもやっておくか(1)\nLispのS式に対する不満が昔から有るが解決が難しいという話。\nAlgol系の文法でラップしてしまえば、S式を直接使わずにS式のパワーが引きだせるのでは無いかと考える人は多いと思う。\n過去にもトライしようとして失敗した人が多数。死屍累々。\nでも、イバラの道に挑むバカ(良い意味でのバカ)がもっといてもいいじゃないかとも思う。\nで、自分はどうなんだ、トライする気はあるのかと言われると、ちょっと及び腰であった。\nそんな中、Shibuya Lispの発表をニコニコで見ていたらこんな発表を見つけてしまった。(リンク:Shibuya.lisp テクニカルトーク #1 ニコニコ動画にて動画公開!)\nイバラの道を進んで最後には、実際の業務に適用してしまった人。\nこれは凄い。\n ##(nicovideo sm5048241)\nこういう活動は表には出てこないけど絶対にどこかで繰返されていると感じた。\n他にもこんなアプローチも。\n ##(nicovideo sm5103172)\nyuumi3だ。実際に動く所を見るとこのアプローチもありかなと思う。\nどんなものになるのか楽しみだなあ。。\n 参考:yuumi3のブログ記事\n (S-Expression for Ruby) ファンクション倶楽部2008秋イベント LT - yuum3のお仕事日記\n S-Expression for Ruby 解説 - yuum3のお仕事日記",
    "url": "/2009/2/28/2009-02-28-post/"
  },
  {
    "id": "2009-03-20-post",
    "title": "そろそろオレ言語でもやっておくか(6)",
    "date": "2009-03-20",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-03-20-post.md",
    "content": "Cyan作った人\nCyanを設計した高校生、5カ月で5つの言語を習得\n 読者の皆さんは、「Cyan」（サイアン）という言語をご存じないかもしれない。\n Cyanは、Lispのマクロを持ち、Python風のインデントによってブロックを表す\n プログラミング言語。2008年の春、林拓人という1人の高校生によって設計さ\n れた。\nこのあいだのShibuya.Lispテクニカルトーク#2のビデオも貼っておく。\n Cyanの現状と、これから\nすごすぎる。\nものすごいフットワークの軽さ。見習うべき。\nこんな風に軽やかに新しい言語を設計できたらいいんだけど...\n自分も作ろうと思い立つ\nと感心しているいちに、自分もやってみようと思いついた。もっと気楽に考えればいい。\n目標は次のShibuya.Lispのライトニング・トークでしゃべるくらいの気軽さで行こう。\n結局いろいろ考えた結果、RubyでLispインタプリタを作ることにした。\nLispの糖衣構文としてRubyっぽいものをいちから実装するよりは、RubyでLispインタプリタを実装して融合させた方が、自分のイメージに近いものができることに気がついた。\n要するに前からぼんやり考えていた自分の欲しいものがやっと発見できたということ。\n自分のほしいものが分からないなんて、人間って面白い。\n(だから、人のソフトウェアやサービスを発見して、あっそうそう、こんなものが欲しかったんだ。なんで思いつかなかったんだ... という風なことがよく起きるんだと思う)\n実は、自分が本当はRubyライクなインタプリタを作りたかったわけではなく、Ruby的なAlgol系言語とS式を混在してプログラミングができたらどんな感じだろうというのが知りたいだけだったのだ。\n今は簡単な式がevalできるレベル。\n関数定義ができる位のレベルになったら、紹介しようと思う。\n 近くのカフェで集中してプログラミングしてるところ",
    "url": "/2009/3/20/2009-03-20-post/"
  },
  {
    "id": "2009-03-21-post",
    "title": "Rubyのよくわからない挙動(1)",
    "date": "2009-03-21",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2009-03-21-post.md",
    "content": "===メソッド(比較演算子)の挙動がよくわからない。\nクラス A を定義し、インスタンスを a に代入する。\n$ irb\n&gt;&gt; class A ; end\nclass A ; end\n=&gt; nil\n&gt;&gt; a = A.new\na = A.new\n=&gt; #\n\n== がtrueになるのはわかる。\n&gt;&gt; a.class == A\na.class == A\n=&gt; true\n\n=== では何故falseになるのか。\n&gt;&gt; a.class === A\na.class === A\n=&gt; false\n\n=== がtrueになってくれないと === 演算子が適用される case 〜 when が使えない。\n例えば、\n case val.class\n when Cell\n Cell型の場合の処理\n when Fixnum\n Fixnum型の場合の処理\n end\n\nという記述はダメ。どれにもマッチしない。\nこう書けばいけるけど、ちょっと苦しい。\n case val.class.to_s\n when &quot;Cell&quot;\n Cell型の場合の処理\n when &quot;Fixnum&quot;\n Fixnum型の場合の処理\n end\n\nこんな場合Rubyの定石として、どう書くんだろう。\n\nコメント by Grape:\n勉強し始めたばかりなので、まだ何とも言えませんが、\nRubyの===は、「サブクラスで適宜再定義される」とあるので、オブジェクトによって挙動が違う可能性があります。\nつまり、実装によっては必ずしも型が同じで値が同じ時にTrueという動きではないかもしれません。\n的外れな答えでしたら、すみませんorz\n\nコメント by mogya:\n＞こんな場合Rubyの定石として、どう書くんだろう。\nこうらしいです。\n case val\n when Cell\n Cell型の場合の処理\n when Fixnum\n Fixnum型の場合の処理\n end\n[ruby-list:10473]case with Class からはじまる一連のスレッドに書いてありました。\nhttp://blade.nagaokaut.ac.jp/cgi-bin/vframe.rb/ruby/ruby-list/10473?10428-11968\n\nコメント by kiyoka:\nGrapeさん、mogyaさん、コメントどうもです。\nmogyaさんに教えてもらった方法でいけそうです。\n内部の仕組みはよくわかりませんが、これで短く書けますね。(そのへんがRubyに対して好みがわかれるところでしょうが...)\n以下、実験結果です。\nirb(main):001:0&gt; class A ; end\n=&gt; nil\nirb(main):002:0&gt; a = A.new\n=&gt; #\nirb(main):003:0&gt; case a\nirb(main):004:1&gt; when A\nirb(main):005:1&gt; 1\nirb(main):006:1&gt; when B\nirb(main):007:1&gt; 2\nirb(main):008:1&gt; else \nirb(main):009:1* 3\nirb(main):010:1&gt; end\n=&gt; 1\n今作っているLispインタプリタをこのスタイルに直しておきますです。\nコメント by Grape:\n勉強し始めたばかりなので、まだ何とも言えませんが、\nRubyの===は、「サブクラスで適宜再定義される」とあるので、オブジェクトによって挙動が違う可能性があります。\nつまり、実装によっては必ずしも型が同じで値が同じ時にTrueという動きではないかもしれません。\n的外れな答えでしたら、すみませんorz\nコメント by mogya:\n＞こんな場合Rubyの定石として、どう書くんだろう。\nこうらしいです。\n case val\n when Cell\n Cell型の場合の処理\n when Fixnum\n Fixnum型の場合の処理\n end\n[ruby-list:10473]case with Class からはじまる一連のスレッドに書いてありました。\nhttp://blade.nagaokaut.ac.jp/cgi-bin/vframe.rb/ruby/ruby-list/10473?10428-11968",
    "url": "/2009/3/21/2009-03-21-post/"
  },
  {
    "id": "2009-03-25-post",
    "title": "そろそろオレ言語でもやっておくか(7)",
    "date": "2009-03-25",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-03-25-post.md",
    "content": "RubyでLisp系言語処理系を作りはじめた\n現段階でRubyのコードで大体500行くらい。\nRedLispという名前にした。Googleで検索したところ、同じ名前のものは無かったのでこれにした。RedはRubyが赤いから。ナント安易な...\n赤色というのは、プレゼンの時にシャア専用とか何とかいえばネタにしやすいという狙いもある(笑)\n\nこんな変な動きをするのだ\nbash-3.2$ ./redlisp \n&gt; (car '(a b c))\na \n&gt; (cdr '(a b c))\n(b c )\n&gt; (+ 1 2 (+ 3 4 )) \n10 \n&gt; +\n# \n&gt; 123\n123 \n&gt; &quot;123&quot;\n&quot;123&quot;\n&gt; (+ &quot;123&quot; &quot;456&quot;)\n&quot;123456&quot;\n&gt; (sprintf &quot;%02X&quot; (car '(15 16)))\n&quot;0F&quot;\n&gt; (cons 1 2)\n(1 . 2)\n&gt; (cons 1 '(2 3 4))\n(1 2 3 4 )\n&gt; (exit 1)\n\nで、結局なにを作りたいの？\nS式でRubyプログラミングができたらどんな感じかを一度体験してみたいというのが作り始めた動機だ。\nS式のどこの節を千切って、あっちへ接木してというような柔軟なプログラミング体験はRubyではできない。\nRubyの良い面も有るのでRubyのコードと混在できるようにするつもり。\nなので、ユーザインタフェース的な実験がメインになる。ということで、実用言語としてのパフォーマンスとかはあまり興味がないの。\nS式でプログラミングをするのは好きなんだけど、例えばTokyoCabinetみたいな最近話題のDBでちょっと使って遊んでみたいというような場合には、Rubyのようにバインディングが量産されてくる言語にのっかるのが楽という事情もある。\nとりあえず直近の目標は、Shibuya.LispでLTをすることなので、ソレナリに面白い話やデモができるように考えていこうと思う。",
    "url": "/2009/3/25/2009-03-25-post/"
  },
  {
    "id": "2009-03-30-post",
    "title": "そろそろオレ言語でもやっておくか(8)",
    "date": "2009-03-30",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-03-30-post.md",
    "content": "Rubyで書いたLisp処理系の RedLisp 開発の続き。\nlambdaとifの二つのスペシャルフォームを実装した結果、fact(階乗計算)関数が動くようになった。\n$ ./redlisp\nredlisp&gt; (def fact\n (lambda (n)\n (if (= n 1)\n 1\n (* n (fact (- n 1))))))\n rubyExp=&gt;&gt;\n# \nredlisp&gt; (fact 10)\n rubyExp=&gt;&gt;\n3628800\nredlisp&gt; (fact 20)\n rubyExp=&gt;&gt;\n2432902008176640000\nredlisp&gt; \n\nRedLispは、まだ実験段階なので、構文エラーなどの例外処理は真面目にやっていない。\nしかし、内部でS式をRubyに動的にトランスレートしてはevalするという方式を取ること自体は間違いでは無さそうという感触は得た。\n\nさて、次はどんな実験をしようかな。\nlet let* の実装をやってみて、Rubyのレキシカルスコープがそのまま利用できるかの確認と、map等の高階関数をどうやって実装するか等の検討かな。\nその後はRubyのクラスライブラリをどうやって呼び出すかあたりが課題となるだろう。\nFile#openとかはブロックを渡す場合と渡さない場合があるが、そういうのをどうやって呼び出し方変えるかなど考えないといけない事が控えている。\nというか、RedLispはそういう思考実験を繰返しながら、言語デザインをするのが目的だったので、早くそのレベルまでいきたいな。",
    "url": "/2009/3/30/2009-03-30-post/"
  },
  {
    "id": "2009-04-01-post",
    "title": "そろそろオレ言語でもやっておくか(9)",
    "date": "2009-04-01",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-04-01-post.md",
    "content": "オレ言語にRedLispという名前をつけたのだけど...\nなんと、redlispは既にあった！ 名前がカブっていたのだ。\n先日Google検索した時は、『日本語のページを検索』のラジオボタンにチェックが入っていたという初歩的な失敗をした。\nGoogleで検索しておけばグローバルに検索されるので間違い無いと思い込んでいた。思い込みとは怖い。\n気をとりなおして別の名前にすることにしたぞ。\n候補は子供のころから粘土細工が好きだったこと、S式でプログラミングをしている時の自分の心理状態が粘土でコネコネしているのと似ているような気がしているので、『粘土』というキーワードをどこかに入れたい。\nそのまま粘土(nendo)にするのもありかな。候補は、\n nendo\n craylang\n rubycray\n rcray\nもちろんnendoというSNSが存在することも、nendoというデザイン会社が存在することもnendo.orgというドメインがあることも知っている。(そんでもって、TMにはなってなさそう)\nでも、プログラミング言語でカブなければよしとするしかない。\nプログラミング言語の名前としてはArcとかIoというような短い名前は沢山ある。カブることを気にしていたら切りがないのだ。",
    "url": "/2009/4/1/2009-04-01-post/"
  },
  {
    "id": "2009-04-02-post",
    "title": "RedLisp改めNendo",
    "date": "2009-04-02",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-04-02-post.md",
    "content": "昨日書いた通り、なんとredlispは既にあった！ということで、Nendoという名前に変更した。\n[CodeRepos]の中で何度もディレクトリ名変えてすみません。\nやっぱりプロジェクトの最初の方ではこういうドタバタは何度もある。\n[CodeRepos]に入れるのはもうちょっと先にしたほうが良かったかな...",
    "url": "/2009/4/2/2009-04-02-post/"
  },
  {
    "id": "2009-04-07-post",
    "title": "そろそろオレ言語でもやっておくか(10)",
    "date": "2009-04-07",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-04-07-post.md",
    "content": "nendoにlet構文を追加しようとして、ふと立ち止まる。\n先にquasiquoteを実装して、その構文の上にletを構築するか、それともletを素直にRubyで書いたevaluatorで実装するか。\nまずは段階的にRubyで書いてみようかな。\n書いては捨て、捨てては書いてというのを繰返していきながら、一番いいやりかたを探していこうと思う。",
    "url": "/2009/4/7/2009-04-07-post/"
  },
  {
    "id": "2009-04-08-post",
    "title": "Rubyがいろんなプラットフォームに広がっている件",
    "date": "2009-04-08",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-04-08-post.md",
    "content": "独SAP、自社VMでRuby処理系のサポート追加へ/@IT\n 独SAPは3月27日、同社のWebアプリケーションサーバで動くRubyの実験実装\n 「Blue Rubyプロジェクト」について明らかにしている。ABAP（Advanced\n Business Application Programming）は、独SAPが提供するWebアプリケーショ\n ンサーバ「SAP NetWeaver Application Server」は、J2EEと独自言語ABAPによ\n るアプリケーション開発が可能なVMを備えている。\n\nIronRubyやJRuby以外にもどんどん使える環境が広がっている。\nMacRubyもLLVM化したりして、高速化競争も始まっており、Rubyプラットフォームの普及は最終段階に来ているのかも。\n JRuby 50倍速、MacRubyはすでに到達域 - 竹内関数 | エンタープライズ | マイコミジャーナル \n今開発しているおもちゃ言語のNendoもいろんな場所で動くと思うと楽しみになってくる。\nあとは、Google App EngineでRubyが使える様になると色々遊べそうだ。Googleはいつ対応するのかなぁ。",
    "url": "/2009/4/8/2009-04-08-post/"
  },
  {
    "id": "2009-04-10-post",
    "title": "そろそろオレ言語でもやっておくか(11)",
    "date": "2009-04-10",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-04-10-post.md",
    "content": "このClojureのtutorialが非常に参考になる。本家のドキュメントではないけどたいへん分かりやすい。\n Clojure Tutorial For the Non-Lisp Programmer | Moxley Stratton\nClojureがJavaのClassライブラリをアクセスする構文を持っている。\n対して、NendoはRubyのClassライブラリをアクセスする必要があるので、言語仕様を考える上でClojureの例は大変参考になる。\n例えばこれは参考になる。\n Clojure provides the ability to interface with Java objects and\n primitives. Knowing how to do this is essential for non-trival\n programs.\nLet's start by instantiating a Java java.util.Date object:\n user=&gt; (new java.util.Date)\n Mon May 26 10:25:25 PDT 2008\n\nTo pass arguments to the object's constructor, just include them in\n the call to new:\n user=&gt; (new StringBuffer &quot;This is the initial value&quot;)\n This is the initial value\n\nTo call an object's method use the dot (.) form:\n user=&gt; (. (new java.util.Date) (toString))\n &quot;Mon May 26 11:12:15 PDT 2008&quot;\n\nThe dot form uses a dot character (.) as the operator. The second\n argument is the object whose method will be called. The\nthird argument is a list containing the method name and the method's\n arguments, if any:\n user=&gt; (. (new java.util.HashMap) (containsKey &quot;key&quot;))\n false\n\nStatic methods can be called in the same way:\n user=&gt; (. Boolean (valueOf &quot;true&quot;))\n true",
    "url": "/2009/4/10/2009-04-10-post/"
  },
  {
    "id": "2009-04-11-post",
    "title": "恥の文化の対極にある日本人ラッパーのメンタリティ",
    "date": "2009-04-11",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2009-04-11-post.md",
    "content": "rapper(ラップをする人)の歌詞って、一般的には自己評価の低いといわれる日本人からすると対極にあると思う。\nということは日本人ラッパーはかなり希少価値が高いかも。\n恥も外聞もなく、『オレは最強、ナンバーワン、ダレにも真似できねぇ』系の歌詞が多い。\n日本人的な、内向的で自己評価低い(ある意味暗い)ラップってあるのかな。そういうのも聴いてみたい。\nそういえばEninemはちょっと内向的な気がするし、MC Sniperも韓国人で日本人にメンタリティが近そうだが、これも内向的なラップをやっている。\n MC Sniper- 한국인(韓國人)\n今、YouTubeでKREVAとかVERBALのオレ最強的ラップを聴いていてふと思っただけなんだけど。\nすみませんが、結論無しのエントリーです。",
    "url": "/2009/4/11/2009-04-11-post/"
  },
  {
    "id": "2009-04-13-post",
    "title": "mapとfilterが動いた",
    "date": "2009-04-13",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-04-13-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況。\nなんとか、mapとfilterを動かす部品がそろったぞ。\n残念ながらmapは副作用を許している。ちょっとキモチワルイ。\nnendo&gt; (map p '(true false nil 1 2 3 &quot;a&quot;))\ntrue\nfalse\n\n1\n2\n3\na\n(true false nil 1 2 3 &quot;a&quot;)\n\nmapの例\n\nnendo&gt; (map (lambda (x) x) '(true false nil 1 2 3 &quot;a&quot;))\n(true false nil 1 2 3 &quot;a&quot;)\n\nmapとforeachは同じなの\n\nnendo&gt; (foreach (lambda (x) x) '(true false nil 1 2 3 &quot;a&quot;))\n(true false nil 1 2 3 &quot;a&quot;)\n\n真偽の判定はRubyと同じ\n\nnendo&gt; (filter (lambda (x) x) '(true false nil 1 2 3 &quot;a&quot;))\n(true 1 2 3 &quot;a&quot;)\n\n気づいてもらえただろうか。\nLisp-1族なのでSchemeに似ているかも知れないけど、true false nil はRubyで定義されているそのもの。\nやっぱり実際に動くと楽しいよね。オレ言語やってみて良かったー。\nこれをきっかけにいろんな言語について知ることもできるし。\nこれから恥を気にせず、書いたコードとか、迷ったこととかをを晒していきます。\n\nコメント by sion:\n人に使ってもらえるツールを作るのは楽しいものです。\nそれで喜んでもらえたら、ひとしおですね。\nと、考えると、オレ言語の開発は 究極かもしれませんね(^^)\n余談ですが、先日 「別に技術にもプログラミングにも興味はない」と言い切るプログラマーに出会ってショックを受けました。\n\nコメント by kiyoka:\n人に使ってもらえるものになるかどうかわかりませんが、その心意気で作っていきます。\nまずは、自分が日常的に使いたくなるものができれば... と思っています。楽しみながら続けたいです。\nそうそう、プログラミング自体に興味が無いプログラマーは時々いらっしゃいますよね。\n最初は私もショックだったのですが、意外とそういう人は多いので悲しいです。\nプログラミング言語の表現力が年々向上しているので、数年先にはプログラミングを楽しめる人とそうでない人の差は、結果として大きな技術力の差になってくると信じています。いや、信じたいです。\nでも時々、スクリプト言語が使える場面でも、C言語でとんでもない質と量のコードを量産する人がいたりして全てあてはまるわけではないんですけどね。\nコメント by sion:\n人に使ってもらえるツールを作るのは楽しいものです。\nそれで喜んでもらえたら、ひとしおですね。\nと、考えると、オレ言語の開発は 究極かもしれませんね(^^)\n余談ですが、先日 「別に技術にもプログラミングにも興味はない」と言い切るプログラマーに出会ってショックを受けました。",
    "url": "/2009/4/13/2009-04-13-post/"
  },
  {
    "id": "2009-04-14-post",
    "title": "やる気はどこからやってくるのか",
    "date": "2009-04-14",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2009-04-14-post.md",
    "content": "着手すると、やる気はあとからついてくる\nこれは、私が経験的に感じていること\n弾さんもこう書いていらっしゃる。\n 404 Blog Not Found:やる気出すより手足出せ\n やる気があるからやるんじゃない。やったからやる気が出るのだ\n 朝礼とかラジオ体操とかには、案外重要な意味があることになる。やる気はや\n らなきゃ出ないのだから、とりあえず体を動かしてしまうというわけだ。脳の\n リハビリで手足を動かすのも、然り。\n 「やる気」がある人というのは、実は例外なく「とりあえず手足を動かす」を\n 実践しているようだ。レポーターはメモを取らずにいられない。絵描きはスケッ\n チせずにはいられない。そしてプログラマーはエディタを起動せずにはいられ\n ない。\n そうやって手足を動かしていくうちに、やる気なるものが出てくる。この「動\n 作」が「意識」に変わるのにはある程度タイムラグがあって、このタイムラグ\n の間に動く分の「余計な動作」というか「捨て動作」とでも言える動作が、実\n はやる気には欠かせない。\n脳科学ではいろいろ解明されてきているらしい、やる気のメカニズムについては、そのうちはっきりしてくると思う。\nDOUBLEのEmotions\nこれは私の好きなDOUBLEのEmotionsという曲。\nミュージシャンというのは創作が仕事なので、やる気というものをコントロールする術を身に付けざるを得ない。\nそんなテーマを扱ったR&amp;B曲。うーん。いいねぇ。\n歌詞はコピーできないそうなので、リンクだけ張っておく。\n DOUBLE Emotions 歌詞検索の歌ネット\nYouTubeも埋め込んでおこう(音声のみ)\n DOUBLE - Emotions\n気になるSF小説\n弾さんの文章をもいちど引用。\n 404 Blog Not Found:やる気出すより手足出せ\n この「動作」が「意識」に変わるのにはある程度タイムラグがあって、このタ\n イムラグの間に動く分の「余計な動作」というか「捨て動作」とでも言える動\n 作が、実はやる気には欠かせない。\nこのタイムラグについて、SFなのにSFとは思えない内容の短編『7パーセントのテンムー』が良かったのでついでに紹介。\n脳科学の研究でこのSFの仮説が証明されたらおもしろいなーと思った。\nネタバレになりそうなので、これ以上は書きませんけど。\n短編『7パーセントのテンムー』が収録された本\n結論\nやる気が出るまで待ってても無駄。とにかく着手すべし。",
    "url": "/2009/4/14/2009-04-14-post/"
  },
  {
    "id": "2009-04-15-post",
    "title": "高階関数の定義(mapとfilter関数)",
    "date": "2009-04-15",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-04-15-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nmapとfilterの定義\n先日『[kiyoka.2009_04_13]Nendo mapとfilterが動いた』で書いた関数定義は、それぞれこんな感じ。\nあんまり美しいとは言えないけど... もっと簡潔に書けるんだろうか。\n\nmapの定義\n\n(define map\n (lambda (pred lst)\n (if (null? lst)\n '()\n (cons\n (pred (car lst))\n (map pred (cdr lst))))))\n\nforeachはエイリアス定義\n\n(define foreach map)\n\nfilterの定義\n\n(define filter\n (lambda (pred lst)\n (if (null? lst)\n '()\n (let ((result (pred (car lst))))\n (if result\n (cons\n result\n (filter pred (cdr lst)))\n (filter pred (cdr lst)))))))\n\nついでに値の標準出力への出力 p の定義\n\n(define p\n (lambda (x)\n (printf &quot;%s\\n&quot; x)\n x))\n\n記念にFizzBuzz問題を書いてみた\n実はletスペシャルフォームも実装済み。\n\nFizzBuzz問題\n\n;; FizzBuzz write in Nendo\n(define fizzbuzz\n (lambda (max)\n (map\n (lambda (x)\n (let ((x (+ x 1)))\n (if (= 0 (% x 15))\n &quot;FizzBuzz&quot;\n (if (= 0 (% x 3))\n &quot;Fizz&quot;\n (if (= 0 (% x 5))\n &quot;Buzz&quot;\n x)))))\n (range max))))\n\n実行結果\nnendo&gt; (fizzbuzz 30)\n(1 2 &quot;Fizz&quot; 4 &quot;Buzz&quot; &quot;Fizz&quot; 7 8 &quot;Fizz&quot; &quot;Buzz&quot; 11 &quot;Fizz&quot; 13 14\n &quot;FizzBuzz&quot; 16 17 &quot;Fizz&quot; 19 &quot;Buzz&quot; &quot;Fizz&quot; 22 23 &quot;Fizz&quot; &quot;Buzz&quot; 26\n &quot;Fizz&quot; 28 29 &quot;FizzBuzz&quot; )\n\n次は、可変長引数をあきらめた話と、Rubyのライブラリを使ってズルしまくりの話を書きます。",
    "url": "/2009/4/15/2009-04-15-post/"
  },
  {
    "id": "2009-04-17-post",
    "title": "[ソーシャル化するOSS開発者たち](http://www.atmarkit.co.jp/news/analysis/200904/14/git.html)を読んだ",
    "date": "2009-04-17",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2009-04-17-post.md",
    "content": "Subversionとgitについて書かれている。\n私はまだgitを使ったことが無いのだけど、そんなに速いのか。\nソーシャル化するOSS開発者たち\n サーバが不要で、いくつかコマンドを叩くだけで、手軽にブランチが作れて、\n しかも非常に速い。単に新しくブランチを作るだけなら、1つあたり41バイト\n のファイルが生成されるだけなので、ブランチングは処理的にも心理的にもコ\n ストが低い。\n .\n .\n 0.5秒で差分が取れるのか、同じ作業に30秒かかるのかでは、まったく仕事の\n やり方が変わってくるという。例えばPythonで書かれたMercurialというもの\n がある。これはGitと同様の分散ソースコード管理ツールでリーナスも評価は\n しているのだが、パフォーマンスの点でGitがベターだと訴える。「コミット\n や差分作成に30秒かかるかもしれない。30秒というと、そんなに悪くないと\n 思うかもしれないけど、まじめな話、10分の1秒というのに慣れてしまったら\n 30秒なんて最低なんです」\n一体どんな顔をしているのかgitのソースコードをダウンロードしてチラ見しておいた。\nスゲー。\nLinusのコーディングスタイルはLinuxとgitでほとんど同じだ。\nカーネル(Linux)とアプリケーション(git)は、おそらく違うスタイルで書かれているんだろうと思っていたのだが。\n例えば、gitの中のsha1値をhexに変換する関数\nchar *sha1_to_hex(const unsigned char *sha1)\n{\n static int bufno;\n static char hexbuffer*4**50*;\n static const char hex[] = &quot;0123456789abcdef&quot;;\n char *buffer = hexbuffer*3 &amp; ++bufno*, *buf = buffer;\n int i;\n\n for (i = 0; i &gt; 4*;\n *buf++ = hex*val &amp; 0xf*;\n }\n *buf = '\\0';\n\n return buffer;\n}\n\n20とか50とか即値が使われまくり。\nこの関数もgitとは思えない。カーネルの中身みたいな雰囲気。\n```lisp\nunsigned long unpack_object_header_buffer(const unsigned char buf,\n unsigned long len, enum object_type type, unsigned long *sizep)\n{\n unsigned shift;\n unsigned char c;\n unsigned long size;\n unsigned long used = 0;\n c = buf*used++*;\n *type = (c &gt;&gt; 4) &amp; 7;\n size = c &amp; 15;\n shift = 4;\n while (c &amp; 0x80) {\n if (len\n\nWhen I first looked at Git source code two things struck me as odd:\n1. Pure C as opposed to C++. No idea why. Please don't talk about portability,\nit's BS.\n\nYOU are full of bullshit.\nC++ is a horrible language. It's made more horrible by the fact that a lot \n of substandard programmers use it, to the point where it's much much \n easier to generate total and utter crap with it. Quite frankly, even if \n the choice of C were to do nothing but keep the C++ programmers out, \n that in itself would be a huge reason to use C.\n .\n .\n .\nところで、BS(bullshit)ってどれくらい強い言いまわしなの？\n気の弱い私はちょっと心配になるよー。\nさて、git本体のソースコードの話は置いといて、GitHubには興味を持ったので、emacsの良いgit-modeを見つけたら一度つかってみよう。\npcl-svn.elと似たキーバインドの奴があるとうれしいんだけど。",
    "url": "/2009/4/17/2009-04-17-post/"
  },
  {
    "id": "2009-04-22-post",
    "title": "Ruby標準ライブラリを使って]のライブラリ実装をサボりまくりな話",
    "date": "2009-04-22",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-04-22-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nRubyでLisp処理系を作ると楽できる\n例えば、sort関数。\n仕様は『引数にリストを取って、ソート済みの新しいリストを返す』というもの。\nnendoが動いている様子。\n$ ./nendo \nnendo&gt; (sort '(1 5 6 3 4))\n(1 3 4 5 6 )\n\nRubyでは\n$ irb\n&gt;&gt; *1, 5, 6, 3, 4*.sort\n=&gt; *1, 3, 4, 5, 6*\n\nさて、nendoの実装はというと\n def getIFunc( name )\n case name\n .\n 略\n .\n when 'sort'\n lambda {|arg| arg.to_arr.sort.to_list }\n .\n 略\n .\n end\n end\n\nとなっている。\n引数argはconsセル用の 'Cellクラス' の連結リストで、一旦RubyのArrayに変換することでRuby標準のsort関数を使っている。\n上の様に短く書けるのはCellクラスにイテレータを実装したことと、Arrayクラスにto_listメソッドを追加したため。\n Cellクラスのキモの部分\nclass Cell\n include Enumerable\n\n def initialize( car = Nil.new, cdr = Nil.new )\n @car = car\n @cdr = cdr\n end\n attr_accessor :car, :cdr\n .\n 略\n .\n def each # Supporting iterator\n it = self\n while Nil != it.class\n yield it\n it = it.cdr\n end\n end\n\n def to_arr\n self.map {|x| x.car}\n end\nend\n\nこちらは、動的にArrayクラスにto_listを追加するコード\nclass Array\n def to_list\n cells = self.map { |x|\n Cell.new( x )\n }\n ptr = cells.pop\n cells.reverse.each { |x|\n x.cdr = ptr\n ptr = x\n }\n return ptr\n end\nend\n\nsortだけでなくreverseとuniqも同じ\n一旦Arrayに変換するだけで良い関数はsortと同様に書ける\n def getIFunc( name )\n case name\n .\n .\n when 'sort'\n lambda {|arg| arg.to_arr.sort.to_list }\n when 'reverse'\n lambda {|arg| arg.to_arr.reverse.to_list }\n when 'uniq'\n lambda {|arg| arg.to_arr.uniq.to_list }\n .\n .\n end\n end\n\nsortに評価関数を指定したい場合は？\nウーン… どうしようかな…\nうまくこの仕組みにのっかって行けるかどうか微妙。\nその時はsort関数をnendoで実装しなおさないといけないなぁ。\nreverseはそのままでいいかも。",
    "url": "/2009/4/22/2009-04-22-post/"
  },
  {
    "id": "2009-04-24-post",
    "title": "RSpecを学習中",
    "date": "2009-04-24",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-04-24-post.md",
    "content": "この記事を読みながら概略をつかもうとしているところ\n Rubyist Magazine - スはスペックのス 【第 1 回】 RSpec の概要と、RSpec on Rails (モデル編)\n[Nendo]の開発では、一旦ラフなコードを書いては、もっと簡潔になるようにリファクタリングするという繰返して開発しているので、RSpecがうまく使えそう。\nとういかテストコードをすでに沢山書いていて、それをちゃんと整理しないとなと思っていたところ。\nRSpecのDSLは慣れると読みやすそう。\nいつか仕事でも役に立ちそうなのでみっちりやっておこう。\nRSpecはオンラインドキュメントが充実しているので、現時点ではこの本を買うまでもないかなと思っている。",
    "url": "/2009/4/24/2009-04-24-post/"
  },
  {
    "id": "2009-04-25-post",
    "title": "Jazzで一番美しいと思う曲",
    "date": "2009-04-25",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2009-04-25-post.md",
    "content": "これ。久々に疲れた時に聴いてみた。美しすぎる。\n Miles Davisの『Blue In Green』という曲。\nこのアルバムに入っている。\nBill Evansのアルバムに入っているトリオの演奏も美しい。",
    "url": "/2009/4/25/2009-04-25-post/"
  },
  {
    "id": "2009-04-26-post",
    "title": "屋外でプログラミング",
    "date": "2009-04-26",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2009-04-26-post.md",
    "content": "最近家では10分も集中することができない(というか、子供が無いたらすぐになんとかしないといけないので、集中することを禁止されている)\nというわけで、1週間に2時間くらいは開放させてもらって、プログラミングに集中するようにしてみた。\n子供がいない時([Sumibi.org]を作っていた時)は土日に8時間くらいは集中する時間があったので、えらく使える時間は減ったなぁと思う。\nモスバーガーの屋外の席でこれからプログラミングするぞという時の写真\n 誰も邪魔する人がいないので、集中を切らすことがない。\n\nちなみに、今週は集中する時間は取れなかった...\n子供がいる家でも、プライベートの時間で勉強を続けている人もいるけど、どうやっているんだろう。\n秘密が知りたい。",
    "url": "/2009/4/26/2009-04-26-post/"
  },
  {
    "id": "2009-04-29-post",
    "title": "]のオープンソースライセンスを何にするか",
    "date": "2009-04-29",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-04-29-post.md",
    "content": "[Nendo]はRubyベースなので、選択肢は二つになりそう\n- Rubyと同じ(GPLとArtisticのデュアルライセンス)\n- 修正BSD\nどちらにするかは別プロジェクトからどちらのランセンスのコードを多く輸入する可能性があるかで考えてみる。\n直感では、[Nendo]のライブラリはRubyではなくNendo言語自身で書く量のほうが圧倒的に多いと思うので、Scheme等の処理系によく採用されている修正BSDの方がいいいかなと思う。\n今のところ、修正BSDで公開されていて参考にしているScheme処理系。\n- [Gauche]\n- TinyScheme\n- Chibi-Scheme\n[Nendo]はSchemeではないので、そのまま取込むことはできないけど、少しの変更で再利用できるだろう。",
    "url": "/2009/4/29/2009-04-29-post/"
  },
  {
    "id": "2009-05-03-post",
    "title": "GitをMacにインストールした",
    "date": "2009-05-03",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-05-03-post.md",
    "content": "WEB+DB PRESSのGit特集を読んでGitを使ってみる気になった。\n[Nendo]を[CodeRepos]からGitHubに移してみようかなと思う。\nSubversionと違って、オフラインでもコミットできるので、カフェでプログラミングにも有利だ。\nこれは育児の合間の時間でもできるな。\n追記:\n結局、git version 1.6.2.4をソースからインストールした。\n自分のMac(PowerBook G4)はCPUがIntelではなく、PowerPCなので、本家サイトに置いてあるIntel専用バイナリが使えない。\nもうそろそろ、PowerPCは取り残される時代が来てしまったかな。\nYouTubeがHQをサポートした頃から動画再生処理も重く、コマ落ちが酷くてまともに觀れないし、いろいろ不便になってきた。\n故障でもしたら買いかえるんだけど。",
    "url": "/2009/5/3/2009-05-03-post/"
  },
  {
    "id": "2009-05-04-post",
    "title": "RSpecでraise_errorマッチャの使いかたを勘違いしていた",
    "date": "2009-05-04",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2009-05-04-post.md",
    "content": "RSpecのexpectationの書き方で、気を付けないと行けないところ\nraise_errorマッチャはProcに対してのみ有効\n『あるexampleで例外TypeErrorが出ること。』という仕様を記述する際、『shouldを付ける対象はProcでないといけない』ということは簡単に間違えそう。\nある関数でTypeErrorが出ることを宣言したい場合、次の例は間違い。\n @anObj.aMethod.should raise_error( TypeError )\n\nこのままでは、RSpecのspecコマンド本体が例外で止まるので、次の様にしていた。\n begin\n @anObj.aMethod.should raise_error( TypeError )\n rescue\n end\n\nこうすることによって、エラーがでなくなり、テストにパスしていたいのでOKだと思ってしまっていた。\nでも実は、ちゃんと検査できていなかっただけ。\n正解はコチラ\n lambda{ @anObj.aMethod }.should raise_error( TypeError )\n\nProcのインスタンスにするためにlambdaで囲っている。\nこの場合、 @anObj.aMethodが TypeError以外の例外をraiseしたり、何も例外をraiseしなかった場合、ちゃんとfailしてくれる。\n(TestDriven Development:TDD)の基本\n上の例はちゃんと失敗するところを見届けてなかったからこんな勘違いをしたのだ。\nTDD の進め方と原則を引用しておきます。ちゃんと守らないと。\n Rubyist Magazine - スはスペックのス 【第 1 回】 RSpec の概要と、RSpec on Rails (モデル編)\n TDD の進め方と原則\n TDD の進め方はいたって簡単です。TDD は以下の 3 つのステップから構成されます。\n 1. プロダクトコードを書く前にテストコードを書き、それが失敗することを\n 確認する (レッド)\n 2. テストに成功するようにプロダクトコードを書く (グリーン)\n 3. プログラムの振る舞いを変えないように、プロダクトコードの重複などを\n 整理する (リファクタリング)\n 4. (最初に戻る)\n「レッド」や「グリーン」といった表現は、いわゆる xUnit*1 の実行結果表\n 示バーの伝統的な色づかいに由来しています。RSpec でもレッド/ グリーンと\n いった色使いの伝統が踏襲されています。\nところで、[Nendo]の開発はspecファイルをガシガシ書き足しているところだが、まだまだ[Nendo]を書き捨てスクリプティングに使えるようになるまでは先が長そう。\n7月のShibuya.lispのLTをする段階で一応ダウンロードして遊べるようにしときたいなぁ。\nそのために、シンタックスエラーとかランタイムエラー表示まわりを強化しようと頑張っているところです。\nプログラミング言語処理系はこういう地道な作業が山積みで骨が折れる。",
    "url": "/2009/5/4/2009-05-04-post/"
  },
  {
    "id": "2009-05-09-post",
    "title": "undefined variable エラーをRubyの例外システムの上に実装してみた",
    "date": "2009-05-09",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-05-09-post.md",
    "content": "[Nendo]はせっかくRubyの上に構築している言語なので、エラー処理などもRubyの例外処理をそのまま使って実装してみた。\nもちろん、バックトレースの情報にもエラーが起きた行番号を埋めこむ処理も入れた。\n以下は、nendo処理系の動作結果 ( rubyExp=&gt;&gt; という部分はトランスレートされた後のRubyコードをデバッグ表示したもの )\nxという変数はどこにも束縛されていない(未定義)のためエラーとなる。\n Rubyの例外システムをそのまま使っている。\n$ ./nendo\nnendo&gt; x\n rubyExp= __e ; __e.set_backtrace( *&quot;(stdin):1&quot;* + __e.backtrace ) ; raise __e ; end &gt;&gt;&gt;\nundefined local variable or method `x' for #\n from (stdin):1\n from (stdin):1:in `initialize'\n from ./nendo.rb:433:in `initialize'\n from ./nendo.rb:871:in `new'\n from ./nendo.rb:871:in `initialize'\n from ./nendo:10:in `new'\n from ./nendo:10:in `main'\n from ./nendo:19\n\nxを束縛する\nnendo&gt; (define x 1)\n rubyExp=&gt;&gt;\n1\n\nその後は例外が発生しない\nnendo&gt; x\n rubyExp= __e ; __e.set_backtrace( *&quot;(stdin):3&quot;* + __e.backtrace ) ; raise __e ; end &gt;&gt;&gt;\n1\n\nできれば、このままあらゆるエラー処理をRubyの例外に載せることができればいいのだけど...\nやってみないと分からないというのが正直なところ。\nたぶん誰かは既に同じ様なことをやってみてるんだろうなぁ。\nでも、そういう、順を追って問題にぶつかりながら解決策を考えるのも、オレ言語を実装する楽しみの一つだと分かってきた。\nオレ言語はいろんな事を考えるキッカケを与えて来れる良い学習方法だと思う。\nまだまだ、Matz氏のいう『コンピュータサイエンスの総合芸術』という域まで達していないけど、多くの事を同時に考えてバランスを取る大変さが分かって来た気がするぞ。\n まつもとゆきひろのハッカーズライフ：第7回　言語の重要性その2 (2/2) - ITmedia エンタープライズ\n しかし、自分言語を作ることで何かメリットがあるのでしょうか？\n ええ、あるんです。\n 1つ目のメリットは、言語処理系というものがプログラミングの中でしばしば\n 登場するテクニックの集合体であることです。例えば、設定ファイルを読み込\n むルーチンなどは、言語処理系の字句解析、構文解析そのものです。また、言\n 語処理系はコンピュータサイエンスの総合芸術ですから、処理系を実装するた\n めに用いたテクニックはあらゆるプログラミングに応用できます。\n また、良い言語をデザインしようという行為は、人間の気持ちをより深く考\n えることでもあります。つまり、インタフェースのあるべき姿について、よ\n り深い考察を行うことでもあるわけです。自分言語を作る2つ目のメリットと\n しては、言語レベルでの使い勝手を考えることで、プログラムの使い勝手に\n 関するより深い経験と知識を身に着けられることがありそうです。",
    "url": "/2009/5/9/2009-05-09-post/"
  },
  {
    "id": "2009-05-12-post",
    "title": "]を[GitHub](http://github.com/)に移してみた。",
    "date": "2009-05-12",
    "categories": [
      "Git"
    ],
    "file_path": "_posts/2009-05-12-post.md",
    "content": "こちら\n kiyoka's nendo at master - GitHub\n[CodeRepos]に置いていある[Nendo]のソースはそのうち消す予定。\nEmacs用のgit.elを試して納得したら心おきなくこのWikiシステム兼ブログシステムを([OldType])も[CodeRepos]からGitHubに移そうかな。",
    "url": "/2009/5/12/2009-05-12-post/"
  },
  {
    "id": "2009-05-13-post",
    "title": "Rubyのメソッドはファーストクラスオブジェクトだった",
    "date": "2009-05-13",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2009-05-13-post.md",
    "content": "Yuguiさんのエントリーより引用\n ファーストクラスオブジェクトとしてのメソッド - 世界線航跡蔵\n やー、Rubyのメソッドはファーストクラスですよ。返り値にできて、変数に格\n 納して演算できて、引数にできるという意味では。\n 確かに、RubyはPythonやJavaScriptやSchemeに比べると高階関数を陽に使うプ\n ログラミング*1 は不格好になる。Pythonなら簡単なのに、\n bound_function = obj.hoge\n bound_function(arg1, arg2, arg3)\n\nRubyは余計なメソッド呼び出しがくっついて不格好だ。\n method = obj.method(:hoge)\n method.call(arg1, arg2, arg3)\n\n私もこの点が気にくわなくてまつもとさんに「メソッドがファーストクラスだっ\n たらいいのに」と言ったことがある。でも、まつもとさんの考えではすでに\n ファーストクラスということだった。\n名前空間\n もう細かいところは記憶が定かでないので、以下は私の理解になる。メソッド\n はただ、名前空間が違うんだ。\n 既存のメソッドと同名の識別子に値を代入すると、それはローカル変数の初期\n 化になる。けれども、メソッド呼び出しでは依然として元のメソッドを参照す\n る。\n p = 1\n p p #=&gt; 1\n\nMatzさんのブログより引用\n Matzにっき(2008-02-01)\n Lisp-1とLisp-2\n ここで説明もなくLisp-1とかLisp-2とか書いたが、そういえば日本語であまり\n この用語を見たことがないので補足しておく。\n 基本的に名前空間が一つしかないLispのことをLisp-1と呼ぶ。たとえばSchemeがそう。\n (略)\n Lisp-1とLisp2の区別はLisp以外のプログラミング言語でも存在する。たとえ\n ば、PythonやJavaScriptはLisp-1であり、 RubyはLisp-2である。\nということで、RubyはLisp-2だから識別子に入れた手続きを呼びだすために callメソッドがが容易されているという理解。\nこれが分かれば、[Nendo]からRubyのメソッドを呼びだす文法が正しく定義できそうだ。\nもうちょっとでメソッドと識別子に登録されたProcオブジェクトは全く別物だと勘違いするところだった。\nこういうエントリーもある。\n Rubyの呼び出し可能オブジェクトの比較(1) - 世界線航跡蔵\n[Nendo]の開発にはドンピシャの情報。Yuguiさんすばらしい。ありがたや。",
    "url": "/2009/5/13/2009-05-13-post/"
  },
  {
    "id": "2009-05-29-post",
    "title": "Scheme脳に偏った変なコーディングについて",
    "date": "2009-05-29",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2009-05-29-post.md",
    "content": "私はRubyでプログラミングする時、次の様にRubyらしからぬコーディングスタイルを取る。(仕事では同僚とコード共有するのであまりやらないけど)\n\nreturn は書かない\n最後の評価値がそのブロックまたはメソッドの戻り値なので、あえてreturnを書く必要なし。\n\n内部関数を定義する\nmethodの内側にローカル関数を定義したい時は lambdaを使って関数定義する。\nどこかのrubyバージョンからdefをネストで定義できる様になったんだっけかな？\n\n配列に対しての破壊的操作を避ける。\nこのような書きかたをするなら\n\n newArr = []\n arr.each { |x|\n newArr.push( hoge( !x ))\n end\n\n代わりにmapやselect等の高階関数を使って次の様に書く(関数型スタイル)\n newArr = arr.map{ |x| hoge( x ) }\n\nたぶん 3番 は万人に許容されると思うが、1,2番 はダメという人もいるだろう。\n昔あるお客さんが書かれたサンプルコードで 1,2番 が使われているのを見てうちの社員がうげぇーとなっていたっけ。\nJavaのような平均的なプログラミング言語に慣れた人には、ちょっと受けいれられないのだろう...\nそうそう、JavaScript + Prototype.jsの組合せでも同じようなスタイルでプログラミング出来るよ。",
    "url": "/2009/5/29/2009-05-29-post/"
  },
  {
    "id": "2009-06-01-post",
    "title": "コードの世界",
    "date": "2009-06-01",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-06-01-post.md",
    "content": "2章まで読んだ。本当にいい本です。オススメ。\nオレ言語を作ったりしている人はたぶん買っているだろうけど、それ以外の人にも薦めるぞ。\n2章まで読んだだけでも、なぜ、RubyにLispのようなmacroを導入しなかったのかを感じ取ることができる。\nLispのようなmacroで無限の柔軟性を手に入れたいのは一部の人だけで、もっと広く使われるためにはもう少しマイルドな代替手段を使って攻める必要があるという狙いがあるようだ。\nたしかに、Rubyのmethod_missingの仕組みや、メタプログラミングの仕組みを使えばかなり読み書きしやすいDSLが作れる。\nでも、個人的にはその仕組みが複数あったり、それぞれになんとなく固有の限界が見え隠れしたりして全容を理解するまでが、遠いという感じがある。でも、これは好みの問題か。\nLisperはLispマクロの単純なルールで限界を突破するけれども、普通のひとにはたしかにコードをパッと見ただけで拒否反応を起こすのも現実なのは何度も経験している。\nうーん。Rubyのバランス感覚はすばらしい。\nでも、それをあえて崩してみるのも楽しいかなと思って作っているのが、[Nendo]というわけ。さてどんなものになるのやら。",
    "url": "/2009/6/1/2009-06-01-post/"
  },
  {
    "id": "2009-06-02-post",
    "title": "伝統的なmacroの実装に向けて",
    "date": "2009-06-02",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-06-02-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nmacroの実装方法調査中。\nとにかくmacro機能が無いと何も実用的な構文は何も定義できないということを今になって痛感。(遅すぎ)\n逆にmacro機能さえ有れば速度さえ気に為なければいくらでも必要な構文が量産定義できるのだった。\n最近、 On Lisp \nそんなこんなで、Rubyのライブラリを呼びだすという楽しい部分は後回しにしたい。\nTinyScheme 1.39のソースコード(init.scm)に含まれるこのquasiquoteが動くとうれしい。というのも、こんな複雑な処理を自分で書くのは骨が折れるので割愛したい。\nこれくらい自分で書かないと行けないのかなとも思うけど。\nしかし、これを動かそうとするだけでもapply とか eqv? とか色々足りない関数が有る。\nしかも、condが使われているのでそのまま動かそうとするとcondをRubyで実装するしか無いのかだろうか。\nいろいろ手は有るけど、このうちどの案にしようか。\nquasiquoteの定義中でcondを使っている箇所をifに書きなおす(Lisperらしくないかも!)\ncondをビルトインにする(Rubyで実装する)\ncondをquasiquote無しでmacro定義する\n動作速度にこだわらないToy言語ということで、3番が有力かなぁ。\n;; The following quasiquote macro is due to Eric S. Tiedemann.\n;; Copyright 1988 by Eric S. Tiedemann; all rights reserved.\n;;\n;; Subsequently modified to handle vectors: D. Souflis\n\n(macro\n quasiquote\n (lambda (l)\n (define (mcons f l r)\n (if (and (pair? r)\n (eq? (car r) 'quote)\n (eq? (car (cdr r)) (cdr f))\n (pair? l)\n (eq? (car l) 'quote)\n (eq? (car (cdr l)) (car f)))\n (if (or (procedure? f) (number? f) (string? f))\n f\n (list 'quote f))\n (if (eqv? l vector)\n (apply l (eval r))\n (list 'cons l r)\n )))\n (define (mappend f l r)\n (if (or (null? (cdr f))\n (and (pair? r)\n (eq? (car r) 'quote)\n (eq? (car (cdr r)) '())))\n l\n (list 'append l r)))\n (define (foo level form)\n (cond ((not (pair? form))\n (if (or (procedure? form) (number? form) (string? form))\n form\n (list 'quote form))\n )\n ((eq? 'quasiquote (car form))\n (mcons form ''quasiquote (foo (+ level 1) (cdr form))))\n (#t (if (zero? level)\n (cond ((eq? (car form) 'unquote) (car (cdr form)))\n ((eq? (car form) 'unquote-splicing)\n (error &quot;Unquote-splicing wasn't in a list:&quot;\n form))\n ((and (pair? (car form))\n (eq? (car (car form)) 'unquote-splicing))\n (mappend form (car (cdr (car form)))\n (foo level (cdr form))))\n (#t (mcons form (foo level (car form))\n (foo level (cdr form)))))\n (cond ((eq? (car form) 'unquote)\n (mcons form ''unquote (foo (- level 1)\n (cdr form))))\n ((eq? (car form) 'unquote-splicing)\n (mcons form ''unquote-splicing\n (foo (- level 1) (cdr form))))\n (#t (mcons form (foo level (car form))\n (foo level (cdr form)))))))))\n (foo 0 (car (cdr l)))))\n\nmacroが動いたら玩具Toy言語といえどももかなり遊べる様になるな。楽しみ^_^\nP.S.\n ちなみにchibi-schemeは伝統的macroではなくdefine-syntaxでquasiquoteを実\n 現しているが、define-syntaxの実装は難しそうなのでnendoではパスするつも\n り。",
    "url": "/2009/6/2/2009-06-02-post/"
  },
  {
    "id": "2009-06-15-post",
    "title": "伝統的なmacroが動いた",
    "date": "2009-06-15",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-06-15-post.md",
    "content": "ここまで長い道程だったが、macroが動いた。\n実際にmacroを実装してみるとmacroがどういうものかやっと理解できた気がする。\n伝統的なmacroの例\n引数に指定された変数をインクリメントするmacroを定義\nnendo&gt; (define inc (macro (x) (list 'set! x (list '+ '1 x))))\n#\n\n変数aを準備\nnendo&gt; (define a 10)\n10\n\nmacroの展開結果を見る\nnendo&gt; (macroexpand1 '(inc a))\n(set! a (+ 1 a))\n\n実際にインクリメントしてみる\nnendo&gt; (inc a)\n11\n\n引数に指定した処理を2回実行するmacroを定義\nnendo&gt; (define twice (macro (x) (list 'begin x x)))\n#\n\n(inc a)をマクロで2回実行\nnendo&gt; (twice (inc a))\n13\n\nmacroの展開結果を見る(1回だけマクロ展開)\nnendo&gt; (macroexpand1 '(twice (inc a)))\n(begin (inc a) (inc a))\n\nmacroの展開結果を見る(2回のマクロ展開)\nnendo&gt; (macroexpand1 (macroexpand1 '(twice (inc a))))\n(begin (set! a (+ 1 a)) (set! a (+ 1 a)))\n\nさて、orとandをmacroで実装してみよう。と思ったが、可変長引数をサポートしていないので、書けないという問題に気がついた。orz.\nやっぱり可変長引数は必須なのか...\nmacroの可変長引数サポートについて\nその後、macroに可変長引数をサポートしようとして,\n(define name (macro (arg1 arg2) body))\n\nという形式ではゼロ個以上の可変長引数がサポートできないことが分かった... o.rz.\n要するに、lambdaが入る部分にmacroというキーワードが入る形で考えていた。\nそうすると、なにが問題かというと、ゼロ個以上の可変長引数を書きたい場合は、気持ち的には\n(define name (macro (. rest) body))\n\nだが、S式として成立しない。 (. rest) の部分がS式としてエラーとなる。\nTinySchemeはmacro定義をつぎの形式で行なうが、この形式ならうまくいく。\n(macro (name arg1 arg2) body)\n\nまたは、\n(macro name (lambda (arg1 arg2) body)\n\nとなっている。\nこの形式なら\n(macro (name . rest) body)\n\nとかけるのね。\nつまり、defineと同じイメージでmacroキーワードを組み立てないといけないのだな。\n\nコメント by shiro:\n(macro rest body) じゃまずいですか? &gt; ゼロ個以上の可変長引数\n\nコメント by kiyoka:\n＞ (macro rest body) じゃまずいですか?\nおっと、今R5RSの仕様をみたら、lambdaがその形式を取るんですね。\n初めて知りました。\nmacroも同じ形式で問題ないです。\nというか、lambdaのほうもその形式をサポートしないといけないですね。\nありがとうございます。\nコメント by shiro:\n(macro rest body) じゃまずいですか? &gt; ゼロ個以上の可変長引数",
    "url": "/2009/6/15/2009-06-15-post/"
  },
  {
    "id": "2009-06-24-post",
    "title": "可変長引数のサポート",
    "date": "2009-06-24",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-06-24-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nlambdaとmacroの可変長引数のサポートができた。\nこれで、いろんなScheme処理系みたいに初期化ライブラリがガンガン書けるぜぃ。\n例えば、list関数同様の関数は次の様に定義できる。\nnendo&gt; (define mylist (lambda lst lst))\n#\nnendo&gt; (mylist 'a 'b 'c)\n(a b c)\n\n1個以上の可変長引数もこの通り\nnendo&gt; (define firstAndRest (lambda ( first . rest ) (list first rest)))\n#\nnendo&gt; (firstAndRest 1 2)\n(1 (2))\nnendo&gt; (firstAndRest 1 2 3)\n(1 (2 3))\n\nこれが動くまでにいろんなバグが見つかってなかなか本題の or と and をmacroで書く所まで行けてない。\nそんなわけで、思ったよりもLisp処理系を作るのは簡単ではないことが分かりつつあるのだが、書いてはリファクタリングを続けることで頭の中でLispというものがどんどん整理されて行く気がする。これが悟り体験のような気がしてウレシイ。\n実際にコードを書いてみて冗長に感じたり、直感的に場合分けが大すぎると感じたりした場合は、だいたいリファクタリングしたらゴッソリと短いコードに置き換わる。\nnendo.rbが1000行を超えては1000行に納まるという繰返し。\nこの感覚なんだろう。\nぷよぷよとかテトリスの連鎖する感じ？\n\nもうそろそろRubyで書く部分は減ってきて Nendoで書く init.nnd の行数が増えて行くのだろう。\nquasiquoteが動く日も近いのではないかな？",
    "url": "/2009/6/24/2009-06-24-post/"
  },
  {
    "id": "2009-06-28-post",
    "title": "defineをmacroで実装した",
    "date": "2009-06-28",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-06-28-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nlambdaとmacroの可変長引数のサポートできたので、それを利用してdefineもNendo上のmacroで実装した。\nいままでは、defineをRubyで実装していたが、Rubyでのリスト処理が煩雑だったのだ。macroでスッキリ書けた。\n初期化ライブラリの init.nnd の冒頭に定義した。\n(set! define\n (macro (arg . body)\n (if (not (pair? arg))\n (cons 'set!\n (cons arg\n body))\n (cons 'set!\n (cons (car arg)\n (list\n (cons 'lambda\n (cons (cdr arg)\n body))))))))\n\nここでは、使える部品が少ないので、定義は非常に冗長になってしまう。\nquasiquoteはまだ使えないし、appendはdefineを使って定義したいのでこうならざるを得ないのかな。\nブートストラップとはそういうものですよ、多分。\nところで、昔、仕事で組込CPUのブートローダーをアセンブラでたくさん書いた事を思い出す。\n組込CPUのブートストラップは、ROM RAMチェックが完了するまではスタック(RAM)が使えないので少ないレジスタを使いまわしてメモリチェックをしないといけない。\nRAMチェックが完了して初めてスタックポインタを設定し、 C言語のエントリポイントである _main を呼ぶことができる。\n_mainまで来ればC言語で書けるので一気に楽になるのだ。\nNendoの初期化ライブラリ init.nnd も同様にビルディングブロックが積みあがるみたいに、後になればなる程、コードが簡潔になっていくのだろう。\ncondもmacro定義したけど、この段階でもまだまだ使える部品が少なくて冗長だ。\n(define cond\n (macro lst\n (define (caseblock elem . elseblock)\n (let ((condition (car elem))\n (body (cdr elem)))\n (append\n (list 'if\n (if (eq? 'else condition)\n true\n condition)\n (cons 'begin body))\n (if (&lt; 0 (length elseblock))\n elseblock\n '()))))\n\n (define (cond_iter lst)\n (if (eq? 0 (length lst))\n '()\n (if (eq? 1 (length lst))\n (caseblock (car lst) '())\n (caseblock (car lst)\n (cond_iter (cdr lst))))))\n\n (cond_iter lst)))\n\n次はこのcondを使ってor と and を定義してみよう。\nもうそろそろ ミニLisp処理系を実装している人とブートストラップの話をしてみたいなぁ。",
    "url": "/2009/6/28/2009-06-28-post/"
  },
  {
    "id": "2009-06-29-post",
    "title": "ついにorとandを定義できた",
    "date": "2009-06-29",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-06-29-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nmacroで構文をどんどん定義している。\nついに or と and が定義できた。ついでに let1 も。\n先日定義したcondも使っている。すごい勢いで積み上がっていく感じが楽しいぞ。\n\n(define let1\n (macro (var expr body)\n (list 'let (list (list var expr)) body)))\n\n(define or\n (macro lst\n (define (or_iter lst)\n (cond\n ((eq? 0 (length lst))\n false)\n ((eq? 1 (length lst))\n (let1 sym (gensym)\n (list 'let1 sym (car lst)\n (list 'if sym sym false))))\n (else\n (let1 sym (gensym)\n (list 'let1 sym (car lst)\n (list 'if sym sym (or_iter (cdr lst))))))))\n (or_iter lst)))\n\n(define and\n (macro lst\n (define (and_iter lst)\n (cond\n ((eq? 0 (length lst))\n true)\n ((eq? 1 (length lst))\n (car lst))\n (else\n (list 'if (list 'not (list 'eq? 'false (car lst)))\n (and_iter (cdr lst))\n 'false))))\n (and_iter lst)))\n\nこれが実行結果\nbash-3.2$ ./nendo\nnendo&gt; (or)\nfalse\nnendo&gt; (or 1 2 3)\n1\nnendo&gt; (or false false 3)\n3\nnendo&gt; (and)\ntrue\nnendo&gt; (and true)\ntrue\nnendo&gt; (and 1 2 3)\n3\nnendo&gt; (and false 2) \nfalse\nnendo&gt; (and true 2)\n2\nnendo&gt; (and 1 2 (print &quot;3\\n&quot;) (print &quot;4\\n&quot;) 5)\n3\n4\n5\nnendo&gt; (and 1 2 false (print &quot;3\\n&quot;) (print &quot;4\\n&quot;) 5)\nfalse\n\n実は、gensym関数の実装はかなりサボっているのだ。\ngensymで生成されるシンボルは若干ぶつかりにくいネーミングルールになっているだけ。いつかイタイ目に会うのかな。\nnendo&gt; (macroexpand '(or 1 2))\n(let ((__gensym__10 1)) (if __gensym__10 __gensym__10 (let ((__gensym__11 2)) (if __gensym__11 __gensym__11 false))))\n\nこのへんがToy言語っぽい。何とかしたい...",
    "url": "/2009/6/29/2009-06-29-post/"
  },
  {
    "id": "2009-07-02-post",
    "title": "Clojureのビデオを見る(1)",
    "date": "2009-07-02",
    "categories": [
      "Lisp"
    ],
    "file_path": "_posts/2009-07-02-post.md",
    "content": "[Nendo]の開発でかなり参考にしたい言語であるClojureのビデオがYoutubeにあった。\niPod touchに入れて数日かけて通勤中に見た。\nIntro to Clojure - 1 to 10\n特にJava Integrationの所は非常に参考になる。\nJavaのインタフェースをClojureからアクセスするためのproxyというキーワードが出てきたのだが、これなんだろう。\n. (ドット)記号でJavaのクラスやメソッドにアクセスする構文は見たことあるけどproxyも調べておこう。\nそれから、[Nendo]のRuby連携のアイデアの為にも、[Nendo]の開発が一段落したらClojureの書籍をじっくり読んでおいた方がいいかも。\nJava連携に限らずClojureには本気で役に立ちそうな機能が満載で開発に3年もかかっているというのもうなずける。",
    "url": "/2009/7/2/2009-07-02-post/"
  },
  {
    "id": "2009-07-05-post",
    "title": "quasiquoteが動いた日",
    "date": "2009-07-05",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-07-05-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nついに、ついに、quasiquoteが動いた！\n(※quasiquoteは、ほとんどのLisp系言語がサポートしています。リスト内包表現に代表されるリストの部分展開をサポートする機能で、 ` , ,@ の3つの記号を使います)\nもうすぐ動くかも、という日々が何日も続いていたので、この上ない達成感がある。\n\nToy言語とはいえ、ちゃんと遊べる様にするためにはちゃんと実装しておかないとね。\nこれが、現段階での quasiquoteの実行結果。\nnendo&gt; `(1 2 3)\n(1 2 3)\nnendo&gt; (set! a 3)\n3\nnendo&gt; `(1 2 ,a)\n(1 2 3)\nnendo&gt; `(1 2 ,@(list a))\n(1 2 3)\nnendo&gt; `(1 ,@(list 2 a))\n(1 2 3)\nnendo&gt; (set! a 11)\n11\nnendo&gt; `,a\n11\nnendo&gt; ``,a\n`,a\n\nR6RSのスペック R6RS:翻訳:R6RS:11.17 Quasiquotation に書いてあるサンプルも一応動いている。\nnendo&gt; `(list ,(+ 1 2) 4)\n(list 3 4)\nnendo&gt; (let ((name 'a)) `(list ,name ',name))\n(list a 'a)\nnendo&gt; `(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)\n(a `(b ,(+ 1 2) ,(foo 4 d) e) f)\n\nこれからRubyとの連携にも手をつけて、どこかでプレゼンできるようなネタを仕込んでいこう。\n育児中の身なので Shibuya.lisp テクニカルトーク#3 には行けなかったけど、今度は何とか都合をつけてイベントに出かけて発表したい。",
    "url": "/2009/7/5/2009-07-05-post/"
  },
  {
    "id": "2009-07-06-post",
    "title": "Shibuya.lisp #3のビデオを見た感想(1)",
    "date": "2009-07-06",
    "categories": [
      "Lisp"
    ],
    "file_path": "_posts/2009-07-06-post.md",
    "content": "実用レベルで使う処理系を作っている方々は実行速度に対する意識が高いなあと感じた。\n shiroさん。現場のSchemeの話題。Gaucheの開発サイクルがわかる。すばらしい。\n 現場のSchemeとGaucheの進化 \nkoguroさん。いつもプレゼンのクオリティが高い。ビデオになっても分かりやすい。\n Inside c-wrapper \n実行速度重視なのはGaucheとかYpsilonとかMoshのScheme実装者がみんなゲームやOSにかんらんでいる人だからだろうか。\nそういえば、koguroさんのc-wrapperもパフォーマンスチューニングの話が多かった。\nLispやSchemeを仕事で使っていないせいかもしれないが、私はどちらかというと実行速度よりもコードの行数が少しでも短くなる事に興味がある。\nさて、われらが[Nendo]については最終的にはWebプログラミングに利用したいと思っているので、そんなにシビアなチューニングは不要だと思っているが、甘いのかな？\nWebアプリは主にDB回りがボトルネックになってくるので、言語側はソースコードの行数圧縮だけを気にすれば良いのではと思っているが...\nまあ、やってみるとハッキリするよね。\n1年後に自分がどんなことを言っているか楽しみ。正反対のことを言ってたりして。可能性は十分ある(笑)",
    "url": "/2009/7/6/2009-07-06-post/"
  },
  {
    "id": "2009-07-07-post",
    "title": "JRubyの開発者がオレ言語も作っている件",
    "date": "2009-07-07",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-07-07-post.md",
    "content": "InfoQ: JVMで動く言語Ioke：分かりやすい構文で、LispとRubyの力を持つ言語\n Ola Bini氏は、JRuby開発の中心人物であり、Practical JRuby on Rails\n Projectsの著者である。その彼が、IokeというJVMの上で動く新しい言語を開\n 発している。\n\n私は言語に関していくつか目標をもっており、そのなかでももっとも具体的な\n 目標は、私がRubyやLispで好きな点を取り入れた言語を作ることです。Ioには\n 既に自分が求めている機能が沢山あることは分かっていますが、ある場面で、\n 十分でないなと思うことがあります。また同様に内部DSLを表すのに非常に適し\n た言語を欲しいとも思っています。自分の邪魔をせず、望んでいることを成し\n 遂げるのに必要な力を沢山与えてくれる言語が欲しいと思っています。そのよ\n うな成り行きで、私はマクロシステムを設計しました。私が設計したものに対\n して、おそらく正気でないと思う人もいることでしょう。\nOla Bini氏がJRubyを開発しながらも、自分の言語もデザインしてみたいというのは分かる気がする。\n技術があるなら、既にある言語の処理系を作るだけで満足するのはもったいないもの。\nそれはそうと、LispとRubyの力の両方をうまく融合したものを作りたいという野望は私と同じだ。\nそれをどうやって実現するかは三者三様のビミョウに異なった答えがあるわけで。\n結局、強力なDSLを構築したかったら『マクロを使う』というのは一つの確実な方法で、それをいかに黒魔術にならない範囲で表現できるかが未解決の問題だと思う。\n[Nendo]はLispなので黒魔術になってしまうことは避けられず、その点は未解決問題としてスルーになるんだろうか。\nそれともすごいアイデアを思い付いちゃったりするんだろうか ^_^\nそんな期待感があるから言語デザインはいつまで経っても楽しい創作テーマなんだと思う。",
    "url": "/2009/7/7/2009-07-07-post/"
  },
  {
    "id": "2009-07-09-post",
    "title": "Rubyとの連携を考える(1)",
    "date": "2009-07-09",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-07-09-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nClojureを参考にする\nClojureの .(dot) operatorを使うやりかたはクラスベースのオブジェクト指向言語との連携を行う上で非常に直感的で良いと思う。\n.(dot)はJavaでもRubyでもメソッドやインスタンス変数へのアクセス記号として使われているので、見た目でLisp外のメソッド呼びだしが連想しやすい。\n以下はClojureのサイトに掲載されているClojureの例。\n Clojure - java_interop\n(.toUpperCase &quot;fred&quot;)\n-&gt; &quot;FRED&quot;\n(.getName String)\n-&gt; &quot;java.lang.String&quot;\n(System/getProperty &quot;java.vm.version&quot;)\n-&gt; &quot;1.6.0_07-b06-57&quot;\nMath/PI\n-&gt; 3.141592653589793\n\nNendoではどうするのか\nClojureの考えかたがそのまま流用出来るかどうか分からないけど、気持ち的にはこんな感じで書きたい。\n Lispのreadの呼びだし\n(read)\n\nRubyのKernel#readの呼びだし\n(.read)\n\nインスタンスのnew\n(. new Date)\n\n同じく、インスタンスのnew\n これは、リーダマクロで (. new Date) に展開されることを想定。\n(Date.new)\n\nRubyのKernel#openでファイルを開いてすべての行を読みこみ\n(let1 f open( &quot;file.txt&quot; )\n (f.readlines.to_list))\n\nブロックの最後に自動でクローズしてくれるwith-openも欲しい。\n ファイルを読みこんでソートして表示する例。\n(for-each\n print\n (with-open( &quot;file.txt&quot; )\n (lambda (f)\n (f.readlines.sort_by.to_list)))\n\n多分、Schemerが見てもRubyistが見ても両方キモチワルイと言うだろうな...\nとりあえず、ここまで動けば発表のネタにはなるでしょう。\nどうです？ちょっと遊んでみたくなりました？\nまずは、ターゲットユーザが自分ひとりなので、自分がスラスラ書ける仕様を試してみるつもりです。\n\nコメント by sion:\nなかなか浮世離れした高尚な遊びですね。\n当方、「python が Windows-31J を理解してくれないから、パッチあてよう！」なんて、極めて野暮なことをやっております(^^;\nようやく今の職場も SubVersion 導入！(いままではVSS) こないだ Wikiも立ち上げたし、今度は trac でも導入しようかと。\nまったく関係ない話でしたね。\nネンド遊びができそうになってきたら、是非使わせてくださいね。\n\nコメント by shiro:\nfoo.barをリーダマクロでS式として読むというのは前にやったことがあるんですが (その時は foo.bar を (-&gt; foo bar) としていた)、\nリーダマクロを素直に実装するとひとつのトークンからひとつのS式への変換になるので、例えばDate.newというトークンが (. new Date) に変換されることになると思います。つまり (Date.new) という式は ((. new Date)) になっちゃう。\nリーダマクロにsplicing (リーダマクロが返したリストを ,@ のように親のリスト中に展開する) を許せば (Date.new) を (. new Date) にすることは可能ですが、そうするなら次のような場合の動作をうまく考えておく必要があります。\n(foo bar.baz) ; splicingすると (foo . bar baz) になっちゃう。\n(foo . bar.baz) ; こんなふうに使われたらどうする?\n\nコメント by kiyoka: \n\nなかなか浮世離れした高尚な遊びですね。\nそうですね。世の中ドラクエが発売されたというのに、こんな遊びを見つけてしまいました。\nなかなかどうしてゲームに匹敵する面白さです。\nネンド遊びができそうになってきたら、是非使わせてくださいね。\nあと何ヶ月かしたら、Rubyと組み合わせて遊べるようになると思います。\nよろしくお願いします。\n\nコメント by kiyoka:\nshiroさんにコメントをもらってからいろいろ考えてみたんですが、リーダマクロで単順に変換するわけにはいかなそうですね。\n例えば、\n (Date.new) は (. Date new) に展開されて欲しいけれども、\n (Date.new.strftime \"%X\") は (. (. Date new) strftime \"%X\") に展開されて欲しいと思ったら単純にはいかなさそうです。\nまた、Clojureでも (set! (instance.member_val) 20) のように set!で インスタンス変数を更新できる様ですが、それも含めて考えると、統一的なルールで処理出来るかどうか考えている所です。\nもうすこし考えが進んだらブログエントリを書きます。\n※ それから、このエントリで 『リーダマクロで (. new Date) に展開されることを想定。』と書いていた所は (. Date new)の間違いでした。すみません。\nコメント by sion:\nなかなか浮世離れした高尚な遊びですね。\n当方、「python が Windows-31J を理解してくれないから、パッチあてよう！」なんて、極めて野暮なことをやっております(^^;\nようやく今の職場も SubVersion 導入！(いままではVSS) こないだ Wikiも立ち上げたし、今度は trac でも導入しようかと。\nまったく関係ない話でしたね。\nネンド遊びができそうになってきたら、是非使わせてくださいね。\nコメント by shiro:\nfoo.barをリーダマクロでS式として読むというのは前にやったことがあるんですが (その時は foo.bar を (-&gt; foo bar) としていた)、\nリーダマクロを素直に実装するとひとつのトークンからひとつのS式への変換になるので、例えばDate.newというトークンが (. new Date) に変換されることになると思います。つまり (Date.new) という式は ((. new Date)) になっちゃう。\nリーダマクロにsplicing (リーダマクロが返したリストを ,@ のように親のリスト中に展開する) を許せば (Date.new) を (. new Date) にすることは可能ですが、そうするなら次のような場合の動作をうまく考えておく必要があります。\n(foo bar.baz) ; splicingすると (foo . bar baz) になっちゃう。\n(foo . bar.baz) ; こんなふうに使われたらどうする?\nコメント by kiyoka: \n\nなかなか浮世離れした高尚な遊びですね。\nそうですね。世の中ドラクエが発売されたというのに、こんな遊びを見つけてしまいました。\nなかなかどうしてゲームに匹敵する面白さです。\nネンド遊びができそうになってきたら、是非使わせてくださいね。\nあと何ヶ月かしたら、Rubyと組み合わせて遊べるようになると思います。\nよろしくお願いします。",
    "url": "/2009/7/9/2009-07-09-post/"
  },
  {
    "id": "2009-07-13-post",
    "title": "Clojureのビデオを見る(2)",
    "date": "2009-07-13",
    "categories": [
      "Lisp"
    ],
    "file_path": "_posts/2009-07-13-post.md",
    "content": "[Nendo]の開発でかなり参考にしたい言語であるClojureのビデオをみた。\nこのあいだ紹介したやつ([kiyoka.2009_07_02])とは別のビデオ。\nInfoQ: Clojure\n In this presentation from the JVM Languages Summit 2008, Rich Hickey\n discusses Clojure, which is an implementation of Lisp. Topics covered\n include Clojure features and syntax, example code, interoperation\n with Java, Clojure and functional programming, persistent data\n structures, concurrency semantics, references, transactions, software\n transactional memory, agents, implementation and pain points.\nRich Hickey自身によるClojureのプレゼンテーションビデオの中でもスライドショーが同期しながら見れるのはこれだけだと思う。また、Clojure自体の紹介が軽めに抑えてある。\n私のように、Clojureの並列処理部分よりもJava連携やLispの拡張自体に興味があるような人にも見てもらいやすいと思う。\nこれを見るとやっぱり、配列とかをLispの構文に組みこんでしまっている点が気になる。\n こんなやつ\n(drop 2* 1 2 3 4 5*) -&gt; (3 4 5)\n\nMapなら、こう書くらしい(Rubyで言うところのHash)\n(def m {:a 1 :b :2 :c 3})\n\nこれを入れてしまうかどうかが一つの分かれ道かも。",
    "url": "/2009/7/13/2009-07-13-post/"
  },
  {
    "id": "2009-07-16-post",
    "title": "Rubyとの連携を考える(2)",
    "date": "2009-07-16",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-07-16-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nRubyの世界へのアクセス手段として引きつづき .(ドット)オペレータを考えてみる。\n\nリードマクロにこだわらずに考えてみる\n要するに、LispからRubyに変換された時、instance.memberとかClass.memberという式に変換されるためにはどうなっていれば良いかだけを考えればいいのかな？\nLispのリードマクロの範囲で出来るかどうかは置いといて順に考えてみる。\n例えば、\n(. Date new)\n\nは、Rubyの次の式に相当する\nDate.new\n\nその流れでいくと、引数が指定された時は、次の様になるだろう。(リードマクロのsplicingはしないという流れです)\n((. Kernel printf) &quot;%d&quot; 100)\n\n対応するRubyの式\nKernel.printf( &quot;%d&quot;, 100 )\n\nそして、.(ドット)が2個登場するパターンは、.(ドット)に続いてシンボルをたくさん並べてもいいのかも。\n(. (. array sort) reverse)\n\n↓\narray.sort.reverse\n\n(. array sort reverse)\n\n↓\narray.sort.reverse\n\n応用編として .(ドット)が3個登場する呼びだしのパターンを書くと\n((. str split sort reverse))\n\n↓\n(str.split.sort.reverse)\n\nとなる。\nこれでも良い気がしてきた。が、後述のドットペア問題も残っているのだった...\nset!も同様に処理可能かも\nset!による代入\n(set (. a b) 1)\n\nこれはコンパイルされた時にRubyの代入に変換される。\na.b = 1\n\nドットペア問題\nshiroさんにも指摘頂いた、このコードがどうなるかを考えておかないと行けない\n(foo . bar.baz)\n\n単順にリーダで変換をかけると、次の様に変換される\n(foo . (. bar baz))\n\nそれは、すなわちS式のセマンティクスで考えると、これと等価なのだ\n(foo . bar baz)\n\nうわー、たまたまドットを使っているせいでどちらのドットが残ったのかわかりにくいかも知れないが、実は2個目のドットがドットペアに置き換わったのだ。\nうーん、まぎらわしい...\nしかし、一応ドットの後ろにシンボルが2個以上続くので syntaxエラーになる。これでいいのか？(多分、この形式がmacroの展開形に出てきた場合は、なにが起きているのか分かりにくい問題になるだろう。)\nさらに最低限syntaxエラーになるようにガードするためには、\n.read\n\nは、内部で\n(. nil read)\n\nもしくは\n(. Kernel read)\n\nに変換して、必ず引数を2個以上にやる必要があるだろう。\n今の感覚では、これでいいんじゃないかなぁと思っている。\n記述しやすいかどうかはある程度の量のサンプルコードとか実用コードを書いてみないとわからん感じがするぞ。\n※ 最後に、なるべく (. a b) という形式をサポートしたい理由は、例えば Rubyのメンバ変数をメタプログラミングで一気にいじりたいという場合に macro展開形で(. a b) 形式で扱えた方が便利だと考えているから。",
    "url": "/2009/7/16/2009-07-16-post/"
  },
  {
    "id": "2009-07-21-post",
    "title": "Rubyとの連携を考える(3)",
    "date": "2009-07-21",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-07-21-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nRubyの世界へのアクセス手段として引きつづき .(ドット)オペレータを実装してみた。 \n\n (ここに書いた仕様はおそらく後日変わると思うので注意)\n実際にコードを書いてみると何か違う\n(. a b) は Rubyのa.bという式に起きかえられるという単純なルールにしてみた。\n以下は、実際の動作。\nnendo&gt; (macroexpand '(. Kernel open))\nKernel.open\nnendo&gt; (macroexpand '(. a size))\na.size\nnendo&gt; (macroexpand '(. (. a size) to_s))\na.size.to_s\nnendo&gt; (macroexpand '(. (. a size) to_s (. to_s to_i)))\na.size.to_s.to_s.to_i\nnendo&gt; (set! str &quot;str&quot;)\n&quot;str&quot;\nnendo&gt; (. str size)\n3\nnendo&gt; str.size\n3\nnendo&gt; (+ (. str size) 1)\n4\n\n何が問題か\n問題は . (ドット)の第一引数にインスタンスが指定できないこと。\nnendo&gt; (define a &quot;str&quot;)\n&quot;str&quot;\nnendo&gt; a\n&quot;str&quot;\nnendo&gt; (. a size)\n3\n\nここまでは良い。が、\nsymbolまたは (. symbol symbol ...) しか受けつけない様にしているので\n例えば、次のようなコードは書けそうで書けない。\nnendo&gt; (. &quot;str&quot; size)\ndot-operator requires symbol, but got str\n from ./init.nnd:292\n from ./init.nnd:267:in `initialize'\n .\n .\n (略)\n\nnendo&gt; (. 3 to_s)\ndot-operator requires symbol, but got 3\n from ./init.nnd:292\n from ./init.nnd:267:in `initialize'\n .\n .\n (略)\n\nRubyを知っている人は、文字列などのリテラルを第一引数に指定したくなるだろうなあ。\n制限がきつすぎるのかな。もうちょっと考えてみよう。\nwith-openを実装してみた\n早速、 . (dot-operator)でRubyのライブラリを呼びだす例として、with-openを作ってみた。\n使いかたは (with-open 手続き ファイル名) または、 (with-open 手続き ファイル名 openメソッドのオプション) と言う形式で記述する。\nイメージはSchemeの with-input-from-file でいう with-系のユーティリティで、オープンしたRubyのFileオブジェクトを引数として手続きpredを呼びだす。\nまた、手続きpredの呼出後に、ファイルをクローズしてくれる。\n(define (with-open pred . lst)\n (let1 len (length lst)\n (let1 f (cond\n ((= 1 len)\n (Kernel.open (car lst)))\n ((&lt; 1 len)\n (Kernel.open (car lst) (cadr lst)))\n (else\n (error &quot;with-open requires 1 or 2 arguments&quot;)))\n (let1 result (pred f)\n (f.close)\n result))))\n\n実際に動かした。 \nt.txtにはこんなテキストデータが入っている場合、\nbash-3.2$ cat t.txt\nline1_A line1_B line1_C\nline2_A line2_B line2_C\nline3_A line3_B line3_C\n\nこのコードを実行すると\n(with-open\n (lambda (x)\n (map\n (lambda (x)\n (x.chomp.split.to_list))\n (x.readlines.to_list)))\n &quot;t.txt&quot;)\n\n結果はこうなる。\n((&quot;line1_A&quot; &quot;line1_B&quot; &quot;line1_C&quot;) (&quot;line2_A&quot; &quot;line2_B&quot; &quot;line2_C&quot;) (&quot;line3_A&quot; &quot;line3_B&quot; &quot;line3_C&quot;))\n\nそれにしても .to_list が毎回必要なのがカッコワルイか。\nそれと、引数の順番は (with-open ファイル名 手続き openメソッドのオプション) の方がいいかもしれない。",
    "url": "/2009/7/21/2009-07-21-post/"
  },
  {
    "id": "2009-07-22-post",
    "title": "コードの世界 読了",
    "date": "2009-07-22",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-07-22-post.md",
    "content": "やっと全部読んだ。本当にすばらしい本。\nこれだけの内容が1人の人間の手で一冊にまとまっているというのは奇跡だとおもう。\nRubyの解説本では無いけれど、読み終わったころには、Rubyの設計思想や優位性が理解できているという副作用もある。\n読後は、Rubyでプログラムが書きたくなるかも。\n私もS式中毒にかかってなかったら、この本を読んだ後は、プライベートなコードもRubyを使うことになっただろう。\nところで、私が一番知りたかったのは、クラスベースのオブジェクト指向と総称(Generics)ベースのオブジェクト指向の比較だが、そこまでの解説はなかった。\nなんかこの本に書かれていたような気がして、最初から探してみたがそのような話題はなかった。\nどんな本を探せば載っているのだろう。",
    "url": "/2009/7/22/2009-07-22-post/"
  },
  {
    "id": "2009-07-23-post",
    "title": "トム・デマルコも誤りを認める",
    "date": "2009-07-23",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-07-23-post.md",
    "content": "「測定できないものは制御できない｣は誤りだった。-- by Tom Demarco：An Agile Way：ITmedia オルタナティブ・ブログ\n この記事のなかで、例えば、GoogleEarch や Wikipedia といったソフトウェ\n アが、果たして計測と制御という管理で作られただろうか、と問うている。そ\n して、２つの種類のプロジェクトを例にし、\n• Project A: 100万ドルのコストを使って 110 万ドルの価値を作る。\n • Project B: 100万ドルのコストを使って 5,000 万ドル以上の価値を作る。\n「計測と制御」は、Project A の世界では有効だが、Project B の世界ではほ\n とんど意味をなさない、と指摘している。これは、ソフトウェア開発という活\n 動には「計測と制御」よりもっと大切なことが多く含まれており、その中では、\n 「工学」の概念は「ポイントを外している」ということだ。\n私がいま仕事でやっているような業務系Webアプリケーションは、Project Aに\n入るのだけれど、Project Bのような要素も柔軟に取入れることで、高い価値が\nつくれないかなと、いつも考えている、がなかなか答えはでない。\nトム・デマルコも成果物の価値で考えると「工学」の狭い世界でチマチマ考え\nてもたいした成果はでないと考え始めたのかな。\nあの、トム・デマルコが？という感じ。\nこれまでトム・デマルコ信者だった品質保証部門の人とかはどんな気分なんだ\nろう...\n追記\nこの記事を読むと、私が前述のブログ記事のタイトルに釣られていた可能性大。反省...\n アジャイルは二度死ぬ(Agile Only Live Twice)その１：トム・デマルコ氏の蹉跌とその誤謬 | AnyProjecTa! プロジェクト・マネジメントに関する情報ポータル",
    "url": "/2009/7/23/2009-07-23-post/"
  },
  {
    "id": "2009-07-25-post",
    "title": "Ruby 1.8と Ruby 1.9の違い",
    "date": "2009-07-25",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2009-07-25-post.md",
    "content": "[Nendo]の文字リテラルの扱いをどうしようかとRubyを調べてみると、Ruby 1.8とRuby 1.9に違いがあることを知った。\n意外と大きな仕様変更なのではないかと思う。\n 先取り！Ruby 1.9.1 (2/3)\n この変更に伴い、いくつか文字列まわりに重要な変更が発生します。\n 例えば、文字の扱いがいろいろと変わります。従来、文字列に対して「\n String#n」とすると、バイト列のn番目の数値が返ってきました。つま\n り、\"Hello\"0は72を返す、といった具合です。しかし、今後文字列はエ\n ンコード情報を保持しますので、\"Hello\"0は\"H\"という1文字を返すよう\n になります。\nRuby 1.8では数値を返す。\n$irb\n&gt;&gt; ?a\n?a\n=&gt; 97\n&gt;&gt; ?a.class\n?a.class\n=&gt; Fixnum\n\nRuby 1.9では文字列1文字を返す。\n$ irb\nirb(main):001:0&gt; ?a\n?a\n=&gt; &quot;a&quot;\nirb(main):002:0&gt; ?a.class\n?a.class\n=&gt; String\n\n[Nendo]の世界では、文字リテラルというのは無くして、1文字の文字列で代用出来るんじゃないかと思っている。\n[Nendo]の処理系自体は、Ruby 1.8とRuby 1.9で動くようにしたいので、Nendoのユーザはこの差は意識しなくても良いはずだ。",
    "url": "/2009/7/25/2009-07-25-post/"
  },
  {
    "id": "2009-07-26-post",
    "title": "Let Over Lambda",
    "date": "2009-07-26",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-07-26-post.md",
    "content": "まだ買っていないのだけれど...\nAmazonの商品説明より\n Let Over Lambdaは世にある中でも最も過激なコンピュータプログラミング書籍\n の1つだ。基礎から始まり、最も高度な言語、すなわちCommon Lispの最も高度\n な機能を説明する。トップ1%のプログラマだけがLispを使う。そして本書を理\n 解すれば、そのLispプログラマのトップ1%になるのだ。本書は、プログラムを\n 書くプログラムであるマクロに関するものだ。マクロこそが、Lispを世界で最\n も偉大な言語たらしめているものなのだ。正しく使えば、驚くべき抽象化の技\n 法、プログラマの生産性、コードの効率、そして他所では耳にすることすらな\n いようなセキュリティをもたらしてくれる。マクロは、他の言語では全く不可\n 能なことを可能にしてくれるのだ。\nLOLの内容を理解すれば、1% x 1%で10000分の1のプログラマになれるそうな。\nOn Lisp \n聞く所によると、On Lispよりも過激なんだそうな。\n全部理解できればプログラムの世界がどんな風に見えるのだろう。\n[Nendo]を作りながら読むと、ただ読むだけではつかめないマクロのパワーを実感できるので、マクロ本を読むのは今がチャンスなんだろう。",
    "url": "/2009/7/26/2009-07-26-post/"
  },
  {
    "id": "2009-07-27-post",
    "title": "Nendoの初期化ライブラリの階層構造",
    "date": "2009-07-27",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-07-27-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\n今回は自分用のメモ。\n[Nendo]の初期化ライブラリ init.nnd の階層構造\n一段下位の部品を使って一段上位の部品を構成している。\n 名前の色は赤色がmacroで、青色が関数を示す。\n\nこの図を見ると、初期化ライブラリはコードの再利用率が高いことが分かる。\n反対に、実行効率という視点で見ると、マクロ展開のオーバーヘッドが多いため、実行効率が非常に低い。\n[Nendo]はマクロの練習と、言語デザインの練習が目的なのでこれでいいのだと思っているのだが。\nこの図は、リファクタリングの影響範囲が調べやすくて良い。もっと早く描いておくべきだったか。",
    "url": "/2009/7/27/2009-07-27-post/"
  },
  {
    "id": "2009-08-01-post",
    "title": "次はアプリを試作してみよう",
    "date": "2009-08-01",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-08-01-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nさて、[Nendo]をどういう方向に持って行こうか考えているのだが、考える前にNendoで簡単なアプリを作ってみようと思い立った。\nそうすれば、自分が言語に期待するものがわかるんじゃないか。\n最初に作ろうと思っているのは、パッケージマネージャソフト Stowのラッパー。\n昔、Cmmiというパッケージマネージャのラッパーを作ったけど、ちょっと自分のパッケージ管理のユースケースに合わなくなってきた。\n今は無理矢理CmmiとStowの組合せでやっているけど、ちょっとめんどくさい。\nもっとStow専用にして、スムースに使えるものがいい。\nこんな風に使いたい。ツールの名前はstowspecがいいかな。\n ソースアーカイブを引数に渡すと自動的に ~/stowspecに登録してくれる\n$ stowspec http://www.example.com/hogehoge-1.2.3.tar.gz\n$ cd ~/stowspec\n$ ls \nhogehoge-1.2.3\n\nspecファイルがS式になっていて、さっきのコマンドで自動生成されている\n$ cd ~/stowspec/hogehoge-1.2.3\n$ cat specfile\n\n(stow\n (configure &quot;configure --prefix=/usr/local/stow/hogehoge-1.2.3&quot;)\n .\n (略)\n .\n\nspecファイルがカレントディレクトリにあれば /usr/local/stow/ へのインストールまでは全く考えなくても良い。\n$ cd ~/stowspec/hogehoge-1.2.3\n$ stowspec\n 以下、 configure, make, make install の全プロセスが走る。\n .\n .\n\nこうすれば、ソースコードからビルドした手順が残せたり、同一ソフトの複数バージョンを混乱無く管理できそう。\n他にも実現したいことは、\n- ~/stowspec 以下をgitで管理したい。そのためには、~/stowspec 以下にはspecファイル以外は置きたくない。\n- --prefix指定がちゃんと動かないtarボールを発見してエラー通知したい。\n- インストールターゲットごとに、ビルド条件を変えたい。(そこはS式なのでifとかcondとか使って自由自在)\nかな。\n今の[Nendo]の機能では不足がありすぎるだろうから、随時構文を追加したり、デザインを見なおしたりしながら進めようと思う。",
    "url": "/2009/8/1/2009-08-01-post/"
  },
  {
    "id": "2009-08-05-post",
    "title": "次はアプリを試作してみよう(2)",
    "date": "2009-08-05",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-08-05-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\n先日書いた通り、Stowのラッパーを[Nendo]で書いている。\n実際にアプリを書いてみると、日常的に自分が使う構文やユーティリティが足りないことがわかる。\nまず、assoc系の関数が全く無いのでいきなりつまづいた。\nそれからGaucheでのプログラミング時に自分がよく使う、let* と case、それに cond の clause節の =&gt; が欲しい。\n一方、Rubyのライブラリを簡単に呼び出せるので、カレントディレクトリを求めたり、指定パスのファイルリストを求めたりするような実用的な操作には困らず意外と実用的なツールが作れることが分かった。\n言語処理系で退屈でしんどい部分であるライブラリ開発を回避したかったので、この点は早めにRuby連携を実装したのは成功かも。",
    "url": "/2009/8/5/2009-08-05-post/"
  },
  {
    "id": "2009-08-18-post",
    "title": "次はアプリを試作してみよう(3)",
    "date": "2009-08-18",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-08-18-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]の開発状況続き。\nlet* と case と condの (text =&gt; expr) 形式をサポートした。\nあとは、assoc系のユーティリティを作ったら、本格的にstowspecのプログラミングに戻ろうと思う。\nさて、stowspecの抜粋を紹介しよう。\n例えば、xxxx.tar.gz から .tar.gzを外した部分(basename)を求めるプログラムは次の様に書けるようになった。\n;; `regex' is a string ( not a regex object )\n;; returns ( $0-string $1-string $2-string $3-string ... )\n(define (regex-match regex str)\n (let1 matchdata ((. str match) regex)\n (if matchdata\n (matchdata.to_a.to_list)\n nil)))\n\n(define (tgz-to-basename tgz)\n (define archive-file-pattern &quot;(*a-zA-Z*.*)&quot;)\n (cond\n ((regex-match (+ &quot;^&quot; archive-file-pattern &quot;(.tar.gz|.tgz|.tar.bz2)$&quot;) tgz)\n =&gt;\n (lambda (m)\n (second m)))\n (else\n nil)))\n\n;; test\n(list\n (tgz-to-basename &quot;abc-1.2.3.tar.gz&quot;)\n (tgz-to-basename &quot;abc-1.2.3.tar.bz2&quot;)\n (tgz-to-basename &quot;abc-1.2.3.tgz&quot;)\n (tgz-to-basename &quot;file.txt&quot;))\n\n結果は、以下の通り。\n(abc-1.2.3 abc-1.2.3 abc-1.2.3 nil)\n\nregex-matchが返すmatchdataの取りまわしがcond で自然に書ける様になった。",
    "url": "/2009/8/18/2009-08-18-post/"
  },
  {
    "id": "2009-08-19-post",
    "title": "Clojureのビデオを見る(3)",
    "date": "2009-08-19",
    "categories": [
      "Lisp"
    ],
    "file_path": "_posts/2009-08-19-post.md",
    "content": "Classベースのオブジェクト指向とGeneric関数指向の違いについてRich Hickey氏の言及がある。\n InfoQ: Rich Hickey on Clojure's Features and Implementation\nQ. Moving on to another feature that brings polymorphism to Clojure,\n multimethods to an object oriented programmer, how would you explain\n multimethods?\nA. When you think about polymorphism, generally you are\n thinking about some Runtime dispatch. Something different happens at\n Runtime, depending on some characteristic of the object. It ends up\n that in object oriented programming languages like Java and C#, there\n is only one thing that can be a criteria for something different\n happening and that's the class or type of the object. A general way of\n thinking about that is saying you have a method call and it involves\n an object and some arguments and the actual dispatch is going to\n differ, depending on the type of this.\nYou can generalize that and that was done in common Lisp to say it\n might be interesting to have things be polymorphic based upon more\n than just the first arguments. So, we are no longer considering the\n first arguments to be special and we'll allow you to take some call\n and look at all the arguments and do something based upon all the\n arguments. There too, though, there are some things that are\n hardwired, for instance, in common Lisp you can only dispatch on\n either the type of arguments or their values. You can say \"If it's\n equal to this or if it's of this type do this\", but you can do it for\n any or all the arguments. Again, we are talking about dispatch based\n upon some function of the arguments.\nそうかそうか。メソッドディスパッチのレベルが違うのか。\nJavaやC#のようなClassベースのオブジェクト指向の場合、メソッド呼び出しが実際にどの実体にディスパッチされるはClassかオブジェクトの型で決まる。\n例)\nClass::method1(a,b,c)\nanObject.method1(a,b,c)\n\n2番目の例について構文をLispっぽく記述したとしたら、こうなる。\n(method1 anObject a b c)\n\nここで、method1が複数定義されている場合、Javaでは第一引数のanObjの型だけでどのメソッドが選択されるかが決まる。\n一方、Common LispのようなGeneric関数指向では第一引数だけでなく全ての引数の型のマッチングで総合的に決まる。\nメリットはJavaやC#のような強い依存度が無くなるということ。\nうーんそういう視点は無かった。うんうん。\n直接の関係は無いけど、戻り値に多値が使えるか使えないかで言語の適用範囲が広がるのと似たような感覚がある。",
    "url": "/2009/8/19/2009-08-19-post/"
  },
  {
    "id": "2009-08-21-post",
    "title": "[util.match](http://practical-scheme.net/gauche/man/gauche-refj_163.html)ってNendoで動くのかな",
    "date": "2009-08-21",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-08-21-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nGaucheにバンドルされている util.match (Andrew Wrightのパターンマッチライブラリ) のソースをざっと見てみた。\nそんなにSchemeの特殊な機能を使っていないので、いつかNendoでも動かせるんじゃないかと思った。ちょっと甘いかな。\nこのライブラリは本当に強力でRubyにはなかなか真似できない部分なので[Nendo]で動かしたい。",
    "url": "/2009/8/21/2009-08-21-post/"
  },
  {
    "id": "2009-08-24-post",
    "title": "扇風機のユーザインタフェースをマジックでグリグリ改善した件",
    "date": "2009-08-24",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2009-08-24-post.md",
    "content": "うちにある扇風機が余りにも使いにくいので、早速マジックでUI変更。\nこの扇風機のひどい所は、本来の『運転(入/切)』よりもionの『(入/切)』のほうが目立つ様にデザインされていること。\nさらにひどいのは、コードを接続して『いざ扇風機をON!』と一番目立つ緑色のボタンを勢いよく押しても何もおきないこと。\n正確にはionがONになっていることを主張する緑色のランプが点灯するだけで、肝心のファンは回ることはない。アホかー！\n\nそもそもイオンというモノ自体が迷信に限りなく近い代物なのにそれをスイッチにしてしまうかなぁ。\nとまあブツブツ言いながら、この本の前書きを読み返してみたりして。\n誰のためのデザイン?\n まわりを見回してみてください。私たちのまわりは、暮らしを過ごしやすく、\n より楽しいものにしてくれるたくさんの工業製品であふれています。本、台所\n 用品、電話、そして、テレビ、ゲーム、家庭用や事務用のコンピュータ。とこ\n ろが、その多くが私たちの暮らしのいらいらの種となっているようです。暮ら\n しは、過ごしやすくなるどころか、難しくなっています。あなたの暮らしは必\n 要以上に複雑なものとなっているようです。\n(略)\n もう事態を変えるべきです。消費者は反乱を起こすべきときです。私たちの暮\n らしがこんなに複雑である必要はありません。この問題はあなたのせいではあ\n りません。このひどい製品を作ったデザイナーとメーカーのせいです。とはい\n え、あなたのせいでもあります。こんなにいらいらさせるような製品をなぜ買\n いつづけたのでしょう。\n『こんなにいらいらさせるような製品をなぜ買いつづけたのでしょう。』の部分にちゅうもーく。\nって、こんなものを買ってしまう消費者、つまり自分も悪いのだ。\nすいませんすいません。本当にすいません。",
    "url": "/2009/8/24/2009-08-24-post/"
  },
  {
    "id": "2009-08-25-post",
    "title": "ラーメン屋 vs.マクドナルドを読む",
    "date": "2009-08-25",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-08-25-post.md",
    "content": "マスコミでよく喧伝されるような、日本人はアメリカ人に比べて創造性が無いとか、リスクを取りたがらないとかいうのは、日本人の気質の問題ではなく制度の問題だということを統計データを引きながら解説してくれる良書。\nこの本の結論としては日本が復活するためには、政治の力に期待するしかないということになっているが、もしそうだとしたらなかなか出口は見えないのではないか。\nとりあえずは選挙に行こう。\nそして、ミクロな視点では自分の得意分野にとことん投資し続けよう。",
    "url": "/2009/8/25/2009-08-25-post/"
  },
  {
    "id": "2009-08-26-post",
    "title": "On Lisp読了",
    "date": "2009-08-26",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-08-26-post.md",
    "content": "一回では理解できなかったので、『継続』の章や『オブジェクト指向Lisp』の章は2回以上は読んだ。\nしかし、call/ccは使ったことないのでなかなかイメージしずらい。反対にCPS変換は実際に使っているので理解できた。\nやっぱり、実際にプログラミングを続けながら、繰返し読むことが大事だな。\n[Nendo]を開発しつつ、次は",
    "url": "/2009/8/26/2009-08-26-post/"
  },
  {
    "id": "2009-08-31-post",
    "title": "[LLTV](http://ll.jus.or.jp/2009/)を見てきた",
    "date": "2009-08-31",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-08-31-post.md",
    "content": "朝まで生テレビが一番おもしろかった。\nパネリストの3人の話を聞いていると、現状のLLというのがコンピューティングのあるレイヤーを担っているだけのチッポケな存在だということを感じた。\n但し、LLは人間にとって、より高い表現力を手に入れる為の進化をつづけており、より簡潔な表現でプログラムを構築するという意味では非常に重要なポジションを担っている。\n最近では、並列化に対する要求が高まっており、LLが並列処理の記述を自然にサポートする時代が来るのだろう。\n今はその過渡期なので、いろんな言語が並列化表現に挑戦しては新しい発見をしていくだろうと思う。\n何かちょっと未来が垣間見れてよかった。\n[Nendo]も一応並列化の実験アイデアが色々あって、つらつら考えているところ。\nそれにしても、東京大阪間を日帰りはつらいよー。",
    "url": "/2009/8/31/2009-08-31-post/"
  },
  {
    "id": "2009-09-02-post",
    "title": "オレオレ参照透明性というアイデア(immutable宣言)",
    "date": "2009-09-02",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-09-02-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nimmutableというスペシャルフォームで副作用なしを宣言するプログラミングスタイルはどうだろうと考えている。\n\nまだ、どのような仕様にするか全然見えてないけど、どんなことが実現したいかという考えは大体ある。\n\nimmutable宣言した範囲では副作用が無いかチェックしてくれる\nimmutableなコードを塗りつぶすというようなイメージ。\nimmutableなコードから、mutableなコードを呼びだすとエラーとなり、その発生ポイントも同地に報告してくれる。\n\nimmutable宣言した範囲は自動的に並列実行できる\n例えば、mapが取る手続とリストの両方についてimmutableしか受けつけないが、for-eachはmutableも受けつけるとか。\nmapとfor-eachの違いはそれだけに留まるようなイメージ。\nそうすれば、処理系はmapで受けた要素同士は独立性が確保されていると判断できるので、結果、並列実行が可能となる。\n\nまた、Rubyのライブラリを使った時にもこのルールが機能するように、Rubyのライブラリロード時にもimmutable宣言したいメソッドリストが指定できるとかできないか。\n問題は、immutableだと信じた範囲を自分で宣言する所で、例えばHaskellをやっているような人には受けいれられないだろうけど、Lisp系言語には合った実践的な方法かなと思っている。\nまあ、プログラマが自己判断で宣言するところが曲者で、実際には使いものになるのかは不明。\n他の言語で似たようなアイデアを持ったものないのかな。もっと勉強しないと。",
    "url": "/2009/9/2/2009-09-02-post/"
  },
  {
    "id": "2009-09-07-post",
    "title": "最近読んだ本。(佐々木氏の本、他)",
    "date": "2009-09-07",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-09-07-post.md",
    "content": "なかなかコンピュータをさわる時間はあまり無いけど、電車に乗っている時間が有るので本だけは読める。\nというわけで最近読んだ本。\n上の、佐々木氏の二冊は未来はこうなるのだ!と煽りすぎのような気がする。\nが、ユーザーのメディアを消費する手段は変化しつづけ、コストも下がり続けているので、うかうかしていると本当にすごいスピードでマスメディアが無くなってしまうかもしれない。\nそうなっても自分の生活は変わらないけれど、経済の世界では間接的にいろんな変化を見れるだろうから楽しみだ。\nJoel本はWebでも読めるのだけれどもまあ、本の方が読みやすいので買った。\nソフトウェア開発に関する示唆に富んだ話が沢山あり、読んでおくとムダな個人サービスを作って人生の貴重な時間をムダにしなくて済むなあと思った。\nこれは人月で仕事をしていない人は読んでおいた方がよい本だよねー。",
    "url": "/2009/9/7/2009-09-07-post/"
  },
  {
    "id": "2009-09-09-post",
    "title": "Google App Engineとかやってみたい",
    "date": "2009-09-09",
    "categories": [
      "クラウド"
    ],
    "file_path": "_posts/2009-09-09-post.md",
    "content": "最近やってみたいばっかりで自由な時間がない。\nクラウドサービス楽しそう。KVSデータベース楽しそう。いつか遊んでみたい。",
    "url": "/2009/9/9/2009-09-09-post/"
  },
  {
    "id": "2009-09-11-post",
    "title": "プログラミング言語Lua公式解説書",
    "date": "2009-09-11",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-09-11-post.md",
    "content": "プログラミング言語デザインの学習の足しになりそうなので1冊買っとこう。\nプログラミング言語の作者自身が書いた本は貴重なので、見つけたらできるだけ買っときたいものだ。\n時々、言語デザインのトレードオフについて書かれていることがある。\n特に有用な情報としては、実際には採用しなかった案と、採用しなかった理由が書かれている場合だ。\nそんなことは言語デザイナ本人しか知らないからねぇ。\n\nコメント by Neyra:\nThat's a crackerjack answer to an interesting qeuiston",
    "url": "/2009/9/11/2009-09-11-post/"
  },
  {
    "id": "2009-09-12-post",
    "title": "Pythonのlambda",
    "date": "2009-09-12",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-09-12-post.md",
    "content": "Pythonのlambda - 西尾泰和のはてなダイアリー\n The fate of reduce() in Python 3000\n Why drop lambda? Most Python users are unfamiliar with Lisp or\n Scheme, so the name is confusing; also, there is a widespread\n misunderstanding that lambda can do things that a nested function\n can't\n このあたりかな。つまり、まずもって大部分のPython使いはLispに不慣れだし、\n 「lambdaじゃないとできないことがある」という誤解の元になる(実際にはネ\n ストした関数を作ればいいだけなのでlambdaは必要ない)のでlambdaを削除し\n ようとした、ってこと。\nそうだったのか。\nPythonはlambda式にマルチステートメントが使えないなど、不備が多いなと思っていた。\nそれはどうしようもないなあ。\nちなみに、西尾さんの記事にリンクされているドキュメントは良い。後でちゃんと読もう。\n 言語パターン - 使いやすい言語・ライブラリをデザインする方法 - qwik.jp/lang-pattern",
    "url": "/2009/9/12/2009-09-12-post/"
  },
  {
    "id": "2009-09-14-post",
    "title": "シェルトランポリンの実現方法",
    "date": "2009-09-14",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-09-14-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nシェルトランポリン\n\nNendoはRubyで実装しているので、スクリプトをこんな風に始めることはできない。\n#/usr/local/bin/nendo\n.\n.\n\nRubyのライブラリを静的リンクをすれば出来るけれどそれは大袈裟過ぎるので避けたい。\nGaucheのリファレンスにはこんな方法が紹介されている。\n Gauche ユーザリファレンス: 3.3 Schemeスクリプトを書く\n典型的なGaucheスクリプトの最初の行は次のようなものです。\n (略)\n #!/bin/sh\n :; exec gosh -- $0 &quot;$@&quot;\n\nよし、パクろう。(笑)\nと思ったが、':' に何か特別な仕組みを持たせないといけないのかも。ちょっと調べてみた。\nGaucheの ':' は？\nさっそく実験。まずはgosh\nbash-3.2$ gosh\ngosh&gt; :\n:\ngosh&gt; (if : 1 2)\n1\ngosh&gt; (symbol? 'a)\n#t\ngosh&gt; (symbol? ':)\n#f\ngosh&gt; (set! : 1)\n*** ERROR: Compile Error: syntax-error: malformed set!: (set! : 1)\n&quot;(stdin)&quot;:5:(set! : 1)\n\nうわー、これは何なんだ。よくわからんけど、単体で評価しても無害なようだ。\nまた、':' は破壊できないようだ。\nSchemeのR5RSの仕様を調べたら、':' は拡張アルファベット文字といってアルファベットと同格として扱って良いみたいだけど...\nGaucheはちょっと ':' を特別扱いしているのかな。\nなので当然こうなる。\ngosh&gt; :; exec gosh -- $0 &quot;$@&quot;\n:\n\nbashの ':' は？\nbash の':'は常に真を返すコマンドとして有名だ。\nbash-3.2$ :\nbash-3.2$ echo $?\n0\n\nbash-3.2$ while :\n&gt; do\n&gt; date\n&gt; sleep 1\n&gt; done\n2009年 9月14日 月曜日 21時57分49秒 JST\n2009年 9月14日 月曜日 21時57分50秒 JST\n2009年 9月14日 月曜日 21時57分51秒 JST\n2009年 9月14日 月曜日 21時57分52秒 JST\n C-c C-c (中断)\n\n結論\nGaucheのように単に無害な ':' を実装すればよいのかもしれない。\n今度実際にやってみよう。\n\nコメント by 齊藤:\nGauche では ： を先頭につけた識別子はキーワードとして扱われます。\n単体の : でもキーワードとして認識されるようですね。\n(keyword? :) は #t になります。\nr5rs には無い Gauche 特有の機能ですので、Gauche のマニュアルを見て下さい。\n\nコメント by kiyoka:\nコメントありがとうございます。\n先日、Chaton上でlequeさんにも教えてもらいました。\nGaucheは純粋なSchemeからうまく拡張されていて実用レベルを保っているんだと思いました。\nただ、Nendoにはまだキーワードは入れずにいこうかなと思っています。\nコメント by 齊藤:\nGauche では ： を先頭につけた識別子はキーワードとして扱われます。\n単体の : でもキーワードとして認識されるようですね。\n(keyword? :) は #t になります。\nr5rs には無い Gauche 特有の機能ですので、Gauche のマニュアルを見て下さい。",
    "url": "/2009/9/14/2009-09-14-post/"
  },
  {
    "id": "2009-09-15-post",
    "title": "シェルトランポリンの実現方法2",
    "date": "2009-09-15",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-09-15-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n\nNendo特有の実現方法としてNendoはtrueというRubyの予約語をそのまま持ちこんでいるので、次の様なシェルトランポリンが書ける。\n#!/bin/sh\ntrue; exec /usr/local/bin/nendo &quot;$0&quot;\n\n;;-*- mode: nendo; syntax: scheme -*-;;\n(print (+ &quot;abc&quot; &quot;def&quot;))\n\n但し、Gaucheの :; 方式に比べて true; 部分がちょっと目立つけど...\nまあ、とりあえずはこれでいいや。",
    "url": "/2009/9/15/2009-09-15-post/"
  },
  {
    "id": "2009-09-24-post",
    "title": "Ruby 1.8.x対応を見送った",
    "date": "2009-09-24",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-09-24-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n[Nendo]でmapをネストして2重ループを形成すると変な動作をする。何だこれは。\nクロージャのレキシカル変数の内容がどんどん破壊される。\n小一時間ほど追いかけた結果、Ruby 1.8.xのクロージャの問題だということが発覚した。\n結論としては、Ruby 1.8.xのクロージャはレキシカルクロージャではないことを自分が忘れていたのが問題。... \n[Nendo]のlambdaはRubyのクロージャにそのままマッピングするようになっているため、Rubyのクロージャがレキシカルクロージャでない限り[Nendo]のlambdaが正常に動かないのも当然だった。\nちょっとテストとしてはわかりにくいかも知れないが、こんなRubyコードで実験した。\n#!/usr/local/bin/ruby\n\nlambda1 = lambda { |val|\n printf( &quot;(0) = %s\\n&quot;, val )\n val = 'A'\n printf( &quot;(1) = %s\\n&quot;, val )\n lambda2 = lambda { |val|\n printf( &quot;(2) = %s\\n&quot;, val )\n }\n lambda2.call( 'B' )\n printf( &quot;(3) = %s\\n&quot;, val )\n val\n}\nlambda1.call( 'START' )\n\nRuby 1.9.2devでは期待通り\n\n$ ruby --version\nruby 1.9.2dev (2009-07-18 trunk 24186) *powerpc-darwin9.5.0*\n$ ./t.rb\n(0) = START\n(1) = A\n(2) = B\n(3) = A\n\n(3)の箇所で値 'A' が保持されている\n\nRuby 1.8.7では...\n\nbash-3.2$ ruby --version\nruby 1.8.7 (2009-06-12 patchlevel 174) *powerpc-darwin9.5.0*\nbash-3.2$ ./t.rb\n(0) = START\n(1) = A\n(2) = B\n(3) = B\n\n(3)の箇所で値 'B' になる。\nRuby 1.9.2がもうすぐ正式に出る時期なので、まじめにRuby 1.8.xでも動く様にするのはあきらめよう。\nちなみに、JRubyとかはどっちなんだろう。今度確認しよう。",
    "url": "/2009/9/24/2009-09-24-post/"
  },
  {
    "id": "2009-10-09-post",
    "title": "gemを公開した",
    "date": "2009-10-09",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2009-10-09-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n\nだいぶ前にgemを公開したのだけど時間が無くてブログ記事を書けなかったので、とりいそぎの記事です。\nインストール方法は[Nendo]を参照して下さい。\nRuby 1.9.2devでしか動かないのでその点だけ御注意下さい。\nまだドキュメントが無いので、現在のNendoでどんなことができるかは、kiyoka's nendo at master - GitHubの中にstowspecというソースコードを参考にして何とかしてもらうしかないです。\n処理系の実装をやっている方の参考になればと思い公開しました。\n当分時間が取れそうにないので、ドキュメント書きなどの作業は進まないと思います。\n追記:\nRoute 477 - github上でのgem生成が終わるそうです(今後はgemcutterで)という記事を見つけた。\nいま公開している[Nendo]のgemは1年保持してくれる様だけど、今後のバージョンアップ時はgemの公開URLが変わるかもしれません。",
    "url": "/2009/10/9/2009-10-09-post/"
  },
  {
    "id": "2009-12-03-post",
    "title": "ついに出たか! Google日本語入力",
    "date": "2009-12-03",
    "categories": [
      "日本語入力"
    ],
    "file_path": "_posts/2009-12-03-post.md",
    "content": "Google Japan Blog: 思いどおりの日本語入力 - Google 日本語入力\nすごい、とうとうGoogle自身が作ったか。\n早速、インストールしてみようとしたが...\n\n自分のMacはPowerPCプロセッサなので試せなかった... orz\n最近はMacといえばIntelなのか...",
    "url": "/2009/12/3/2009-12-03-post/"
  },
  {
    "id": "2009-12-13-post",
    "title": "プログラミング学習リハビリ",
    "date": "2009-12-13",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-12-13-post.md",
    "content": "最近こんな本を図書館でゲットした。\n図書購入依頼していたのが届いた。購入依頼は同時期に届くのがやっかいだなあ...\nProgramming in Luaの方からパラパラとファッション雑誌をめくる感じで斜め読みしている。\nまた言語処理系の実装を再開する日が来た時のために、Luaもひととおり眺めておこうと思って。\nLuaのほとんどの構造は『テーブル』という連想配列のようなデータ構造の上に構築されており、Luaのシンプルさの源になっているようだ。\nPythonの辞書とかJavaScriptのHashのようにオブジェクト指向アーキテクチャの屋台骨として利用されているみたい。\nこういう言語仕様は構造がシンプルになると同時に、黒魔術的な無茶をすればユーザが後からPrototype.jsのようなメタレベルの拡張ライブラリも作れる。\n私はどちらかというと、こちらのスキだらけの構造が好きなので、そういう部分で勉強になる。\n[Nendo]の開発のヒントが沢山詰まっていそう。\nまだちゃんと読んでいないので感想は後日。\nというか読む時間あるかなぁ。",
    "url": "/2009/12/13/2009-12-13-post/"
  },
  {
    "id": "2009-12-23-post",
    "title": "Programming in Lua 読了",
    "date": "2009-12-23",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2009-12-23-post.md",
    "content": "-- 第1部 言語(最初の一歩型と値ほか)\n-- 第2部 テーブルとオブジェクト(データ構造データファイルと永続化ほか)\n-- 第3部 標準ライブラリ(数学ライブラリテーブルライブラリほか)\n-- 第4部 C API(C APIの概要アプリケーションの拡張ほか)\n-- 第5部 付録:Luaリファレンスマニュアル(言語アプリケーションプログラムインターフェイスほか)\nLuaの印象\n読了といっても、言語のコアに関する第一部と第二部だけ読んだ。\nLuaの言語コアはシンプルに保たれており、JavaScriptでいうPrototype.jsのようなメタな拡張ライブラリもLua上に実現できそう。\nLuaもオブジェクト指向機能はプロトタイプベースなのでJavaScriptに近い印象がある。\n記述言語としてのLuaに対する印象は、コアはシンプルだけど、ちょっと込み入ったアルゴリズムを書こうとすると、プログラムが長くなってしまう気がした。\n(本書のサンプルコードの書きかたが冗長なだけで、うまくイテレータ等を使えばもっと短いコードになるのかもしれないが... 解説の流れ上、まだ説明していない機能が突然出てくるのを避けるために、しょうがないのかも知れない)\n収穫\n本書を読んだことによる収穫は、コルーチンの動作がはっきりイメージできたこと。\nいままで、Rubyのyieldを使ったコードは曖昧にしか理解できていなかった。\nRubyの解説書を読んでもかなり端折って説明されているのが常なので、わかりにくかった。\n本書で、コルーチンに関して低レベルのAPIが用意されており、イテレータがその仕組をどのように使って構築されているかを順を追って解説されている。\n言語処理系の実装はめんどくさそう\nいつも、プログラミング言語の解説書を読んで思うことは、実用レベル言語にするためには、モジュールとか例外とかデバッグの仕組みとか地味にめんどくさい所を整備しないといけないのだなあということ。\n[Nendo]という処理系を作って遊んでいるんだけど、その辺の事まで考えると気が遠くなるのであった...\nたとえば、一人でGaucheを全部実装しているshiroさんとかすごいなあと思ってしまう。",
    "url": "/2009/12/23/2009-12-23-post/"
  },
  {
    "id": "2009-12-30-post",
    "title": "『パターン、Wiki、XP ~時を超えた創造の原則』とRuby",
    "date": "2009-12-30",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2009-12-30-post.md",
    "content": "Rubyコミュニティーの方々のプレゼンでたびたび紹介されていた本。やっと読了。\nRuby関連のイベントでこの本が紹介されるのは、XPの発展に貢献したメンバーがRubyのユーザーになって来ていることが原因らしい。\n(SmalltalkとRubyの両方を使っている人が多い？)\nパターン、Wiki、XP ｜gihyo.jp … 技術評論社 より引用\n 著者からの一言\n 筆者は当初Wikiの起源を調べようとしていました。WikiはWeb上のシステムなの\n で，Webが誕生した1991年より前にさかのぼることはないだろうと思っていたの\n ですが，もっと昔の思想と深い関係があることがわかりました。\n Wikiの起源への道のりは，デザインパターンやXPの起源への道のりでもありま\n した。Wiki，デザインパターン，XPは，どれも一つの思想，建築家クリスト\n ファー・アレグザンダーのパターンランゲージを起源としています。さらにそ\n の背後には，建築，知の共有，ソフトウェア開発を貫く「時を超えた創造の原\n 則」がありました。\n 最終的には，1960年代に考え出された思想が源流となっていたことがわかりま\n した。こんなにも昔の思想が形を変えて現在に影響を与えていることに筆者は\n 驚きました。この驚きを伝えたいと思い，本書を書きました。\nWikiシステム[OldType]を実装する前に読んで起きたかった...\nWikiにそんな起源が有るとは知らなかった。もし先に読んでたら、[OldType]はだいぶ違うデザインになっていたかも。\nデザインパターンや、アジャイルに馴染みが有っても無くても、この本は一度は読んでおいて損はないと思う。\n有名なかずあるデザインパターンの利用者という視点から、既存のデザインパターンはたんなるよく練られたテンプレートであり、自分でパターンを作って発展させるという視点もあるということを気づかせてくれる。\nほかにもいろいろあるけど、ブログで書評するにはなかなか難しい本です。\nこの本では言及されていないけど、Rubyの開発コミュニティにも何となく同じ思想が継承されている気がした。\n例えば、Rubyコミッターの方がプレゼンで『Rubyにはえもいわれぬ楽しさがあるので、ぜひ参加してください』という言いかたを頻繁にされているけど、本書で登場する『無名の質』と関係ありそうな気がした。\n『コミュニティーで言語を発展させるプロセスに皆さんも参加することで、住みやすい環境ができます。それに参加しないのはもったいないですよ』というような。\n技術の本では無いのだけど、その根底に流れる思想の本として一度は読んで見てはいかが？\nP.S.\n後でこんなページ見つけた\n『パターン、Wiki、XP』刊行トークセッション［パターン、Wiki、XP ―― 時を超えた創造の原則（WEB+DB PRESS plusシリーズ）］｜gihyo.jp … 技術評論社",
    "url": "/2009/12/30/2009-12-30-post/"
  },
  {
    "id": "2010-01-02-post",
    "title": "2010年の抱負",
    "date": "2010-01-02",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2010-01-02-post.md",
    "content": "開けましておめでとうございます。\n去年の今頃『[kiyoka.2009_01_05] Life 2009年の抱負』で、いろいろ書いたけど、思ったようにはグローバル化は自分の仕事に影響しなかった。\n今年は仕事とプライベートのバランスを取り戻す年にしたい。\nそして、2010年の年末にはハッピーエンドで終わりたいと思っています。あわよくばその時に未来の話が出来るようになっていれば最高かな。\nみなさんの1年も良い年でありますように。",
    "url": "/2010/1/2/2010-01-02-post/"
  },
  {
    "id": "2010-01-11-post",
    "title": "heist:Rubyで実装されたScheme処理系",
    "date": "2010-01-11",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-01-11-post.md",
    "content": "あまり時間が無くて[Nendo]の開発が滞っているが、[Nendo]の他にもRubyでLisp処理系を実装している人がそれなりに居る様なので、順番に見て行きたいと思う。\n手始めとしてheistを調べ始めた。\n作者のブログによると、開発動機は実用目的ではなく勉強目的の様だ。\nSICPを読んでいるうちに一度実装してみたくなったという感じだろう。\n作者のブログには自虐ネタ的なブログエントリもあったり。\n April fool: area man releases world’s slowest Scheme interpreter : The If Works\n勉強の割には、参考にできそうな所がいくもありそう。\nソースが公開されているので、簡潔に実装する方法については参考になるだろう。(まだ細かくはソースを読んでいないが...)\nまず、heistはTreetopというPEGパーサージェネレータを利用していてパーサーが短く書かれている様だ。\n 参考: InfoQ: Treetop-Ruby用のPEGパーサージェネレータ\nこれは[Nendo]にも取り入れたい。[Nendo]はlexerとパーサーをベタで書いているので結構行数を食っているのだ。\n他のプロジェクトの良い所を色々盗もう。\nちなみに、heistという名前はあまり良い名前じゃないなあ。辞書を引いて見たら『強盗』という意味だったんだけど。どういうつもりだろう。",
    "url": "/2010/1/11/2010-01-11-post/"
  },
  {
    "id": "2010-01-14-post",
    "title": "年末に読んだ本",
    "date": "2010-01-14",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-01-14-post.md",
    "content": "年末、約2週間ほど完全に自由の身だった間に読んだ本。あー、この時間は天国だったなあ。\n3冊の本のジャンルはバラバラだけど気にせずに...\n編集者のあとがきに、3000位の名言の中から厳選したと明記してある通り、どの名言も価値がある。そして行動に結びつく名言ばかり。\nたしかに、これまで、ドラッカーの本を数冊読んだけど、どの本のどこのページを切り出しても重みがあると感じていたので拾いだすと3000程度の名言があってもおかしくないか。\n名言のなかでも、個人の得意なこと、強みに集中することが重要であるという指針は肝に命じたい。\n PP. 51\n 『自らの強みに集中せよ』\n 不得手なことの改善にあまり時間を使ってはならない。自らの強みに集中すべ\n きである。無能を並みの水準にするには、一流を超一流にするよりも、はるか\n に多くのエネルギーと努力を必要とする。\nただ、本書全体を通して気になるのは、組織による仕事を前提にした言葉が多い点。\nインターネットが出現して以来、組織の形は変わりつつあると思うが、その場合はそのまま適用が難しいだろうと思う。\nどうやって脳をポジティブ思考に持っていき、幸福になるかという本。\n茂木さんがまえがきを書いていらっしゃるので、もっと脳科学のアカデミックな内容かとおもいきや、後半になるほど若干胡散臭く成りがちで、どちらかというとやわらか系の本。\nさすがに、スピリチュアルな話までは出てこないけれど、いつのまにか神が登場してしまうあたり無神論者な方は引いてしまう可能性あり。\nただ、脳の動きは未だ解明されていない科学なので、ポジティブ思考の方法論としてこのような本が書かれるのは悪くない。\n本書を読みながら、幸福を感じる脳を作りだすという点では『宗教』も良い面があるなと思った。(戦争の引金になる等、もちろん悪い面もあるが。)\njohn lennonの有名な曲『imagine』じゃないけれども...\n図書館の哲学の棚周辺をぶらぶらしていたら目に入った。\n『人気映画を題材に哲学の理論を痛快に解き明かす！』という趣旨の本。\nたしかに哲学書を直接読むよりは、映像化された映画のイメージや表現によって容易に哲学の概念が理解できるような気がする。\n哲学を専門的に追求する必要性の無い、しかし哲学がどのようなものかを知っておきたい私達の様な一般人にはちょうど良いかも知れない。\n結局、時間切れで第3章までしか読めなかったが、スラスラ読めるタイプの本なので、また今度借りて続きを読んでみようと思う。というか、育児で精一杯で本を読む時間なんか今は無いのだけど。\n読書は楽しい。もっと読書したいな。プログラミング系の専門書ももっと読まないと行けないのだけど。\n追記: Grapeさんのコメントで紹介していただいた本を転記。\n(本の背表紙をクリックできます)\n哲学とは？みたいな内容ではないですが、↓この本は面白かったです。\n↓これも入門的な内容ですが、昔読んで面白かったですよー\n\nコメント by Grape:\n哲学とは？みたいな内容ではないですが、↓この本は面白かったです。\nhttp://www.amazon.co.jp/%E3%82%82%E3%81%AE%E3%81%90%E3%81%95%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90-%E4%B8%AD%E5%85%AC%E6%96%87%E5%BA%AB-%E5%B2%B8%E7%94%B0-%E7%A7%80/dp/4122025184/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1263463260&amp;sr=8-1\n↓これも入門的な内容ですが、昔読んで面白かったですよー\nhttp://www.amazon.co.jp/%E7%84%A1%E9%99%90%E8%AB%96%E3%81%AE%E6%95%99%E5%AE%A4-%E8%AC%9B%E8%AB%87%E7%A4%BE%E7%8F%BE%E4%BB%A3%E6%96%B0%E6%9B%B8-%E9%87%8E%E7%9F%A2-%E8%8C%82%E6%A8%B9/dp/4061494201/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1263463410&amp;sr=1-1\n何か現実に役に立つAI作りたいな～と思って、脳とか哲学の本を少しづつ読んでます。\n\nコメント by kiyoka:\nGrapeさん、コメントありがとうございます。\nコメントの一部をブログ本文に転記させて頂きました。\nAmazonのレビューを見て、「ものぐさ精神分析」のほうは読んでみたくなりました。\nAIの夢というのはプログラマなら絶対だれもが持っちゃいますよねー。私も日々、脳科学の本とかを物色しています。\nコメント by Grape:\n哲学とは？みたいな内容ではないですが、↓この本は面白かったです。\nhttp://www.amazon.co.jp/%E3%82%82%E3%81%AE%E3%81%90%E3%81%95%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90-%E4%B8%AD%E5%85%AC%E6%96%87%E5%BA%AB-%E5%B2%B8%E7%94%B0-%E7%A7%80/dp/4122025184/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1263463260&amp;sr=8-1\n↓これも入門的な内容ですが、昔読んで面白かったですよー\nhttp://www.amazon.co.jp/%E7%84%A1%E9%99%90%E8%AB%96%E3%81%AE%E6%95%99%E5%AE%A4-%E8%AC%9B%E8%AB%87%E7%A4%BE%E7%8F%BE%E4%BB%A3%E6%96%B0%E6%9B%B8-%E9%87%8E%E7%9F%A2-%E8%8C%82%E6%A8%B9/dp/4061494201/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1263463410&amp;sr=1-1\n何か現実に役に立つAI作りたいな～と思って、脳とか哲学の本を少しづつ読んでます。",
    "url": "/2010/1/14/2010-01-14-post/"
  },
  {
    "id": "2010-01-15-post",
    "title": "gemをGemCutter.orgに再登録した",
    "date": "2010-01-15",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-01-15-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nGithub.comのgem配布の仕組が廃止になったので、GemCutter.orgにgemを再登録した。\n\nモジュール名もprefix付きのkiyoka-nendoという名前からnendoになり、これでnendoというgem名がNendo言語のものになった。\nこれで、nendoの処理系をインストールするのは超簡単になった。\n手順は[Nendo]に記載した通り、Ruby 1.9.1の環境で、gem install nendo とするだけ。\n少しづつ、自分でアプリを書いたり、リファレンスマニュアル(未整備)を書きながら、使える処理系にしていこう。\nとりあえず、nendoを使てどんなコードが書けるかは、このソースをざっと眺めて見て貰えればと思う。\nsample/stowspec at 473eabbbf23023b619213ded4ad1a76979a7e3f2 from kiyoka's nendo - GitHub",
    "url": "/2010/1/15/2010-01-15-post/"
  },
  {
    "id": "2010-01-16-post",
    "title": "プログラマに比べて、プロ楽器奏者が間違えないのはなぜ？",
    "date": "2010-01-16",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2010-01-16-post.md",
    "content": "自分はキーボード入力でタイプミスする方だと思う。\n一般的にプログラマはキー入力をミスるもんなんだろうか。\nプログラマのみなさんはどうですか？\n\nクラシック音楽のバイオリニストとかピアニスト(特にソリスト)はそんなにミスしてはいけないだろう。\nDVDで見てると、あんまりミスしている様に見えないのは、単に自分がそこまで優秀なリスナーでは無いだけなのかな？\n\n特に、クラシック音楽は譜面通りに演奏することが前提なので恐ろしいと思う。\n演奏家は、基本的な音楽的センス等も必要かも知れないが、それ以上に正確さが要求される職業なんだろうなあとラフマニノフのピアノ協奏曲第2番のDVDを見ながらふと思った。\nもしそうなら、自分は絶対に演奏家には向かなかっただろうなと思う。\n一筆書きのプログラミングなんてありえないもんなー。リファクタリング万歳なプログラマで良かったー。",
    "url": "/2010/1/16/2010-01-16-post/"
  },
  {
    "id": "2010-01-19-post",
    "title": "LEGOブロックを使って1分でiPodTouchスタンドを作る方法",
    "date": "2010-01-19",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2010-01-19-post.md",
    "content": "結論:LEGOブロックを使えば、こんなiPodTouchスタンドが簡単に作れる！\n\n動機:できあいのスタンドが大きくて持ち運びにくい\n買ったのはこれだが、大きいのでカバンに入れようとは思わない。\nそんな理由で、結局使わなくなった。\n100円ショップで調達する案などを調査\n100円あれば立派なiPod touchスタンドができる！ | 和洋風◎\n 100円ショップでiPod touchスタンドを見つける秘訣 - hp12c\nうーん、値段だけ考えればいいんだけど、使い勝手が悪そう。\nLEGOでスタンドを作る方法\n\nLEGOを用意する\nレゴ デュプロの大きさが丁度良い。\n小さい男の子のお子さんがいる家庭ならあるはず。うちのは、これを使った。\n\nこの形のブロックを4個用意する\n\n写真の様に組合わせるだけせるだけ\n\n好きな色を使えばよろし\n\n持ち運ぶ時は、縦につなげば鞄にも入れやすい\n\nうちでは、レストランで子供がぐずった時にビデオを見せるのにiPodTouchが大活躍している。但し、手持ちなのでかなり面倒だったのだ。\nこのスタンドで楽に慣りそうだ。\n※注意: iPhoneはiPodTouchに比べてちょっと本体が厚めなので、この方法でいけるかどうかは未確認です。うまく行った方、コメント下さい。",
    "url": "/2010/1/19/2010-01-19-post/"
  },
  {
    "id": "2010-01-20-post",
    "title": "LET OVER LAMBDA 読了",
    "date": "2010-01-20",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-01-20-post.md",
    "content": "やっとひととおり読めた。休み休み読んで、結局半年くらいかかったのか。\n『第6章 マクロの効率』だけはあまり興味が無かったので飛ばした。(どうも自分はイマイチ実行速度には興味が無いらしい)\n- 目次\n第1章　クロージャ\n第2章　マクロの基礎\n第3章　リードマクロ\n第4章　プログラムするプログラム\n第5章　アナフォリックマクロ\n第6章　マクロの効率\n第7章　Lispを動かすForthを動かすLisp\nAmazonの商品説明の通り、『Let Over Lambdaは世にある中でも最も過激なコンピュータプログラミング書籍の1つだ』というのは偽りではない。\n全編Lispマクロ満載の本なので、既にLispでプログラミングをしている人がさらに高い技術を追求したい場合に読む本だと思う。\nLispのユーザ数の少なさから考えて、どれだけ売れているのか分からないけれど、Lispをかじった事がある人なら、Lispマクロを使えばこんな凄いことが出来るのかというのを垣間見れるので、立ち読み程度でも中身を見てもらえばと思う。\n補足として、\nさて、私が開発しているLisp方言[Nendo]の話に移ると、本書にはコアライブラリを簡潔に書く上で参考になりそうなアイデアがたくさん有りそうだが、本書は難易度が高すぎるので[Nendo]の開発を進めながら、何度も読み返して咀嚼しないといけないなと思った。",
    "url": "/2010/1/20/2010-01-20-post/"
  },
  {
    "id": "2010-02-03-post",
    "title": "プログラミングClojureを読む(その1)",
    "date": "2010-02-03",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-02-03-post.md",
    "content": "目次\n- 第1章 Getting Started\n- 第2章 Clojureひとめぐり\n- 第3章 ClojureからJavaを使う\n- 第4章 シーケンスを使ったデータの統合\n- 第5章 関数型プログラミング\n- 第6章 並行プログラム\n- 第7章 マクロ\n- 第8章 マルチメソッド\n- 第9章 現場のClojure\n第4章の途中を読んでいる所。\n[Nendo]ではどうするかなーと考えながら読んでいるので時間が掛かる。\n特に、第3章で出てくるClojureからJavaへのアクセス構文については、[Nendo]でかなり参考にさせてもらっている。\n本書を読みながら、改めて感じたことは、ClojureからJavaへのアクセスする構文のパターンが多すぎて複雑な気がする。\n[Nendo]ではあまりパターンを増やさず、一度チュートリアルを読めば覚えられる程度にとどめようと思った。\nまた読み進んだら、再度感想を書きます。",
    "url": "/2010/2/3/2010-02-03-post/"
  },
  {
    "id": "2010-02-20-post",
    "title": "プログラミングClojureを読む(その2)",
    "date": "2010-02-20",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-02-20-post.md",
    "content": "目次\n- 第1章 Getting Started\n- 第2章 Clojureひとめぐり\n- 第3章 ClojureからJavaを使う\n- 第4章 シーケンスを使ったデータの統合\n- 第5章 関数型プログラミング\n- 第6章 並行プログラム\n- 第7章 マクロ\n- 第8章 マルチメソッド\n- 第9章 現場のClojure\nやっと、最後まで読めた。\nじっくり読むために、1歳半の子ををいろんな施設にあづけている時間に読んだので、それにかかった金額は1万円くらいか。\nそれに比べると、本の購入金額なんてあって無いようなもんだな…\n独身とか学生の方々は時間のある今のうちにいろいろ好きなことをしておく事をオススメする。\nそれはさておき、感想を。\nClojureはJVMと心中することで本気のプロジェクトにも使えるLispだと感じた。\nSchemeやCommon Lispに慣れている人からすると、quoteやquasiquoteの記号が違っていたり、再帰のコーディングには気を付けないといけなかったりでちょっと勝手が違う所も有るだろうけど、やはりS色とマクロが揃っているので、本質部分はLispだ。\n全体を通してClojureのデザインのうまい所は、参照透過な部分とそうでないコード(副作用を持つコード)を意識して分離できる仕組を全部そろえている所だと思う。\nさほど意識しなくても純粋な部分を明確に意識して保護できる。(Haskellが純粋関数型言語ならClojureは高純度関数型言語か)\nそれを達成するために、処理系にはSTMやMVCCが組込まれていたり、データ構造の隅々までシーケンスで包みこんであったり、かなりの力が入っている。\nやっぱり処理系がここまでしてくれれば、関数型プログラミングのメリットが十二分に発揮できるし、安心して関数型プログラミングができそうだ。\n一般的にこの手のマイナー言語だが重要な書籍は原書(英語)でしか読めないところを、重要な本を日本語に翻訳して下さったshiroさんに感謝。",
    "url": "/2010/2/20/2010-02-20-post/"
  },
  {
    "id": "2010-02-21-post",
    "title": "set!の実装につまづく",
    "date": "2010-02-21",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-02-21-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nちょっと作業する時間があったので、set!をSchemeの仕様に近づける修正にトライした。\nつまづいたので備忘録として記事にしておく。\n\n方針\n方針としては、Schemeのグローバル変数に相当するものをRubyのインスタンス変数 (Rubyでの表記は@var) に割当て、Schemeのローカル変数に相当するものを、Rubyのローカル変数 (Rubyでの表記はvar)に割りあてる方式でやることにした。\nLispからRubyへのトランスレートにおいて次の様なコードを吐く様にした。\n(以下は原理を簡単にする為に、実際に[Nendo]処理系が出力するコードを簡略化してある。一応動く)\n\nトランスレート前のLispコード\n\n(define a 100)\n(let ((a 1))\n (set! a 2))\n\nトランスレート後のRubyコード\n\n #/usr/local/bin/ruby\n\n @_a = 100\n lambda {|a|\n begin\n 6 if defined?(a) == &quot;local-variable&quot;\n puts &quot;(1)&quot;\n 8 a = 2 # local variable\n elsif self.instance_variables.include?(:@_a)\n puts &quot;(2)&quot;\n 11 @_a = 2 # global variable\n else\n raise NameError\n end \n rescue =&gt; __e\n raise __e\n end\n 18 p local_variables\n }.call(1)\n\n実行結果\nruby localvar_test.rb \n(1)\n*:a, :__e*\n\nどこがダメか\n上記のコードでは11行目が実行されるかと思いきや8行目のほうが実行される。\nローカル変数 a が8行目で宣言されてしまうので、6行目の判定は定義済となってしまうのだ。\nRubyのローカル変数の代入は非常に特殊で、ブロック内のどこかに代入が記述されただけで(実行されなくても)、ローカル変数が宣言されたことになってしまう。\n変数と定数 - Rubyリファレンスマニュアルの引用\n 宣言は、例え実行されなくても宣言とみなされます。\n v = 1 if false # 代入は行われないが宣言は有効\n p defined?(v) # =&gt; \"local-variable\"\n p v # =&gt; nil\n手ぬきの代償\n[Nendo]ではLispコードを等価なRubyコードにトランスレートすることで、クロージャが持つローカル変数のスコープ管理などを全てRuby本体の機能にまかせるという前提だったのだが、上記のやりかたでは十分でないということになる。\nSchemeのset!と等価なローカル変数の代入を実装するためには、そのローカル変数が定義済かどうかの判定を生成されたRubyコード自身にやらせるのでは遅すぎるということだ。\n対策\nRubyへトランスレートする前のLispコード(S式)の段階でレキシカルスコープの解析を行い、それぞれのset!が出現した場所でそのローカル変数が定義済かどうかを判定して、各set!に対応するコードを動的に切りかえる。\n多分これで実現できるだろう。\n感想\nRubyのローカル変数の代入と宣言の仕様は、なかなか微妙な仕様だと思う。\nSchemeが define(定義) と set!(代入)の役割をはっきり分離しているのに対して、Rubyはそこを分かちがたく統合してしまっている。\nそこには、Rubyなりの設計方針でそうなっているのだとは思うが、Schemeと比べるとスッキリしないなあ。\nRubyの『驚き最小の法則』というのを昔聞いたことがあるが、今回のは個人的にちょっと驚いた。\nというか、せめて宣言と代入を分離する手段も用意しておいてほしかったぞ。\n参考: yugui wiki - 『初めてのRuby』余った切れ端\n yuguiさんの見解が書かれているページを見つけた。\n初期値 (6章余り)\n Column: 初期値\n (略)\n Ruby文法は妥協と折衷、損益判断により構成されています。Ruby文法がなぜ\n Aであるかを調べると、いつも「Bにするだけの価値があるか」という点が浮\n かび上がってきます。変数は基本的に代入による初期化を必須にする方針の\n 一方で、インスタンス変数とグローバル変数についてはアクセス可能なコー\n ド範囲が広すぎて初期化を強制するには弊害が大きすぎたのだと考えられま\n す。\n\nコメント by shiro:\nrubyの仕様はまだよく理解できてないですが、このコードに限ればdefined?(a)がlocal-variableになるのはlambda式の仮引数が|a|になってるからじゃないでしょうか。試しに lambda {|z| ...} に変えてみたら11行目の方が実行されました。\n仮引数が|a|なのは (let ((a 1)) ...) だから、ということなら、8行目の方が実行されるのが正しいですよね。\nただまあ、Schemeコードを処理する時に変数がローカルかグローバルかを判定するのはごく簡単なので (サブフォームに再帰してゆく時にローカルの変数リストを渡して行くだけ)、そうしてしまった方がうんと楽だとは思います。あと、その時点でset!に対応するコードを切り替えるのは、「動的」とは言わないと思います。コードそのものの実行時じゃないから。\n\nコメント by kiyoka:\nshiroさん、コメントありがとうございます。\nご指摘の通り、上記の実験に致命的な間違いがありました。\nこの記事での問題点の記述も微妙にずれております。\n再度、問題点を整理して次の記事にしてみます。\nただ、解決方法はshiroさんのコメントのように、サブフォームにローカル変数のリストを渡す方法でいけると思います。\nまた、Rubyコード生成時にset!のコードに対応するRubyコードに切り替えるのは、どちらかというと「動的」でなくて「静的」ですかね。\nコメント by shiro:\nrubyの仕様はまだよく理解できてないですが、このコードに限ればdefined?(a)がlocal-variableになるのはlambda式の仮引数が|a|になってるからじゃないでしょうか。試しに lambda {|z| ...} に変えてみたら11行目の方が実行されました。\n仮引数が|a|なのは (let ((a 1)) ...) だから、ということなら、8行目の方が実行されるのが正しいですよね。\nただまあ、Schemeコードを処理する時に変数がローカルかグローバルかを判定するのはごく簡単なので (サブフォームに再帰してゆく時にローカルの変数リストを渡して行くだけ)、そうしてしまった方がうんと楽だとは思います。あと、その時点でset!に対応するコードを切り替えるのは、「動的」とは言わないと思います。コードそのものの実行時じゃないから。",
    "url": "/2010/2/21/2010-02-21-post/"
  },
  {
    "id": "2010-02-22-post",
    "title": "set!の実装につまづく(2)",
    "date": "2010-02-22",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-02-22-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n先日の記事([kiyoka.2010_02_21]『set!の実装につまづく』)の続き。\nshiroさんのコメントで間違いを御指摘いただいたのと、問題点がうまく記述できていなかったため、もううちど原点に戻って整理しよう。\n[Nendo]の設計方針\nクロージャのレキシカルスコープ等の管理はRuby処理系まかせにする\n[Nendo]ではLispコードを等価なRubyコードにトランスレートすることで、クロージャのローカル変数(=レキシカル変数)のスコープ管理を全てRuby本体の機能にまかせることにする方針。自分で書くよりも、コード量が削減できるし、Ruby VMの最適化の恩恵にも浴することができるのではないかというのが狙い。\n(クロージャのレキシカル変数がちゃんと動くようになったのはRuby 1.9.1からです。昔のRubyでは挙動が違うことに注意)\nRubyのインスタンス変数とローカル変数の両方を使う\nSchemeのグローバル変数に相当するものをRubyのインスタンス変数 (Rubyでの表記は@var) に割当て、Schemeのローカル変数に相当するものを、Rubyのローカル変数 (Rubyでの表記はvar)に割りあてる方式でやることにした。\n当初、Schemeのグローバル変数の機能もRubyのローカル変数だけで代用できるのではと思ったが、Rubyのローカル変数はRubyのコード実行時に割当てが決まるのではなく、Rubyコードのコンパイル時点で割当てわれてしまうため、コンパイル時に未定義の変数は永遠に未定義のままとなる。\nこれでは、トップレベル関数の相互呼出ができないとか、replでトップレベル関数の差し替えなどもできないという問題がある。\n実験コード\n 1 #!/usr/local/bin/ruby\n\n #\n # Rubyのローカル変数に割当てたクロージャは、pre-definedでないと呼出せない。\n #\n def test1\n proc1 = lambda {\n p &quot;proc1(1)&quot;\n }\n proc2 = lambda { # '\n\n補足として、test1()メソッドの入口でproc3 = nilとしておくと、上のエラーは回避できるが、Lispのrepl上では未来にユーザーがどのような変数を使うかは神のみぞ知るなので、ここでは使えない。\nset!の実装方法\nset!の代入対象の変数がローカル変数か、グローバル変数か、はたまた未定義かを生成後のRubyコードで動的に判断させる方法を最初に試したが、ダメだった。\n例えば、(set! a 2) をRubyに変換したイメージを下記に示す。これではうまくいかない。\n begin\n if defined?(a) == &quot;local-variable&quot;\n 3 _a = 2 # local variable\n elsif self.instance_variables.include?(:@_a)\n 5 @_a = 2 # global variable\n else\n raise NameError\n end \n rescue =&gt; __e\n raise __e\n end\n\n前回の記事 ([kiyoka.2010_02_21]『set!の実装につまづく』) でも書いたように、Rubyのローカル変数の代入は非常に特殊で、if false then a = 2 end の様に例え実行されなくても、それ以降は ローカル変数 a が『宣言』されたことになってしまう。(前回の記事で『ブロック内のどこかに代入が記述されただけで(実行されなくても)、ローカル変数が宣言されたことになってしまう。』と書いたのは私の勘違いでした…すみません)\n例えば、上の実装イメージでset!が連続で記述されたら1回目と2回目の set! の挙動が変わってしまうだろう。(たぶん、1回目はグローバル変数を更新し、2回目は新しく宣言したローカル変数を更新する挙動になるだろう)\n(define a 100)\n(set! a 2)\n(set! a 3)\n\n下記の実験コードで試してみよう。\n実験コード\n #/usr/local/bin/ruby\n\n def local_variable_test\n func1 = lambda {||\n print &quot; ---- (1) ----\\n&quot; \n begin\n print &quot;a : &quot; ; p a\n rescue NameError\n puts &quot;NameError(1)&quot;\n end\n print &quot;defined?(a) : &quot; ; p defined?(a)\n print &quot;local_variables : &quot; ; p local_variables\n 13 if false\n 14 a = 1 # assign\n 15 end\n\n print &quot; ---- (2) ----\\n&quot; \n begin\n print &quot;a : &quot; ; p a\n rescue NameError\n puts &quot;NameError(2)&quot;\n end\n print &quot;defined?(a) : &quot; ; p defined?(a)\n print &quot;local_variables : &quot; ; p local_variables\n if false\n a = 1 # assign\n end\n }\n\n func1.call()\n end\n\n local_variable_test()\n\n実行結果\nbash$ ruby local_variable_test.rb\n ---- (1) ----\na : NameError(1)\ndefined?(a) : nil\nlocal_variables : *:a, :func1*\n ---- (2) ----\na : nil\ndefined?(a) : &quot;local-variable&quot;\nlocal_variables : *:a, :func1*\n\nfunc1の ---- (1) ---- と ---- (2) ---- 部分は同じコードの繰返しなのに、13,14,15行目の実行されない代入が登場するとそれ以降ローカル変数a はNameErrorにならない。\nRubyの仕様ではローカル変数が宣言されるとnilが代入される様だ。(今回の問題には関係ないけど、local_variablesメソッドの出力結果が defined?(a)の結果と対応していないのが変だが、それは気にしないでおこう。Rubyのバグかな？)\nまとめ\nこのように、たとえ実行されない代入文でも宣言となる仕様では、set!に対応するコードをRubyで動的に切りかえる事はできない。\nよって、前回の記事でも書いた様に、LispからRubyへの変換時にその時点での対応するRubyコードに切りかえて出力しないといけない。\n今回のset!対応は生成Rubyコードを人間に見やすくインデントするリファクタリングをやった後にやろう。",
    "url": "/2010/2/22/2010-02-22-post/"
  },
  {
    "id": "2010-02-27-post",
    "title": "letrecを実装した",
    "date": "2010-02-27",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-02-27-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nやっとletrecを実装した。1時間半位で実装できた。変換処理はRubyで実装している。\nSchemeのR5RS仕様書に内部defineはletrecに変換可能と書いてあるので、[Nendo]も同じ仕様で実装しよう。\nやっぱりリスト処理はRubyよりも、Lisp系言語の方が書きやすいので、そのコンパイルフェーズは[Nendo]自身で書きたい。\nもっとよく考えていけば、[Nendo]自身で書ける部分も増えそうだけど、鶏が先か卵が先かというような、複雑な依存関係が増えそうな危険な香りもするのでちょっとずつリファクタリングする方が良いかな？\nちなみに、もしやと思ってGauche 0.9のcompile.scmを見てみたら、Gaucheも内部defineはletrecに変換しているようだ。\nやっぱり、早めに内部defineは消しておき、letrec 1本に収束させた方が綺麗だからだと思う。",
    "url": "/2010/2/27/2010-02-27-post/"
  },
  {
    "id": "2010-03-02-post",
    "title": "set!の実装につまづく(3) =>解決",
    "date": "2010-03-02",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-02-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n先日の記事 ([kiyoka.2010_02_22]『set!の実装につまづく(2)』)の続き。\n問題のバグを修正し、各々のset!に対応するRubyコードを正常に出力できるようになった。\nshiroさんのコメントにあったように、LispのコードをRubyに変換する処理において、サブフォームに再起して行く際にローカル変数のリストを渡していく方法で簡単に実装できた。\nset!の第一引数の変数名がローカル変数リストにヒットすればRubyのローカル変数を使用し、ヒットしなければRubyのインスタンス変数(Lispのグローバル変数の代替品)を使う実装にした。\nこのバグ修正をする前作業として、インデント付きのRubyコード生成を生成するようにしたので見やすくなった。\nそのままコードを貼りつけて解説する。\n-- グローバル変数の更新\nNendo:\n(define a-global-var 1)\n(set! a-global-var 10)\n\n生成コード(Ruby):\n @_a_global_var = \n 1\n @_a_global_var = \n 10\n\n-- ローカル変数の更新\nNendo:\n(let ((a-local-var 2))\n a-local-var)\n\n生成コード(Ruby):\n begin\n ___lambda = lambda { |_a_local_var| \n begin\n _a_local_var\n rescue =&gt; __e ; __e.set_backtrace( *&quot;(stdin):126&quot;* + __e.backtrace ) ; raise __e\n end\n } ; ___lambda.call(\n 2\n )\n end\n\n-- グローバル変数とローカル変数の混在\nNendo:\n(define a-global-var 1)\n(let ((a-local-var 3))\n (set! a-global-var 20)\n (set! a-local-var 4))\n\n生成コード(Ruby):\n @_a_global_var = \n 1\n\n begin\n ___lambda = lambda { |_a_local_var| \n @_a_global_var = \n 20\n _a_local_var = \n 4\n } ; ___lambda.call(\n 3\n )\n end\n\n明日は、内部defineをletrecに変換するコンパイルフェーズを[Nendo]自身で書いてみよう。\nところで、実際にSchemeの仕様書を読みながら実装してみると、Schemeの仕様があまり何も規定していない実装自由度の高い仕様であることが分かる。\nなので、どのような用途を狙うかによって、処理系ごとの規模の振れ幅は大きいだろうなと思う。\n例えば、小さなフットプリントを狙うのか、処理系のソースコード規模最小限を狙うのか、高速な処理系を狙うのかなどで全く違った実装になる。\nSchemeの処理系の数が余りにも多いのも頷ける。(tinyschemeとかchibischime、GaucheとかMoshとか色々ある)",
    "url": "/2010/3/2/2010-03-02-post/"
  },
  {
    "id": "2010-03-06-post",
    "title": "named letをmacroで実装した",
    "date": "2010-03-06",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-06-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nこれまで、[Nendo]ではlet等の予約語はマクロを束縛すると正しく展開できない実装だったが、ついに予約語と同名の変数にマクロを束縛しても動作するようにした。\nそうすることで、例えば named let をmacroで定義できるようになった。\n;; named letのサポート\n(define let\n (macro lst\n (if (symbol? (car lst))\n ;; named let\n `(letrec ((,(first lst)\n (lambda ,(map\n (lambda (x)\n (first x))\n (second lst))\n ,(third lst))))\n (,(first lst)\n ,@(map\n (lambda (x)\n (second x))\n (second lst))))\n\n ;; don't touch\n `(let ,@lst))))\n\nなぜこれをできるようにしたかというと、処理系全体のソースコードがコンパクトになる方向を目指しているためだ。\n一般的にS式のmacroはソースコード規模を圧縮する方向に作用するため、Rubyで実装するコアはシンプルな構文のみに抑え、Lispのmacroを多用して構文を拡張した方が有利になるからだ。\nRubyではコード圧縮に限界がある。\nRubyで『named letの機能を持たない基本的なlet』と『letrec』に対応するコード生成機能が有れば、named letを[Nendo]のmacroで記述できる。\n例えば、下記のnamed letのサンプルコードは上のマクロで解決できる。\n展開前\n(let1 total 0\n (let loop ((cnt 10))\n (if (&lt; 0 cnt)\n (begin\n (set! total (+ total cnt))\n (loop (- cnt 1)))))\n total)\n\n展開後\n(let ((total 0))\n (letrec\n ((loop (lambda (cnt)\n (if (&lt; 0 cnt)\n (begin (set! total (+ total cnt))\n (loop (- cnt 1)))))))\n (loop 10))\n total)\n\n実行結果\n55\n\n恥を晒すと、本当はSchemeのdefine-syntax相当をサポートしてそれで定義するのがまっとうな方法かも知れないが、まだそこまで自分の力量が足りていないというのが正直なところ。\nしかし、これまで実際にLisp処理系を実装するのは本当に勉強になると実感した。\nやればやるほど、Lispの奥深さが少しづつ感じ取れる様になった。(オマケとしてRubyにも詳しくなったし…)\nLisp系言語を本当に習得したいという人は一度は自分のLisp処理系を実装してみることをおすすめするぞ。",
    "url": "/2010/3/6/2010-03-06-post/"
  },
  {
    "id": "2010-03-16-post",
    "title": "Gaucheの #?= 相当のデバッグユーティリティをサポート",
    "date": "2010-03-16",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-16-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nGaucheには #?=S式 という形式のリーダマクロでデバッグ表示する機能がある。\nそれを[Nendo]でもそっくりそのまま真似てみることにした。\n結果を見て頂けるとわかるように、本当にソックリな表示になっているのがわかるだろう。\nこれで、手がGaucheに慣れてしまっている人でも[Nendo]で遊びやすくなったかな？\n近日中にそこそこ遊べるバージョンとして 0.2.0 をリリースするので、粘土遊びを試してみてください。\n\ngoshの実行例 (リファレンスマニュアルより抜粋)\n 今のところ、作者は必要な時は古典的な「プリントスタブ」方式を使っていま\n す。そのためのリーダーマクロ #?=expr が定義されています。これは\n (debug-print expr) のように読まれ、マクロ debug-print はexprを評価して\n その値を返しますが、評価前と評価後にメッセージを出力します。\n\ngosh&gt; #?=(+ 2 3)\n#?=&quot;(stdin)&quot;:1:(+ 2 3)\n#?- 5\n5\ngosh&gt; #?=(begin (print &quot;foo&quot;) (values 'a 'b 'c))\n#?=&quot;(stdin)&quot;:2:(begin (print &quot;foo&quot;) (values 'a 'b 'c))\nfoo\n#?- a\n#?+ b\n#?+ c\na\nb\nc\ngosh&gt; (define (fact n)\n (if (zero? n)\n 1\n (* n #?=(fact (- n 1)))))\nfact\ngosh&gt; (fact 5)\n#?=&quot;(stdin)&quot;:6:(fact (- n 1))\n#?=&quot;(stdin)&quot;:6:(fact (- n 1))\n#?=&quot;(stdin)&quot;:6:(fact (- n 1))\n#?=&quot;(stdin)&quot;:6:(fact (- n 1))\n#?=&quot;(stdin)&quot;:6:(fact (- n 1))\n#?- 1\n#?- 1\n#?- 2\n#?- 6\n#?- 24\n120\n\nNendoの実行例 (プログラムをファイルに保存してから実行)\n-- ソース fact.nnd\n\n#!/bin/sh\ntrue; #-*- mode: nendo; syntax: scheme -*-;;\ntrue; exec /usr/local/bin/nendo $0 $*\n\n;; fact\n(define (fact n)\n (if (zero? n)\n 1\n (* n #?=(fact (- n 1)))))\n\n(print (fact 5))\n\n-- 実行結果\nbash$ ./fact.nnd \n./fact.nnd \n#?=&quot;./fact.nnd&quot;:9:(fact (- n 1))\n#?=&quot;./fact.nnd&quot;:9:(fact (- n 1))\n#?=&quot;./fact.nnd&quot;:9:(fact (- n 1))\n#?=&quot;./fact.nnd&quot;:9:(fact (- n 1))\n#?=&quot;./fact.nnd&quot;:9:(fact (- n 1))\n#?- 1\n#?- 1\n#?- 2\n#?- 6\n#?- 24\n120",
    "url": "/2010/3/16/2010-03-16-post/"
  },
  {
    "id": "2010-03-18-post",
    "title": "初期化スクリプトをコンパイル済にして高速化した",
    "date": "2010-03-18",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-18-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n[Nendo]にはinit.nndという起動直後に読み込まれる初期化スクリプトがある。\n中身は[Nendo]のソースコードで、caar や caaar や let1、cond、caseなどの基本的な構文が定義してある。\n0.2.0の時点で約600行のソースだ。\nこのファイルの読み込みが重いという問題があったのだが、かなりad-hocな方法で解決した。\n[Nendo]の処理系はもともと Nendo(Lisp言語)を読み込むと、それと等価なRubyコードにトランスレートして実行する仕組みを持っている。\n今回 init.nnd の読み込みが重いのは、パース、マクロ展開、Rubyコードへのトランスレートという非常に重いプロセスが済んだ init.nndc(コンパイル済ファイル)というファイルを生成するようにした。(拡張子のネーミングは Emacsの .el と .elc と同様にUNIXで一般的なルールです)\n察しの通り init.nndc は生成したRubyコードが入っている。\nさて、どれくらいの差があるか計測してみよう。\n計測に使ったマシンは PowerBook G4 (PowerPC 1GHz) の非常に時代遅れなマシン。\nちなみに nop.nnd は中身がコメントのみで関数呼び出しも何もないファイル。\n;;-*- mode: nendo; syntax: scheme -*-;;\n;; Nothing to do.\n\ninit.nnd (コンパイルなし)\n\nbash-3.2$ time nendo nop.nnd\n\nreal 0m10.462s\nuser 0m9.550s\nsys 0m0.280s\n\ninit.nndc (コンパイル済)\n\nbash-3.2$ time nendo nop.nnd\n\nreal 0m0.809s\nuser 0m0.636s\nsys 0m0.110s\n\nコンパイルしないと、起動に10秒もかかってしまってしまう。\n最初に[Nendo]をさわった人はここで見向きもしなくなるだろうが、コンパイル済であれば、まあギリギリOKの範囲だろう。\n0.2.0のリリース版は自動的にコンパイル済の初期化スクリプトが選択されるようになっていますので御安心を。",
    "url": "/2010/3/18/2010-03-18-post/"
  },
  {
    "id": "2010-03-19-post",
    "title": "Nendo 0.2.0 リリース",
    "date": "2010-03-19",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-19-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n多少は遊べるようになってきたので、バージョン 0.2.0 としてリリースしました。\n\nインストール方法など、詳細は[Nendo]を参照してください。\nチュートリアル(書きかけ) [Nendo.Tutorial]、 リリースノート [Nendo.ReleaseNote]もあわせて御覧ください。",
    "url": "/2010/3/19/2010-03-19-post/"
  },
  {
    "id": "2010-03-22-post",
    "title": "実用アプリを作りながら、処理系を鍛えるのは重要",
    "date": "2010-03-22",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-22-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n実は[Nendo]の処理系を作りながら、その言語で[Stowspec]というパッケージ管理ツールを書いてみている。\nShiroさんのGaucheの開発プロセスの話を聞いて、レベルは数段下だけど真似してみている。\n実際にツールを書いてみると、デバッグ表示の仕組が一番最初に必要になったり、RSpecに定義したテストで漏れている項目がじゃんじゃん見つかる。\n漫然と処理系を作るだけでなく、普段使うツールを作ってみると次に取り組むべき課題が自然に提示されてやりやすい。\n[Stowspec]のほうは一応落ちついたので、一度Webアプリに挑戦してみたいな。\nRubyでいうところのSinatraとHamlみたいなシンプルな仕組みで、[Kahua]のようなS式でHTMLを書けるようになると嬉しいな。\nまあ、そんなに急がずとも、基本的なCGIがどんな風になるのかから見てみようかな。",
    "url": "/2010/3/22/2010-03-22-post/"
  },
  {
    "id": "2010-03-26-post",
    "title": "多値の実装完了",
    "date": "2010-03-26",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-26-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n多値が動いた。(参考リンク: Scheme:多値)\nChatonでつぶやいたら、さっそくShiroさんが答えて下さった。\nGauche &gt; Archives &gt; 2010/03/24 周辺のログを抜粋\n kiyokaの質問\n オレLisp処理系Nendoに多値を組み込みたいけど、どうやったらいいのか悩み中です。\n ちなみにNendoは継続とかサポートしていません。\n 巷のSchemeライブラリのソースを流用したいことが多いので、できれば values と receive がそのまま動けばうれしいのですが...\n shiroさんからの回答\n\nkiyoka 性能を考えないなら、guileがやってたように0個と2個以上の値を特別なオブジェクトにパックしてしまうってのでとりあえず動かすことはできますよ。\n 受け取る値の個数を間違えた場合にその内部的な「多値オブジェクト」が見えてしまう、というのがちょっと残念ですが。\n (define (values . args) (match args (val) val _ (make-values args)))\n (define (call-with-values producer consumer) (let ((v (producer))) (if (values? v) (apply consumer (values-values v)) (consumer v))))\n 多値オブジェクトは make-values で作成、values? で判断、 values-valuesで値リスト取り出し、と想定。\n (define-syntax receive (syntax-rules () ((receive vars expr body ...) (call-with-values (lambda () expr) (lambda vars body ...)))))\n\nほぼshiroさんの回答通り実装してみた。\n残念ながら[Nendo]には match と define-syntax がまだ装備されていないので、別の手段で実装してある。\nmake-values、values?、values-values は Rubyで書いてある。\n\nソースコード\n\n(define (values . args)\n (case (length args)\n ((1)\n (car args))\n (else\n (make-values args))))\n\n(define (call-with-values producer consumer)\n (let ((v (producer)))\n (if (values? v)\n (apply consumer (values-values v))\n (consumer v))))\n\n;; srfi-8\n(define receive\n (macro (vars expr . body)\n `(call-with-values\n (lambda () ,expr)\n (lambda ,vars ,@body))))\n\n実行結果\n-- R5RSの仕様書に書いてある例\n\nnendo&gt; (call-with-values\n (lambda () (values 4 5))\n (lambda (a b) b))\n\n=&gt; 5\nnendo&gt; (call-with-values * -)\n\n=&gt; -1\n-- その他\nnendo&gt; (call-with-values\n (lambda () (values 1 2))\n cons)\n\n=&gt; (1 . 2)\nnendo&gt; (call-with-values\n (lambda () (values 10))\n list)\n\n=&gt; (10)\nnendo&gt; (receive all (values) all)\n\n=&gt; ()\nこの結果は実装依存だと思うが、Gauche 0.9と同じ動作になっている。\nnendo&gt; (receive (a . b) (values 10 20 30) (list a b))\n\n=&gt; (10 (20 30))\nこれで、Gaucheのtext.html-liteのポーティング準備が一歩前進した。\n後は、keyword関連と list* を実装したら簡単にポーティング出来るんじゃないかと。\nこの作業のゴールとしては、Sinatraのページ記述用プラグインとしてhamlとかerb等があるが、その一つとしてS式でもページが書けることを狙っている。(Sinatraのソースを読んだら、プラグイン追加するためには、パッチを当てないとダメっぽいが...)\nとりあえずの中間地点として、まずS式でCGIが書ける段階を目指そう。\n\nコメント by shiro:\nlistは簡単ですよ。 (define (list arg . args) (if (null? args) arg (cons arg (apply list* args))))\n\nコメント by kiyoka:\nlist* の定義は簡単なんですねー。ありがとうございます。\n上記コードがNendoでも動きました。\nnendo&gt; (list 1)\n=&gt; 1\nnendo&gt; (list 1 2 3 4)\n=&gt; (1 2 3 . 4)\nコメント by shiro:\nlistは簡単ですよ。 (define (list arg . args) (if (null? args) arg (cons arg (apply list* args))))",
    "url": "/2010/3/26/2010-03-26-post/"
  },
  {
    "id": "2010-03-27-post",
    "title": "オレ言語処理系]を開発する意味",
    "date": "2010-03-27",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-03-27-post.md",
    "content": "『Just for Fun』 という答えはありきたりすぎて面白く無いかも知れないけど、実際そういう部分が一番大きい。\n同時に、プログラミングスキルを上げたいという気持ちも当然あって、それらの動機は混在しているし、考えてみると他にも動機がいろいろ有りそうで自分自身でもはっきり説明できない所がもどかしい。\nしかし、振りかえってみると、[Nendo]の開発は知的好奇心を刺激するし、同時にLispプログラミングのスキルが上がっているのは確かなので、このまま好循環で進んで行きそうだ。\nちなみに、ちょっとSumibiエンジンのソースを読み返してみたが、今のスキルで[Sumibi.org]を書き直したら随分とスッキリした短いコードが書けるだろうなあと感じた。\nこれをさらっと出来てしまうほどコードを書くスピードが速いわけではないので実際は思うだけで終わりそうだけど...",
    "url": "/2010/3/27/2010-03-27-post/"
  },
  {
    "id": "2010-04-01-post",
    "title": "Gaucheのtext.html-liteをポーティングできた",
    "date": "2010-04-01",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-04-01-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nGaucheから持ってきた text.html-lite が動いた。感動！\n(Gaucheのリファレンスマニュアル: Gauche ユーザリファレンス: 11.36 text.html-lite - シンプルなHTMLドキュメントの構築)\nいざポーティングしようとすると、[Nendo]にnullリスト関連のバグがたくさん見つかったが。\nついでに text.tree も必要だったのでポーティングした。\nしかし、まだ[Nendo]からRubyのHashにアクセスできないので、まだちゃんとしたCGIスクリプトが書けない…\n現状でできる範囲のサンプルはこんな感じ。\n#!/bin/sh\n:; #-*- mode: nendo; syntax: scheme -*-;;\n:; exec /usr/local/bin/nendo $0 $*\n\n(load-library &quot;text/html-lite&quot;)\n(load-library &quot;text/tree&quot;)\n(require &quot;cgi&quot;)\n\n(define (params-list-page cgi)\n `(\n ,(html-doctype)\n ,(html:head\n (html:title &quot;CGI parameter list&quot;))\n ,(html:body\n (html:h1 &quot;CGI parameter list&quot;)\n (html:table :border 1\n (for-each\n (lambda (x)\n (html:tr\n (html:td x)))\n (to-list (cgi.params.keys)))))))\n\n(let1 cgi (CGI.new)\n (cgi.print\n (cgi.header))\n (cgi.print\n (tree-&gt;string\n (params-list-page cgi))))\n\nRubyの大量のライブラリ(gem)が使えるとなったら、いろいろ試したいことがある。\n例えば、Excelファイルをアップロード/ダウンロードするとか、ImageMagickで画像を生成して返すとか。\nやっと、S式でRubyプログラミングの雰囲気が出てきたぞ。",
    "url": "/2010/4/1/2010-04-01-post/"
  },
  {
    "id": "2010-04-02-post",
    "title": "プログラマは皆どのようにしてLisperと化して行くのか？",
    "date": "2010-04-02",
    "categories": [
      "Lisp"
    ],
    "file_path": "_posts/2010-04-02-post.md",
    "content": "vallog: プログラマは皆どのようにしてLisperと化して行くのか？のエントリ。よくこれだけの項目書いたなあ。\n私はPerlやRubyからLisperに転身したのであるが、上記エントリのかなりの項目数が当てはまる。\n色々あって、RubyでLisp処理系を作る事になったが、それはLisperで居続けるためのRubyプログラミングであって、やっぱり自分はLisperだと自覚している。\nあっ、そういえば最近、Lispを学習する人のブログエントリが増えている気がするが、自分の見ているところが偏っているだけなのかな？",
    "url": "/2010/4/2/2010-04-02-post/"
  },
  {
    "id": "2010-04-12-post",
    "title": "Internetがない環境での生産性は高いか",
    "date": "2010-04-12",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2010-04-12-post.md",
    "content": "答えは、『どんな作業をするかによって変わる』だと思う。\n最近、子供を託児所に預けている数時間の間にカフェで[Nendo]の開発を行っているけれども、Internetが接続されていない環境では割り込みが入らないため、コーディングやデバッグの生産性は非常に高い。\n\nただ、他の言語処理系のコードや設計方針なんかを参考にしようとすると、Internetから情報が得られないため部分的に非常に生産性が低い。\nInternetは諸刃の剣だと思う。\nInternetに繋った環境と繋ってない環境を1日おきとか、午前と午後で分けるとかにするとか工夫するとうまく生産性を上げれるかも。\n今Twitterがはやっているけれども、みんなどうやってそのノイズに負けず生産性の維持をしているのだろうか。",
    "url": "/2010/4/12/2010-04-12-post/"
  },
  {
    "id": "2010-04-13-post",
    "title": "Nendo 0.3.0 リリース",
    "date": "2010-04-13",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-04-13-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n[Nendo] 0.3.0をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n(img-s http://allgems.ruby-forum.com/images/rubygems-125x125t.png)\nチュートリアルと、リファレンスマニュアルはまだ書きかけです。\n[Nendo.Tutorial] \n[Nendo.ReferenceManual] \n言語のコア部分の目立つバグは取れてきたと思います。\nまだまだ、Lispの強みであるlist操作系ライブラリやmatch系ライブラリが不足気味です。\nいろんなアプリを作りながら少しづつ肉付けしていく予定です。\nもうそろそろ、ruby-list MLとかに、アナウンス出した方がいいのかな… オレ言語というのはアナウンスタイミングが難しい。",
    "url": "/2010/4/13/2010-04-13-post/"
  },
  {
    "id": "2010-04-14-post",
    "title": "ビューティフルアーキテクチャを読む",
    "date": "2010-04-14",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2010-04-14-post.md",
    "content": "図書館にあったので借りて読んだ。\nシリーズ前作のビューティフルコード\nもしかして自分は、コードよりもアーキテクチャの議論のほうが好きかも。\nこれまで自分が作ってきたものを見ても、自力のコードをがんばるよりもいろんなコンポーネントを組みあわせて面白いものを創る方を優先してきた気がする。\nさて、今回自分が読んだ章はこれだけ。\n一番読んでためになったのは、1章,2章,14章かな。\n自分の中の曖昧なイメージを明確に出来たという意味では、5章も読んでよかった。\n図書館に返却する道すがら別の章もパラパラめくって見たけど、楽しそうな話題が沢山あった。\nいつかもういちど借りよう。(というか買えということか)\n\n第1部アーキテクチャについて\n-- 1章アーキテクチャとは何か?(ジョン・クライン、デビッド・ワイス)\n-- 2章 2つのシステム:今風ソフトウェア物語(ピート・グッドリッフ)\n-- 5章リソース指向アーキテクチャ:「Web上にある」こと(ブライアン・スレッテン)\n\n第4部エンドユーザアプリケーションのアーキテクチャ\n-- 11章 GNU Emacs:漸進的機能追加方式が持つ力(ジム・ブランディ)\n\n第5部プログラミング言語とアーキテクチャ\n-- 13章ソフトウェアアーキテクチャ:オブジェクト指向対関数型(バートランド・メイヤー)\n-- 14章古典再読(パナギオティス・ロウリーダス)\n\nしかし、一番期待していた言語設計の13章が難しすぎてわからなかった。残念。\nなんか議論がいろんな視点に移っていて、煙に巻かれた感じ？\nこの章ちゃんと理解できた人いるのかなぁ。\n\nコメント by Alice:\nHey, that's a clveer way of thinking about it.",
    "url": "/2010/4/14/2010-04-14-post/"
  },
  {
    "id": "2010-04-17-post",
    "title": "CRuby-1.9.1とJRuby 1.5.0-RC1の挙動の違いを発見",
    "date": "2010-04-17",
    "categories": [
      "JRuby"
    ],
    "file_path": "_posts/2010-04-17-post.md",
    "content": "JRubyのバグかなとTwitterでつぶやいたら、@hiro_asariさんから、どんな内容か教えて下さいと返信もらったので、これはその説明用エントリです。@hiro_asariさんありがとうございます。\n Twitter / Hiro Asari: @kiyoka JRubyで1.9相当の挙動を促すに ...\n @kiyoka JRubyで1.9相当の挙動を促すには--1.9というフラグが必要です。そ\n れでも違う場合には、どのような物か提示してもらえれば調査してみます。\nこのあたり、Ruby処理系間の仕様の調整(RubySpecとかあるけど)のノウハウが無いので、後は@hiro_asariさんにお願いできればと思います。\n仕様がちょっと違うというだけのバグなので、JRubyの中身を知っている人ならスグに直せそうな問題です。(JRuby側を合わせるとしたらですが...)\nそれから、本ブログからソースコードをコピペする場合は、ページタイトル右横のPLAIN TEXTアイコンで本ページのTEXT版が出てきます。その方法を試してみて下さい。\n現象\n次のメソッドの返す型が違う。\nCRubyはシンボルの配列を返し、JRubyは文字列の配列を返す。\n- global_variables\n- instance_variables\n- local_variables\nclass_variablesだけは両方の処理系でシンボルの配列を返す。\n実験結果\n* 実験用ソースコード print_variables.rb\n# -*- encoding: utf-8 -*-\n\n$global_var1 = 1\n$global_var2 = 2\n\nclass A\n @@class_var1 = 1\n @@class_var2 = 2\n def initialize\n @instance_var1 = 1\n @instance_var2 = 2\n end\n\n def view_variables\n local_var1 = 1\n local_var2 = 2\n\n print &quot;global_variables:\\n &quot;\n p global_variables\n print &quot;class_variables:\\n &quot;\n p A.class_variables\n print &quot;instance_variables:\\n &quot;\n p self.instance_variables\n print &quot;local_variables:\\n &quot;\n p local_variables\n end\nend\n\na = A.new\na.view_variables\n\n* JRubyの挙動\n$ jruby --1.9 --version\njruby 1.5.0.RC1 (ruby 1.9.2dev trunk 24787) (2010-04-14 0b08bc7) (Java HotSpot(TM) Client VM 1.5.0_22) *ppc-java*\n$ jruby --1.9 print_variables.rb \nglobal_variables:\n *&quot;$$&quot;, &quot;$`&quot;, &quot;$@&quot;, &quot;$\\\\&quot;, &quot;$&quot;, &quot;$:&quot;, &quot;$/&quot;, &quot;$~&quot;, &quot;$0&quot;, &quot;$_&quot;, &quot;$*&quot;, &quot;$?&quot;, &quot;$-n&quot;, &quot;$-I&quot;, &quot;$-p&quot;, &quot;$global_var1&quot;, &quot;$-a&quot;, &quot;$-l&quot;, &quot;$global_var2&quot;, &quot;$-d&quot;, &quot;$-K&quot;, &quot;$stderr&quot;, &quot;$stdout&quot;, &quot;$LOAD_PATH&quot;, &quot;$SAFE&quot;, &quot;$FILENAME&quot;, &quot;$stdin&quot;, &quot;$VERBOSE&quot;, &quot;$LOADED_FEATURES&quot;, &quot;$deferr&quot;, &quot;$defout&quot;, &quot;$PROGRAM_NAME&quot;, &quot;$KCODE&quot;, &quot;$DEBUG&quot;*\nclass_variables:\n *:@@class_var1, :@@class_var2*\ninstance_variables:\n *&quot;@instance_var2&quot;, &quot;@instance_var1&quot;*\nlocal_variables:\n *&quot;local_var1&quot;, &quot;local_var2&quot;*\n\n* CRubyの挙動\n$ ruby --version\nruby 1.9.1p376 (2009-12-07 revision 26041) *powerpc-darwin9.8.0*\n$ ruby print_variables.rb \nglobal_variables:\n *:$;, :$-F, :$@, :$!, :$SAFE, :$~, :$&amp;, :$`, :$', :$+, :$=, :$KCODE, :$-K, :$,, :$/, :$-0, :$\\, :$_, :$stdin, :$stdout, :$stderr, :$&gt;, :$&lt;, :$., :$FILENAME, :$-i, :$*, :$?, :$$, :$:, :$-I, :$LOAD_PATH, :$&quot;, :$LOADED_FEATURES, :$VERBOSE, :$-v, :$-w, :$-W, :$DEBUG, :$-d, :$0, :$PROGRAM_NAME, :$global_var1, :$global_var2, :$-p, :$-l, :$-a, :$1, :$2, :$3, :$4, :$5, :$6, :$7, :$8, :$9*\nclass_variables:\n *:@@class_var1, :@@class_var2*\ninstance_variables:\n *:@instance_var1, :@instance_var2*\nlocal_variables:\n *:local_var1, :local_var2*\n\n今回初めてTwitterが有効活用されそうな予感です。\n\nコメント by あさり:\n念の為に追記しておきますと、http://twitter.com/hiro_asari/status/12359856172 に書きました通り、この点は http://bit.ly/acyiqv で対処しました。ご報告に感謝します。\n\nコメント by kiyoka:\nあさりさん、すばやい対処ありがとうございます。お役に立ててなによりです。\nCRuby1.9互換競争で、JRubyがトップを走ってそうですね。\nまた何か見つけたら報告します。\nコメント by あさり:\n念の為に追記しておきますと、http://twitter.com/hiro_asari/status/12359856172 に書きました通り、この点は http://bit.ly/acyiqv で対処しました。ご報告に感謝します。",
    "url": "/2010/4/17/2010-04-17-post/"
  },
  {
    "id": "2010-05-01-post",
    "title": "Nendo 0.3.1 リリース",
    "date": "2010-05-01",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-05-01-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n[Nendo] 0.3.1をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nチュートリアルと、リファレンスマニュアルはまだ書きかけです。\n[Nendo.Tutorial] \n[Nendo.ReferenceManual] \nあまり、作業が進んでいませんが、一旦区切ってリリースしておきます。\n現在はおもちゃのCGIサンプルを作りながら少しづつ肉付けしていっています。",
    "url": "/2010/5/1/2010-05-01-post/"
  },
  {
    "id": "2010-05-07-post",
    "title": "驚愕！ SQLiteのテストコードは本体の約679倍",
    "date": "2010-05-07",
    "categories": [
      "SQLite"
    ],
    "file_path": "_posts/2010-05-07-post.md",
    "content": "SQLiteのテストコードは4567万8000行！ 本体のコードは6万7000行 － Publickey\n 軽量なリレーショナルデータベースとして人気のSQLite。そのWebサイトに掲載\n されている「How SQLite Is Tested」の内容が、海外のプログラマなどのあい\n だで話題になっています。\n 3月に公開された最新バージョンのSQLite 3.6.23。本体のソースコードは約6万\n 7200行（67.2KSLOC、Kilo Source Lines of Code：空行やコメントを除いた行\n 数）なのに対し、テストコードはなんと4567万8300行（45678.3KSLOC）だと紹\n 介されているのです！これはテストコードが本体の約679倍もの大きさだという\n ことになります。\nスゲー。SQLiteはオモチャだと思っていたが、この数字を見て考えかたが変わった。\nこれくらいテストコードが充実したプロダクトなら安心してリファクタリングや性能チューニングできそう。\n見習いたい。",
    "url": "/2010/5/7/2010-05-07-post/"
  },
  {
    "id": "2010-05-08-post",
    "title": "今作りたいもの",
    "date": "2010-05-08",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2010-05-08-post.md",
    "content": "今日時点で作りたいものをリストアップしてみる。\nこういう心境は数ヶ月もすると簡単に変化する。\n例えば、もろコンフリクトするライバルプロジェクトや、やる気を無くすほど良く出来たサービスが出てくるので、本当に今日時点でのスナップショット。\nbetter SKK\n[Sumibi.org]と同じ様な統計的アプローチを使うが、連文節変換ではないもの。\nコード量はSumibiよりもはるかに少なそうな気がする。\n私が個人的にSKKのキライな所である、大文字小文字を駆使して送りがなを指定する部分を、統計的に解決してほしい。\n使うキーもずっと減らして基本的にCtrl-Jだけにしたい。\n簡易Webデータベース\nサイボウズデヂエのような簡易データベース。\n特徴は、NoSQLを使ったラフなデータベースで、WebとExcelを併用使用できるもの。\n自分では使わないのだけど、業務でよく遭遇する部署ローカルな管理表をWeb化してもっと共有しやすくする。\nExcelからのインポート部分とExcelとの併用の仕方で一応アイデアがあるのだ。まだWeb上で同様のサービスは発見できていない。\nデカ文字生成サイト\n[Nendo]言語の使いやすさを試す目的でCGIを少し作ってみたのだけど、既に何が面白いのか自分でも良くわからず、どうしようかと思っているもの。\nもうひとつひねりが欲しい。\n(ちなみに、nendo 0.3.1以上のgemをインストールすると、dekamoji.cgiという名前でソースが入っている。dekamoji.cgiのソース )\n)\n任意の文字列を画像化してくれるので、こんな画像が作れる。が、2chとかで多用されるだけで今ひとつ平和利用されそうにないなぁ。\n\n ちなみに、『高橋メソッド』を中国語でいうとこうなるそうな。\n\nコメント by もぎゃ:\nデカ文字生成サイト、なんか思いつけば面白い物になりそうですね。\nぱっと見て思いついたのは、WEBデザインのタイトル部分として使う方法。\nたとえば、 http://oasis.mogya.com/ これの\n「検索の多い電源スポット」「駅名や住所を入力して電源スポットを検索することができます」とかは、本当は画像にしたほうが見栄えが良くなるのですけど、プログラマの性(サガ)で、「そんなことしたら気軽に書き換えられないじゃないか！」と思ってしまって、ついついテキストにしてしまいます。\nCGIで動的に画像を生成できると、ちゃんとしたデザインでありながら動的に書き換えも可能になって、プログラマが作るサイトのデザインが多少改善されるかも。\n・・・実用的かもしれないけれどあんまり面白くないなぁ。なんか思いついたらまた書き込みに来ますｗ\n\nコメント by kiyoka:\nデカ文字生成サイトのひねりとしては、手書き風フォントを使うというアイデアもあるのですが、フォントの利用規約が曖昧なものが多く、このような応用にはすっきり使えなさそうです。\n正統派路線では、IPAフォントではなくもっと美しいフォントを自腹で買うという方法もあるのですが、かなり高いようなので実現できなさそうです。\n今ひとつ良いアイデアが出なさそうなので、いったんサイトを開いてみて、面白い利用のされ方を待つのがいいのかもしれません。\n残りの作業としては、key-value-storeの勉強用に完成した画像を蓄積していく部分を実装したらサイトオープン可能な状態です。\nちょうど、Nendo言語のお試しとしては、いいお題になっていることは間違いないのですが...\nコメント by もぎゃ:\nデカ文字生成サイト、なんか思いつけば面白い物になりそうですね。\nぱっと見て思いついたのは、WEBデザインのタイトル部分として使う方法。\nたとえば、 http://oasis.mogya.com/ これの\n「検索の多い電源スポット」「駅名や住所を入力して電源スポットを検索することができます」とかは、本当は画像にしたほうが見栄えが良くなるのですけど、プログラマの性(サガ)で、「そんなことしたら気軽に書き換えられないじゃないか！」と思ってしまって、ついついテキストにしてしまいます。\nCGIで動的に画像を生成できると、ちゃんとしたデザインでありながら動的に書き換えも可能になって、プログラマが作るサイトのデザインが多少改善されるかも。\n・・・実用的かもしれないけれどあんまり面白くないなぁ。なんか思いついたらまた書き込みに来ますｗ",
    "url": "/2010/5/8/2010-05-08-post/"
  },
  {
    "id": "2010-05-10-post",
    "title": "PowerPCに失望の連続(2)",
    "date": "2010-05-10",
    "categories": [
      "ハードウェア"
    ],
    "file_path": "_posts/2010-05-10-post.md",
    "content": "([kiyoka.2010_04_05]ハードウェア PowerPCに失望の連続) でも一度書いたが、まだまだやられている。\n私の開発用Macは今だに、PowerPCなのだが、時代に置いていかれそうだ。\n最近、使いたいけど、PowerPCに対応していないせいで使えなかったオープンソースソフトウェアのリスト。\n- MongoDB\n- KyotoCabinet\n- MacRuby 0.6\n特に、MacRubyがMacという名前がついているくせにPowerPCのMacを置き去りにしているのが寂しい。\nやっぱりオープンソースソフトウェアをいろいろ試したい人は LinuxとIntel(特に64bit)でないとキツいのかな。\n次に買うノートパソコンはMacでなくてもいいかなぁ。\nレノボがいいのかな。",
    "url": "/2010/5/10/2010-05-10-post/"
  },
  {
    "id": "2010-05-11-post",
    "title": "Hadoop本を読む",
    "date": "2010-05-11",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-05-11-post.md",
    "content": "翻訳者の玉川さんにいただいた本。\nまだ全部読んでいない。\n結構、分厚い本だ。\nある程度読み進んでは、実際に動かしてみてという繰返しで学習しないと、MapperとReducerの作りかたがパッと思い浮かぶまでにはならなさそう。\n実際に、14章のケーススタディを読みながら手を動かして実験するのが学習が早そうに感じた。\n個人でHadoopを使ってまで実験をしてみたいプロジェクトは無いけれども、そのうち仕事で使う日が来るのかも知れない。\nプライベートで自然言語処理の実験をやるとすれば、1台のStandalone構成のHadoopで慣れておくというのも先行技術としてはありかな...？\nプライベートなプロジェクトであっても、お金をかける気さえあれば、Amazon EC2で数十インスタンス起動してみれる時代になったのは感慨深い。\n[Sumibi.org]のような、楽しそうなプロジェクトに手をつける機会が有れば、一度は分散で統計処理を経験しておきたい。\nその時にまた読み返そう。",
    "url": "/2010/5/11/2010-05-11-post/"
  },
  {
    "id": "2010-05-24-post",
    "title": "初めての人のためのLISP<増補改訂版> 読了",
    "date": "2010-05-24",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-05-24-post.md",
    "content": "深い本。\nこの分量で、Lispのミクロで見た視点と、マクロで見た視点(俯瞰した視点)の両方を楽しく見せてくれるすばらしい本だ。\nマイ処理系を実装しながら読むと、もっとリファクタリングしたくなってくる。\n例えば、現在の[Nendo]は read eval print loop (通称repl) がRubyで書いてあるのだけど、ちゃんとLispで\n(loop (write (eval (print))))\n\nというコードにしてしまいたいと思った。\nおそらく、少しのリファクタリングで直せるだろうし、プログラムの見通しも良くなりそう。\n本書の話に戻ると、本書はどちらかというと、特定のLispについてではなく、過去の歴史的経緯なども踏まえてLispの本質を伝えようとしている。\nCommon Lispに至る経緯なども知れて良い。\nあわせて、今のSchemeを知った上で読むと、SchemeがLispの本質を失わず相当スッキリした仕様になっていることも実感できた。\nやっぱり、自分はCommon Lispよりも、Schemeの方が好みであることも再確認。\nLispを使わない人も一読をオススメするぞ。",
    "url": "/2010/5/24/2010-05-24-post/"
  },
  {
    "id": "2010-05-27-post",
    "title": "Nendo 0.3.2 リリース",
    "date": "2010-05-27",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-05-27-post.md",
    "content": "[Nendo] 0.3.2をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nチュートリアルと、リファレンスマニュアルはまだ書きかけです。\n[Nendo.Tutorial] \n[Nendo.ReferenceManual] \n今回から、Nendoで記述されたユーザースクリプトをRubyにコンパイルする機能が入りました。\nLispの一番重い処理であるコンパイルステップ(マクロ展開など)が処理済みのRubyのソースコードが出力されます。\n コマンド例\nnendo -c script.nnd &gt; script.rb\n\nあとは、script.rb に実行権限を付ければ普通のRubyスクリプトとして実行できます。\nchmod +x script.rb\n./script.rb\n\nこれで、頻繁に利用するコマンドラインツールを[Nendo]で書いてもストレスなく使えるものが作れます。\nちなみに、Nendoで開発している[Stowspec]というコマンドラインツールでは以下のような結果になりました。\n起動時間だけが分かるように、stowspecスクリプトのmain関数の入口で (exit 0) するようにしています。\nうちにある一番速いマシン(Sumibi.orgの漢字変換サーバ)での計測結果。\n スペック: AMD Athlon(tm) 64 X2 Dual Core Processor 4200+\n$ time ./stowspec\n2.147 secs \n$ time ./stowspec\n2.156 secs \n$ nendo -c ./stowspec &gt; stowspec.rb \n$ time ./stowspec.rb\n0.315 secs \n$ time ./stowspec.rb\n0.315 secs \n\nちなみに、ソースコードの行数はかなり膨らんでいますが、この時間で終わるのはRubyすごいです。\n$ wc stowspec\n 576 1924 20576 stowspec\n$ wc stowspec.rb\n 6183 20458 531101 stowspec.rb\n\n他にも、vectorが使えるようになったりと、少しずつ言語のコア機能が固まりつつありますが、もうそろそろ、新しいモノ好きの人に試してもらうためのドキュメント整備が必要かなと思っています。",
    "url": "/2010/5/27/2010-05-27-post/"
  },
  {
    "id": "2010-05-28-post",
    "title": "末尾再帰最適化をどう実装するか",
    "date": "2010-05-28",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-05-28-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n最新の[Nendo] version 0.3.2ではまだ末尾再帰最適化がサポートされていない。\nこれは無限ループが記述できないということを意味する。\nwhileやuntilといった、無限ループ構文は[Nendo]の初期化スクリプトでマクロで定義されているが、[Nendo]のプリミティブにループという概念が無いため、ただの再帰呼び出しに変換してある。つまり無限ではなく、いつかはスタックオーバーフローするということである。\n無限ループが書けないと何が困るかというと、デーモン化したとき、肝心のメインループ(普通は無限ループ)が書けないとか、無限ストリームを読み込む tail -f のようなものも書けない。\nさて、どうやって無限ループを実現するかを考えはじめているのだが、まだまとまっていない。\n案としては、継続をサポートするという正統派な方法と、Rubyのwhileと同様にプリミティブなループ構文を用意してSchemeからは遠ざかるという案だ。\nしかし、何とかしてSchemeと同様の末尾再帰最適化を実現して、Schemeのライブラリをなるべく簡単にポーティングできるようにしたい。\n継続を実現する具体策としてはRubyのcallccがあるが、例外等との絡みで安全性が低いというのをどこかで読んだことがあるので、できればそのまま使わないほうが良いだろう。\n(それに、今ちょっと調べた範囲ではJRuby 1.5.0とRubinius 1.0が callccを完全にサポートしていないみたいだ。callccの優先順位は非常に低いということか...)\nなんてぼんやり考えたのだけど、R5RSを再度確認したら末尾呼び出しになる箇所はこんだけあるよと書いてある。多い！\nつまり、これらの箇所をループに最適化せよということか。\nうわー、めんどくせー。\n(if ) \n (if ) \n (cond +) \n (cond * (else )) \n (case +) \n (case * (else )) \n (and * ) \n (or * ) \n (let () ) \n (let () ) \n (let () ) \n (letrec () ) \n (let-syntax () )\n (letrec-syntax () ) \n (begin ) \n (do () \n ( ) \n *)\nたぶん、上の式を全て lambdaにコンパイルして 最終的には lambda の末尾呼び出しだけを解析して最適化すればいいのだろうが、今の[Nendo]はそうなっていない。\nif と let と lambda くらいだけで勘弁してほしい。たぶんそれで実用レベルにはなるだろう。\nそれともいっそ named letだけが末尾再帰最適化の対象になるとわりきるとか。Clojure も recur という予約語を使って再帰呼び出しを明示した場合のみ最適化されるわりきった仕様だったっけ。\nそして、マニュアルの注意書きで逃げると。 ^_^;\n[Nendo]の用途から考えると本気でがんばる部分じゃない気がしてならないので。\nもうちょっと考えてみよう。\nちなみに今の[Nendo]は次のようにマクロ展開される。これを全部最適化対象にするのは骨が折れるのでやりたくない。\n- case, cond, and, or → if ( Rubyのifで実現 )\n- let*, named let → let ( Rubyのlambdaで実現 )\n- begin → begin ( Rubyのbegin,endで実現 ) \n- lambda → lambda ( Rubyのlambdaで実現 )\n- lterecはプリミティブ ( Rubyのlambdaで実現 )\n\n処理系の実装って本当に地道な作業が多いなあ。\nやっぱり、named letだけ最適化するというあたりが落としどころかな。\n[Nendo]の場合は、一番めんどくさい作業であるライブラリ開発をRubyに丸投げしているので、だいぶ楽できているとは思うのだが、それでも大変な作業だ。\nそれを考えると、Gaucheのライブラリまで含めたの整備状況は凄いよなあ。(最適化も凄いけど)\n追記: 先程、Ruby 1.9.1でcallccを試してみたら 実行速度が非常に遅かった。もし、callccを使うとしたら、例えば、named letの内側の末尾再帰呼出しだけをcallccでジャンプに置きかえる位が現実的かも。",
    "url": "/2010/5/28/2010-05-28-post/"
  },
  {
    "id": "2010-06-09-post",
    "title": "Rubyの呼び出しスタックの深さ制限値を広げることはできるか",
    "date": "2010-06-09",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2010-06-09-post.md",
    "content": "Rubyで、再帰呼び出しの回数が深すぎると、スタックオーバーフローになる。\n再帰を多様する関数型プログラミングスタイルでコーディングなんかすると頻繁にスタックオーバーフローを目にすることになる。\n 例\ntail_recursion_normal.rb:7: stack level too deep (SystemStackError)\n\n[Nendo]の末尾再帰最適化をやろうとして、ふと思った。「Ruby側のstackの深さ制限を緩和すれば、そこそこ深い再帰呼び出しをしても実用レベルでは問題にならないんじゃないだろうか」\n結論。その考えは甘かった。\nCRuby 1.9.2 preview3 のソースを見たのだが、CRubyが採用しているGCの制約でMARKが届く範囲までしかstackの拡張を許していないようだ。\nということは、現状の設定が理論値上の最大値に設定してあるということなのだろう。\nそんな楽な道はあきらめて、ちゃんと末尾再帰最適化にチャレンジしよう。安心して再帰が書けるようにしよう。",
    "url": "/2010/6/9/2010-06-09-post/"
  },
  {
    "id": "2010-06-12-post",
    "title": "今さらRubyでCGIもないだろうと思って調べたら、Rackにたどりついた。",
    "date": "2010-06-12",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-06-12-post.md",
    "content": "CGI程度の簡単アプリであっても、Rackに乗せるべきだと思った。\n\nRoute 477 - 5分でわかるRack , シュレーディンガーの猫たち から一部引用\n(略)\n というわけで、これからRuby用のWebアプリ用フレームワークやWebサーバを書\n こうとするなら Rackは間違いなくチェックすべきライブラリだ。そうでなくて、\n 単にWebアプリを作りたいだけの場合でも、「超シンプルなWebアプリ用フレー\n ムワーク」としてRackを使うという選択肢もあるだろう。\n(略)\n Rackの思想\n 「Webアプリって要するにリクエストをレスポンスに変換するだけの関数だよねー」\n ってのがRackの基本っぽい。\n なので、\n * env(環境変数のハッシュ)を受け取って\n * ステータスコードとHTTPヘッダとHTTPボディを返す\n ような関数を書けばWebアプリになります。\n一度、サンプルを作って体験してみよう。\nデカ文字作成サイトがちょうど良いかな。\n\nついでに、Rack::Reloaderを[Nendo]でWebアプリ開発する時にうまく使えないかにも興味がある。\nGreenbear Laboratory - Rack日本語リファレンス\n Rack::Reloader\n リクエスト時に、Rubyスクリプトが更新されていたらリロードする。 (ただ\n し、重くなるのを避けるため、一度リロードしたら10秒間はリロードしない。\n この秒数は設定可能。)\n[Nendo]の話に移ると、Emacsで[Nendo]アプリを編集する場合、スクリプト全体を毎回実行するのではなく、関数単位でevalし、テストを繰返すスタイルを取る。\nLispでは多分、標準的な開発スタイルだと思われる。\nちなみに、Gauche用のWebフレームワーク[Kahua]はもっと進んでいて、サーバーに直接replで接続し、サーバー上にデプロイ済みのアプリに対して関数単位で動的に更新しながら開発できる。\nこれに慣れると、ファイル単位のReloadとかDeployの繰返しには戻りたく無くなる。\n[Nendo]とRackで、これに似たスタイルを作れそうな気がするので、その辺もいろいろ実験してみようと思う。\n(単に、replでS式を一つ評価する度に完成したRubyソースを吐きだすような特殊なreplを作れば良いだけだと思っている。考えが甘いかな？)",
    "url": "/2010/6/12/2010-06-12-post/"
  },
  {
    "id": "2010-06-22-post",
    "title": "2010年現在、これから個人で始めるプロジェクトについて思ったこと",
    "date": "2010-06-22",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2010-06-22-post.md",
    "content": "2010年にもなると個人で作るべきWebアプリケーションはあまり無い。\n2008年位までは、時間さえ許せば個人がプライベートで、アイデア一発モノのWebアプリケーションを作れた。というよりも、まだ試されていなくて簡単に実装できるアイデアが沢山あった。\n例えば、新しいWikiエンジンとかblogエンジンとかCMSとかの汎用ツールやWebフレームワークが沢山生み出された。どれも発展途上で試行錯誤のしがいがあった。\n2010年現在の状況を見てみると、なかなか普通に思いつくアイデアはほとんど試されているんじゃないかなー。世の中にはWebサイトが溢れ返っている。Webフレームワークもある程度定番に収束しつつある。\nおまけにGoogle App Engineなどのように無料で使えるクラウドサービスがあるので、サイトをオープンするための費用面での敷居も下がり続けている。\nTechCrunch Japanなんかを時々チェックしていると、ますますそういう思いが強くなっていく。毎日似たようなサービスが雨後の竹の子のように生まれ続けている。\nそうすると何が起きるかというと、「個人がプライベートで習作するWebアプリケーション」というのは既存の無料サービスのサブセットの作り直し作業に成り下がる。これは残念。まるでピアノの練習曲を弾いているみたいな感じがする。そんなんでいいのか?\nこの作業はモチベーション的になかなか厳しいものがある。既にあるのに、しかも無料なのに、なぜ今更作る必要があるのかと。ノウハウが得られる以外のメリットは無い。\nいま、単なるWebアプリケーション開発は飽和している。\nまた、ベンチャーが立ち上げるWebアプリケーションもWikiシステムやブログシステムのような汎用情報プラットフォームを裸で提供するだけでなく、特定業者向けに最適化されたWebサイト(クラウド)に移ってきているように思う。\nそういうものは、その業界に精通したものだけが作れる類いのものだ。(本当にそういうものが有用なんだけど)\n現在では、Ruby On Railsのようなフレームワークを使えば簡単にWebアプリケーションが量産できる時代になってしまったので、そうなるのは当然でむしろ望ましい方向だろう。\nでも考えてみれば、アプリケーションの存在意義は本来そこだ。\n注力すべきレイヤーが汎用フレームワークから１段上のアプリケーションに上がっている。生産性が上がった結果、その生産性が正しい方向に使われている。うんうん、世の中は確実に良くなっている。\nさてさて、個人でやれることに戻ると、何が残っているのか。\n人によっていろいろな意見はあるだろうけど、私は自然言語処理やプログラミング言語などの新しいアイデアを試すとか、スマートフォン上のアプリケーションとWebサイト(クラウド)との組み合わせで、さらに進歩したものを作る方向かなーと思う。(スマートフォン関連は既に飽和気味の感も否めないが...)\n結論めいたことは書けないけど、個人がやるべき領域はどんどん狭く、専門的になってきている気がするなぁ。\n\n何かまとまりがない記事だけど、一応公開しときます。\n※ 進歩って何?という議論はあるだろうけど。新規性? 独自性? 生産性? 利便性?\n※ 自分がチェックしているブログやニュースサイトによる偏った見方かもしれないので注意。\n※ 私が最近開発している[Nendo]というLisp処理系もScheme言語の習作の域を出ていないというご指摘もあるだろうけど、これはこれで、これからいろいろ試したいアイデアが残っているので...\n\nコメント by yoriyuki:\n自然言語処理や機械学習も5年くらい前は論文一つ読んだだけの門外漢でも何かできそうな気がしましたが、今となってはとてもとても。Googleみたいな大企業が専門家を揃えて参入してくるのだから太刀打ち出来ません。\n自分が何で優位なのかを見極めないといけないですね。月並みですが。\n\nコメント by kiyoka:\nまとまりの無い記事だったのに、コメント頂けて幸いです。\n自然言語処理や機械学習の件は、私もそう思います。趣味でちょっとかじった程度の人間にはもうインパクトのあるものは作れそうにない気がします。\nよほど、奇を衒ったもの（要は役に立たないネタ的なもの）くらいしか作れないでしょうね。\n＞自分が何で優位なのかを見極めないといけないですね。月並みですが。\n本当にそう思います。\nこれまでの自分を振り返って、手を出したジャンルがバラバラで一貫していないので余計に自分の優位な部分って何なのかがよくわからなくなってきています。\n平均的に優秀なエンジニアではこの先やっていけいないことは目に見えているので、冷静に自己分析も必要ですね。\n誰もが抱える悩みではあると思いますが、自分も引き続き悩み続けることでしょう。\nコメント by yoriyuki:\n自然言語処理や機械学習も5年くらい前は論文一つ読んだだけの門外漢でも何かできそうな気がしましたが、今となってはとてもとても。Googleみたいな大企業が専門家を揃えて参入してくるのだから太刀打ち出来ません。\n自分が何で優位なのかを見極めないといけないですね。月並みですが。",
    "url": "/2010/6/22/2010-06-22-post/"
  },
  {
    "id": "2010-06-29-post",
    "title": "MacBook Pro上のsubversionとファイルシステムの準備",
    "date": "2010-06-29",
    "categories": [
      "Mac"
    ],
    "file_path": "_posts/2010-06-29-post.md",
    "content": "MacBook Proが手に入ってさっそく開発できるようにセットアップを行っている。\nこの記事は未来の自分の為のメモ。\nこの時作業したOSのバージョンは Snow Leopard (10.6.4)\nUTF-8-MAC問題の回避方法\nX Code 3.2に入っているsubversionクライアントはファイル名の濁点をUTF-8-MACとして処理する。\n 参考リンク:\n selflearn @ ウィキ - MacでのUTF-8-MAC問題を解決する\n解決方法は、MacPortsのsubversionをインストール時に +unicode_path オプションを指定すると濁点の処理が、Linux等と同様のアルゴリズムになるパッチが当たる。\n$ sudo port -v install subversion +unicode_path\n\n(MacPorts 1.9.1で確認済)\n大文字小文字問題の回避方法\n過去記事 ([kiyoka.2008_02_02]MacOSXMacOS XのSubversionでCodeReposがチェックアウトできない) と同じ問題。\n(要するにmakefileとMakefileという二つのファイルを同一のディレクトリ内に共存できない)\nそういうファイルは、時々オープンソースのソースコードパッケージ内に存在するので、オープンソースの作業をする場合は対処しておいた方が後々便利。\n作業はMacOS Xの『ディスクユーティリティ』というツールを使う。\n\n新しいパーティション作りを大文字小文字を区別できるファイルシステムでフォーマットする。上の例では \"CaseSensitive\"というパーティション名にしている。\nこの新しいパーティションでなら、makefile と Makefileという二つのファイルを同一ディレクトリ内に保存できるようになる。\nMacを買ってきてまだパーティションが汚れていないうちに、パーティション分割すればデフラグの様な作業も不要。",
    "url": "/2010/6/29/2010-06-29-post/"
  },
  {
    "id": "2010-06-30-post",
    "title": "末尾再帰最適化、実装完了",
    "date": "2010-06-30",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-06-30-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n先日「[kiyoka.2010_05_28]Nendo 末尾再帰最適化をどう実装するか」で悩んでいた末尾再帰最適化が解決した。\n結局Chaton上のGaucheのチャットルームで質問したら、shiroさんにcallccのないプラットフォーム上で末尾再帰最適化する方法を教えて頂いた。\n仕組みは簡単だけど、なぜそれで実現できるのかの説明が難しい。(自分的に)\n今回はその説明を試みてみる。「継続」などの専門用語を使わずに説明してみたい。\n末尾再帰最適化とは\nLisp(特にScheme)や関数型言語では再帰呼び出しを多様したプログラミングスタイルが推奨される。\n理由は、そのほうが手続き的スタイルでコーディングするよりも問題をより自然に表現できるから。(宣言的に書ける)\n問題は、言語処理系がなんの工夫もしていない場合、再帰呼び出しがスタックを消費するため、いずれスタックオーバーフローを起こすということ。\nそうならないため、Schemeなどの処理系は末尾再帰最適化を施して、再帰的記述を積極的に使えるようにしている。\n次の例で、再帰を使ったプログラムの例を挙げる。\n* mainループ: 自分自身を呼び出す無限ループの例\n一番シンプルな例では、関数の最後で自分自身を呼び出し無限ループを作る。\nSchemeなどではごく普通に使われる書き方で、Schemeのサブセットである[Nendo]もこのスタイルを推奨している。\n(define (main argv)\n ;; イベントキューから新しいイベントを取り出して処理する等\n (main argv)\n\nこのようなコーディングは、デーモンプロセスのようにメモリに常駐し半永久的に動き続けるようなプログラムで使われる。\n説明のために Rubyで再帰を使わずに記述すると、以下のようになる。\ndef main\n while true\n # イベントキューから新しいイベントを取り出して処理する等\n end\nend\n\nRubyでは処理系が末尾再帰最適化をサポートしていないため、このように書かないといけない。(実際にRubyは1.9.2になっても末尾再帰最適化はサポートしていない)\n* my-member?関数: リスト中に特定の値が含まれているか調べる関数\n上記のmainループの例では、宣言的に書けるというメリットが感じられなかった。どちらかというと、whileを使ったほうが自然なほどだ。\nしかし、プログラムによっては、再帰定義で記述するとプログラムを宣言的にすっきり記述できる。\n(define (my-member? val lst)\n (if (null? lst)\n #f\n (if (eq? val (car lst))\n #t\n (my-member? val (cdr lst)))))\n\nこの例では、my-member?自身を呼び出して、リストの先頭以外の調査を自分自身に丸投げしている。\n実行結果\n(my-member?\n 2\n '(1 2 3 4 5))\n\n=&gt; #t ;; リスト中に含まれていた\n(my-member?\n 6\n '(1 2 3 4 5))\n\n=&gt; #f ;; リスト中に含まれていなかった\n[Nendo]での末尾再帰最適化の実現方法\n* 末尾再帰最適化を施していない場合のイメージ\n[Nendo]はNendoのソースコード(S式)をいったんRubyのプログラムに変換する。今回の対策をする前は以下のようなコードを出力していたため、10000回の再帰が完了するまでに、Stackオーバーフローで停止していた。\nRubyでsimple_loop関数を再帰呼び出しするコードになっているので、当然だ。\n生成後のRubyソースコードイメージ(説明用に簡略化されている)\n#!/usr/local/bin/ruby\n#\n# non tail recursion optimization code.\n# =&gt; tail_recursion_normal.rb:X: stack level too deep (SystemStackError)\n#\n\ndef printCounter( count )\n m = count % 1000\n if 0 == m \n printf( &quot;count = %6d\\n&quot;, count )\n end\n count\nend \n\ndef main\n count = 0\n @_simple_loop = lambda {|dummy1|\n printCounter( count )\n count += 1\n if count &lt; 10000\n @_simple_loop.call(nil)\n end\n }\n @_simple_loop.call(nil)\nend\n\nmain\n\n実行結果\n$ ./tail_recursion_normal.rb\ncount = 0\ncount = 1000\ncount = 2000\ncount = 3000\n./tail_recursion_normal.rb:8: stack level too deep (SystemStackError)\n\n* 末尾再帰最適化を施した場合のイメージ\n遅延呼び出しリクエストパケット(DelayedCallPacketクラス)を使って末尾再帰最適化を実現した。\n以下のようなコードが生成される。\n実行しても、生成前の[Nendo]のスクリプトは再帰呼び出しでプログラミングしているにもかかわらず、スタックオーバーフローすることはない。\n※ 本当のNendoの内部では、可変長引数が扱えるため、下記のコードよりも複雑になっている。\n生成後のRubyソースコードイメージ(説明用に簡略化されている)\n#!/usr/local/bin/ruby\n#\n# tail recursion optimization with trampline and DelayedCallPacket\n#\n\nclass DelayedCallPacket\n def initialize( _proc, _arg1 )\n @proc = _proc\n @arg1 = _arg1\n end\n\n def call\n @proc.call( @arg1 )\n end\nend\n\ndef trCall( result )\n while result.is_a? DelayedCallPacket\n result = result.call()\n end\n result\nend\n\ndef printCounter( count )\n m = count % 10000\n if 0 == m \n printf( &quot;count = %6d\\n&quot;, count )\n end\n count\nend \n\ndef main\n count = 0\n @_simple_loop = lambda {|dummy1|\n trCall( printCounter( count ))\n count += 1\n if count &lt; 100000\n DelayedCallPacket.new( @_simple_loop, nil )\n end\n }\n trCall( @_simple_loop.call(nil) ) \nend\n\nmain\n\n実行結果\n$ ./tail_recursion_optimized_with_tramp.rb\ncount = 0\ncount = 10000\ncount = 20000\ncount = 30000\ncount = 40000\ncount = 50000\ncount = 60000\ncount = 70000\ncount = 80000\ncount = 90000\n .\n .\n .\n\n* 解説\n\n末尾再帰呼び出しと判断される箇所には関数呼び出しコードを出力せず、かわりに遅延呼び出しパケットを生成して返すコードを埋め込む。\n(DelayedCallPacketクラスのインスタンスを返す)\nそれ以外の関数呼び出しについては、いつ遅延呼び出しパケットが戻ってきても良いように、trCall()関数で括る。\ntrCall()関数は、遅延呼び出しパケットが戻って来なくなるまで繰り返し遅延された呼び出しを実行しつづける。(パケット以外の値はスルー)\n\n末尾再帰最適化をしていない場合の呼び出しツリーはこのようになり、いつか呼び出しスタックが溢れる。\nmain\n simple_loop\n simple_loop\n simple_loop\n simple_loop\n .\n\nそれに比べて、末尾再帰最適化を行った場合には次のようになる。\nmain\n trCall\n simple_loop\n simple_loop\n simple_loop\n simple_loop\n .\n\n一度trCall()関数に入れば 本来再帰呼び出しとなるところが、trCall()関数内のwhileループ内部からの連続呼び出しに変換される。\nなぜ、これで解決するかというと、遅延された再帰呼び出しを、トランポリン関数trCall()が、スタックを消費しない単純なループに変換して処理しているからだ。\nこれは継続か？\n遅延呼び出しパケットは継続を格納したパケットといえなくもない。参考:Scheme:CPS\nパケットはその時点での未来の実行継続ポイントでもある。\nSchemeの本物の継続(call/ccで取得できるもの)との大きな違いは、その実行継続ポイントとして関数の入り口しか扱えないという違いがある。\n(他にもいろいろ違いがあると思う。詳しい人、コメントください)\nまとめ\n末尾再帰呼び出しの実行を、呼び出し元に遅延させ、呼び出し元でループとして処理すればスタック消費をリダクションできる。(リソース消費の最適化)\n参考リンク\n末尾再帰 - Wikipedia",
    "url": "/2010/6/30/2010-06-30-post/"
  },
  {
    "id": "2010-07-02-post",
    "title": "高速化のアイデア",
    "date": "2010-07-02",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-07-02-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n関数呼び出しが重たいのがわかっている。\n例えば、現在の[Nendo]は関数の引数が1個の時でも、次のような引数変換用のcallProcedure関数を通る。\n callProcedure( '関数名', @_func, Cell.new( 1 ))\n\nこれを\n @_func.call( 1 )\n\nのように、目的のクロージャを直接呼びだす様にすれば、オーバーヘッドが無くなる。\nこれは計測の結果、ボトルネックだと確実に分かっている。\n(例えば、fib(20)が10倍ほども高速化された)\n先にsrfi-1等のポーティングをやってから取り掛かろう。",
    "url": "/2010/7/2/2010-07-02-post/"
  },
  {
    "id": "2010-07-05-post",
    "title": "srfiのポーティング(1)",
    "date": "2010-07-05",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-07-05-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nsrfi-1のポーティングに挑戦中。\nOlin Shiversさんのリファレンス実装はsyntax-rulesが使われていないが、call-with-current-continuation(継続)が使われている。\n リファレンス実装の情報はこちら: SRFI 1: List Library\n そして、ソースコードはこちら\nこれを、継続を使わない形式に書きなおしていく予定。\n継続が使われている理由を推測すると、おそらくmap関数などに長いリストを渡してもスタックオーバーフローしないようにしているのだろう。\nmapが一つのリストを受けとった場合については、末尾再帰で書くのは簡単だけど、複数のリストを受けとった場合も考慮すると、継続なしで効率の良いコードは書けない気がする。(セルの大量コピーが発生しても良いなら書けるかも)\nNendoについては、セルの大量コピー版でいくか...\nsrfi-1以外については[Nendo]はsyntax-rulesが未実装なので、syntax-rulesを先にサポートする必要が有りそう。\n外の処理系のsyntax-rulesの実装を見てまわっているが、Scheme自身で書かれていたり(chibi-scheme)、Rubyで書かれて言たり(heist)、いろいろだ。(Gaucheは何で書かれているのか読み切れなかった。どこに有るのか見つけられなかった。Gaucheはチューニングの工夫が入りすぎていて、簡単にソースが追えないなあ...)\nそれにしても、Scheme処理系の実装方法の幅は広いなあ。いろいろソースを読むのも楽しい。",
    "url": "/2010/7/5/2010-07-05-post/"
  },
  {
    "id": "2010-07-08-post",
    "title": "srfiのポーティング(2)",
    "date": "2010-07-08",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-07-08-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nOlin Shiversさんのリファレンス実装のポーティングの続き。\ncall-with-current-continuation(継続)を使わない様に書きなおした。\nちゃんとソースコードを読んだら、call-with-current-continuationが使われている理由は、map系関数の高速化の為だった。\nnull-listが渡されたら、早めに処理を中断してムダな計算をしないようにするため。\nそうと分かれば、書き換えは簡単。\nしかし、テストスイートをどうやって用意するかが問題だ。\n他の処理系から頂戴して来たいがライセンスとかがあるのでちょっと選別しないといけない。",
    "url": "/2010/7/8/2010-07-08-post/"
  },
  {
    "id": "2010-07-22-post",
    "title": "自宅サーバマシンが起動しなくなって、考えたこと",
    "date": "2010-07-22",
    "categories": [
      "サーバ管理"
    ],
    "file_path": "_posts/2010-07-22-post.md",
    "content": "このブログをホスティングしているサーバなので、しばらくブログが503になっていた。503といってもリーバイスでなくてhttpのリザルトコードのほうね。\n２年に一度くらい、マザーボードやハードディスクが故障する。\n大概マザーボードが故障することが多く、２年毎にマザーボードを新調することになる。(今回はオンボードのNICが死んだ模様)\nマザーボードを買うと、CPUソケットが新世代になってしまっているので、手持ちのCPUは捨てないといけいない。メモリも同様。\n結局２年に３万円ほどの出費と手間がかかっているのが現実なので、もうどこかのVPSでホスティングするという選択肢も考え中。\nやっと２年で３万円くらいで借りれるVPSが出てきたので、Kahuaだけを動かすならそちらに載せ替えても良いかな。\nファイルサーバはDropbox、メールはGmail、自分のこれまでのデータはMacBook Proに入れるようにすれば、もうLinuxサーバは不要なのかも。\nなんかクラウドって便利だなぁ。\nただ、その反面、そのサービスが終了したらオシマイというリスクもあるのでそこは考えようだなぁ。\nそれに、自分でサーバー維持してると、サーバーが落ちたタイミングで、障害解析したり最新のLinux Kernelやディストリビューションにアップグレードしたりしてノウハウが更新できて良い面もある。\nそんなサーバー周りのノウハウが役に立つかはわからないけど、実際に自分でやっておくと仮想化されたインフラを使う時、肌感覚として知っておくのと知らないのでは大きな差になるんじゃないかな。\nそんなこんなで、迷いつつ今回はサーバーを新調せずになんとかする方法を調査中だったりする。",
    "url": "/2010/7/22/2010-07-22-post/"
  },
  {
    "id": "2010-07-25-post",
    "title": "Nendo 0.3.3 リリース",
    "date": "2010-07-25",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-07-25-post.md",
    "content": "[Nendo] 0.3.3をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nあいかわらずチュートリアルと、リファレンスマニュアルはまだ書きかけですが...\n[Nendo.Tutorial] \n[Nendo.ReferenceManual] \n今回の目玉はsrfi-1のサポートと末尾再帰最適化でしょう。\nSRFI 1: リスト ライブラリはScheme単体では貧弱なリスト処理ユーティリティを増強するものです。\nScheme処理系のほとんどは、このライブラリをサポートしており、これが無いとそもそも処理系を使ってもらえないほどの必須ライブラリと言えます。\n末尾再帰最適化は、再帰的に記述したコードのスタックオーバーフローを軽減する機能でR5RS Schemeでは必須とされている機能です。それが[Nendo]にも入りました。\n例えば、以下のコードはスタックオーバーフローせず無限ループします。\n(define (foo)\n (foo))\n\n今後はR5RSのdefine-syntax define-rules等の健全なマクロを実装して、より多くのSRFIライブラリをサポートしていく予定です。\n[Nendo]は独自仕様のLisp処理系を作ろうとして開発を始めましたが、Scheme(R5RSですが)を参考にすればするほどSchemeはシンプルにまとまった良い仕様だということが分かってきて、現在はSchemeにどんどん近づいていっています。\n将来的にはRuby gemsを簡単に利用できるSchemeライクな言語という位置付けになりそうです。\n普段の利用シーンとして、ハイパフォーマンスなプログラムを作りたい場合は[Gauche]を、Ruby gemsで見つけたライブラリを使って手早くツールを書きたい場合は[Nendo]を使うという風に、二つの処理系をスイッチしてもあまりストレスが無いようにできればいいなあと思っています。",
    "url": "/2010/7/25/2010-07-25-post/"
  },
  {
    "id": "2010-07-26-post",
    "title": "『計算論 計算可能性とラムダ計算』を借りる",
    "date": "2010-07-26",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-07-26-post.md",
    "content": "図書館で借りれた。別の市町村にしかなかったので、図書館が又貸ししてくれた。\nそのおかげで、2週間での返却制限が付く。\nしかし、こんな数式だらけの本を2週間しか借りられないのはつらいなあ。\nたぶん、買うべきなんだろうけど。\n中をちらっと見てみたが、これを学習したからといって、役に立つかというと微妙かも。\n自作処理系がβ簡約とかの最適化を真面目にやるならたぶん役に立つだろう。\nHaskellはあまりやったことが無いので間違っているかも知れないが、Haskellとかでバリバリプログラミングする人はこの本でラムダ計算を学習しておくと、Haskellらしいコードが書けるのかも…\n買って積読しておくよりも、今回は流し読みして必要になるまで買わないことにしよう。",
    "url": "/2010/7/26/2010-07-26-post/"
  },
  {
    "id": "2010-07-29-post",
    "title": "『スタートダッシュ型仕事術』を見習いたい",
    "date": "2010-07-29",
    "categories": [
      "仕事術"
    ],
    "file_path": "_posts/2010-07-29-post.md",
    "content": "引用: Life is beautiful: スタートダッシュ型仕事術：実践編\n まず最初に言っておくと、「仕様がころころ変更になる」のはソフトウェア\n の宿命。どんなに頭の良い人が設計しても、「作ってみなければ分からない」\n 「使ってみなければ分からない」ことはどうしてもあるので、「アーキテクチャ\n の大幅な変更」「ユーザーインターフェイスの大幅な変更」があるのはあたり\n まえ。\n ぜひとも認識して欲しいのは、「だからこそスタートダッシュで肝となる部\n 分を一気に作って、早めに（仕様変更が必用かどうかの）見極めをする必用が\n ある」という点。特に「作って見なければ分からない」部分の見極めのための\n コーディングの時間を惜しんでいては、良いものは作れない。紙の上での設計・\n 仕様書作り・会議に時間をかければかけるほど、そのかけた時間そのものが足\n かせになって柔軟な発想ができなくなる。それよりも、発想が浮かんだ時点で\n 実際にコードを書いてみて「これで行けるかどうか」の実感をつかむことが大\n 切。\n(略)\nこの段階で大切なことは、\n\n書いたプログラムを捨てることを恐れないこと\nこの段階で仕様書を書くことは時間の無駄と認識すること\n細かなことを無視して、一番難しい部分を最初に作ること\nできるだけ早く、一気に「見極めが出来るところ」まで持って行くこと\nコードは多少汚くても良いが、モジュール間のインターフェイスだけはキチンと設計すること\n\nの５つである。とにかく、このプロセスの目的は、「このアーキテクチャのままで製品化できるのかどうか」「想定し\n ているユーザーシナリオに合致したものができるかどうか」の「見極め」をすることなので、それ以外のこと（たとえ\n ば仕様書を書く、ミーティングに出席する、ユーザーインターフェイスの細部を決めるなど）に時間を使わず、とにか\n く一日でも早く「見極め」ができるところまで持って行く。\n製品化されるプロジェクトでなくても同じだな...\nプロジェクトの一番のキモになる部分が自分の想定したイメージ通りかを先に試す必要がある。\nプライベートのプロジェクトでは自分の時間を投資しているわけだから、キモが実現出来るかどうかを早目に見極めて続けるか/やめるかを速い段階で決断しないといけないわけだし。\nこの記事を読んで、早速[Nendo]の開発の優先順位が変わった。\ndefine-rulesとかどうでもいいので(誰がいつやっても実装できるに決まっている) 先にRubyとの連携部分をもっと詰めるべきだと思った。\nよし。いろんなgemsを使ってみて問題点を洗いだし、先に解決していこう。(そのためにはそれなりに使えるツールを作る必要あり？)\nSRFIライブラリの充実とかは後でじっくりやればいいのだよな。(util.listだけは普段必要としているので先にポーティングするかも)",
    "url": "/2010/7/29/2010-07-29-post/"
  },
  {
    "id": "2010-07-30-post",
    "title": "Rubyのブロック構文をサポートした",
    "date": "2010-07-30",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-07-30-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\n新しく追加したブロック生成構文\n[Nendo]でRubyのブロックを生成する構文を追加した。\nRubyのブロック構文とは、以下のような {} で囲んだコード片(クロージャ)をメソッドに渡す構文である。\n# ファイルの１行目を読み込んで出力する\nopen( &quot;file.txt&quot; ) { |f|\n puts f.readline\n}\n\nRubyのライブラリにはブロックを受けとるメソッドが多く、[Nendo]からRubyのライブラリをまともに使おうと思ったら[Nendo]でブロックを生成する方法が必須となる。\nいろいろ考えた結果、&amp;block というプリミティブなキーワードを追加することにした。他に考えた案よりも、実装が簡単だった。\n([Nendo]のlambdaはRubyのブロックとは仮引数の渡しかたが違うため、[Nendo]/no lambdaをそのままブロックとして渡すことができない)\n&amp;blockの構文は lambda と類似しており (&amp;block (arg ...) body ...) のように \"lambda\"のかわりに\"&amp;block\" と書くだけ。\n上記のコードを[Nendo]で書くとこうなる。\n;; ファイルの１行目を読み込んで出力する\n(.open &quot;file.txt&quot; (&amp;block (f)\n (.puts (f.readline))))\n\nRubyでも別の書き方にすると、[Nendo]のコードと似た感じになるのはRubyに詳しい人ならご存知だろう。\n# ファイルの１行目を読み込んで出力する\nopen( &quot;file.txt&quot;, &amp;Proc.new { |f| \n puts f.readline\n} )\n\n※ 他にも (&amp; (lambda ...)) と書くとRubyのブロックに変換してくれるという案もあったけど、実装の簡単さと視認性が大きく変わらないという理由で上記のようにした。\nsortライブラリを楽して実現\n前から[Nendo]のために自前でsortアルゴリズムを書くのはいやだなと思っていた。\nせかっくRubyが組込みでsortを用意してくれているので、それを使わない手はない。かなりチューニングしてくれているハズだし。\n今回、ブロック生成構文を使って sort と sort-by ができた。\n(define (sort lst . cmpfn)\n (let1 cmpfn (get-optional cmpfn #f)\n (to-list\n (if cmpfn\n (lst.to_arr.sort (&amp;block (a b) (cmpfn a b)))\n (lst.to_arr.sort)))))\n\n(define (sort-by lst keyfn)\n (to-list\n (lst.to_arr.sort_by (&amp;block (item) (keyfn item)))))\n\nまとめ\n\n(&amp;block (arg ...) body ...) というRubyのブロックを生成できる構文を用意した。\nそれを使って[Nendo]のsortライブラリはRubyのsortをそのまま使えた。\n\nいろんなライブラリで、もうちょっと&amp;blockを試してみて、問題なさそうならこの仕様で行く予定。",
    "url": "/2010/7/30/2010-07-30-post/"
  },
  {
    "id": "2010-08-02-post",
    "title": "Gaucheのobject-applyのようなことをしたい",
    "date": "2010-08-02",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-08-02-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nGaucheでは次のようなことができる。Rubyでいうところの\n/abc/ =~ &quot;abc&quot;\n\nと同じ処理が\n(#/abc/ &quot;abc&quot;)\n\nのように書ける。\nこれは、Gaucheのリファレンスマニュアルをちゃんと読む前は、きっと内部(reader)で #/abc/ のリテラル部分がこんな感じのコードに変換されているのだろうと思っていた。\n(lambda (str)\n (rxmatch #/abc/ str))\n\nでも、以下の例ように引数に正規表現リテラルが来る場合はまずい。\n/abc/ 部分が (lambda ...) にされてしまったら、rxmatchはどう定義すればいいのか... いったい引数の型チェックはどうすればいいの？\n(rxmatch #/abc/ &quot;abc&quot;)\n\nで、Gaucheのリファレンスマニュアルを見ると、『適用可能なオブジェクト』という仕組みで実現されている。これは面白い。\n Gauche ユーザリファレンス: 6.16 制御\n6.16.2 適用可能なオブジェクト\nGaucheでは、特別な組み込みの機構によって任意のオブジェクトを「適用可能」\n にすることができます。\nGeneric Function: object-apply object arg …\n 手続きでもジェネリックファンクションでもないオブジェクトが何らかの\n 引数に適用されたとき、そのオブジェクトと引数がジェネリックファンク\n ションobject-apply に渡されます。\n\n この機能は、具体的な例を挙げた方が説明し易いでしょう。\n\n例えば、次のような式を評価しようとしたとします。\n (&quot;abcde&quot; 2) \n\nオペレータは文字列に評価されますから、手続きでもジェネリックファンクショ\n ンでもありません。そこで、Gaucheはこの式を、あたかも次のような式が与え\n られたかのように解釈します。\n (object-apply &quot;abcde&quot; 2) \n\nデフォルトでは、とを引数とする object-applyのメソッド\n は定義されていないので、この式はエラーになります。しかし、次のようなメ\n ソッドを定義すると：\n (define-method object-apply ((s ) (i ))\n (string-ref s i)) \n\n最初の式はまるで文字列が整数に適用されたかのように動作します。\n(\"abcde\" 2) → #\\c \n[Nendo]でGaucheのモノマネをしようとすると、マルチメソッドディスパッチャを実装しないといけないのかー。\nしかし、この仕組みは凄く柔軟性があって上述の (#/abc/ \"abc\") のような記述を拡張していけるので魅力的だ。\nただ、うまくマルチメソッドディスパッチを実装しないと非常に実行効率の悪いものが出来上がりそう....\n(Rubyでいうところの method_missing と同じように便利で強力だけど反面重いので気をつけて使えというものになりそう)\n[Nendo]でもマルチメソッドディスパッチとobject-applyを実装して実現するのは楽しそうだけど、いいのかな。\nもうちょっと考えてみよう。\n[Nendo]では、将来Rubyのクラスを定義できるようにするのか等、まだ考えきれていないところがたくさんあるので、それと合わせて考える必要があるなぁ。\n\nコメント by shiro:\nマニュアルへのパーマリンクはこんな感じで貼れますよ。p=の後の単語をindexから探してそこにジャンプするcgiになってます。\nhttp://practical-scheme.net/gauche/man/?l=jp&amp;p=object-apply\n\nコメント by kiyoka:\nshiroさん、ありがとうございます。\nブログ記事中のリンクをパーマリンクに直しておきました。\nコメント by shiro:\nマニュアルへのパーマリンクはこんな感じで貼れますよ。p=の後の単語をindexから探してそこにジャンプするcgiになってます。\nhttp://practical-scheme.net/gauche/man/?l=jp&amp;p=object-apply",
    "url": "/2010/8/2/2010-08-02-post/"
  },
  {
    "id": "2010-08-08-post",
    "title": "今創りたいもの(2) 『modeless SKK』",
    "date": "2010-08-08",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2010-08-08-post.md",
    "content": "以前に同様のタイトルで作りたいものをリストアップした。 ([kiyoka.2010_05_08]創作心理 今作りたいもの)\n[Nendo]の開発を進めながら、ここらで一旦アプリケーションを書いてみるというステージに戻るのも悪くないかなと思ってどんなものがいいか考えてみた。\n前にも書いたがSKKライクな日本語入力メソッドを試しに作ってみたいと思っている。\n私は普段、[Sumibi.org]という自作の日本語入力メソッドをEmacsから使っているが、少し不満が出てきた。\nやはり、自分の期待した使い勝手に到達していない。(いつも使っている上での感覚的な話)\nそこで一旦寄り道して、modelessなSKKを作ったらどんな使い心地なのかを試してみることにした。(曖昧検索機能もアリ)\nただし、試してみてSumibiを超えられそうにないようだったら、すぐにプロジェクト中止となるので、完成することを期待しないで頂きたい。\n個人的に[Nendo]のドッグフーディングの観点からすると、このお題はなかなか良いと自負している。\nKyotoCabinetというDBを使ったり、それなりに大量の件数のデータ(SKKのラージ辞書)を正規表現などを駆使して意味のあるデータに変換しないといけないので、処理系にとっては実用性が試される。\n現在KyotoCabinetとAmatchというgemライブラリを使ってローマ字綴りでの曖昧検索が使いものになるか試してみているところだが、1日程度で実験の土台ができたのは思っていたよりも早かった。\n([Nendo]の功績というよりも、使えるgemが豊富にあるというのが大きい)\n今後、曖昧検索の実験が進んだらブログ記事で紹介しよう。",
    "url": "/2010/8/8/2010-08-08-post/"
  },
  {
    "id": "2010-08-10-post",
    "title": "modeless SKK",
    "date": "2010-08-10",
    "categories": [
      "創作心理"
    ],
    "file_path": "_posts/2010-08-10-post.md",
    "content": "modeless SKKのプロトタイプの作成中。Sekka:石火(仮名)\n\n曖昧検索の評価\nプロトタイプといっても、曖昧検索がどれくらい効果的かという実験をしようとしているところ。\n曖昧検索というのはGoogle検索の『もしかして』機能をイメージしてもらえれば良いかと思う。それをローマ字の綴りに限定したもの。\n昔からある yc.el や ゆでたまご等の modeless 入力メソッドの弱点は、目視では変換前のローマ字綴り間違いに気づきにくいというところ。\n例えば、『しぜんげごしょり』なら間違いにきがつきやすいが、『shizengegosyori』では全くどこが抜けたのかわからないだろう。\n今回の曖昧検索を modeless SKK に適用すれば、上のキーワードでも『自然言語処理』を変換候補にすることが可能だ。\nさて、実装だが、SKKのラージ辞書 (SKK-JISYO.L) をローマ字をキーに検索できるようにし、辞書に入っているローマ字と、ユーザー入力のローマ字のJaro-Winkler距離が近い方から列べるとどんな具合いかを見た。\n結果はなかなか脈ありな感じ。\n以下に実行結果を載せているけれども、\n『雰囲気』に対するローマ字クエリとしてfunnikiでもfunikiでも、さらに間違ったfuinkiでも救えていたり、『漢字変換』に対しては kajinhenkan や kanjihekan を救えているのはいいかも。\n実験の様子\n\nJaroW()がJaro-Winklerの距離(値域 0.0 ≦ 1.0)\n閾値 = 0.940000 は JaroWの値での足切り値\n\n$ ./aimai\n&gt; henkan\n閾値 = 0.940000 探索件数(1176)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *henkan*:*変換/返還*\n JaroW(0.96667) Jaro(0.94444) PairD(0.88889) *henka*:*変化/返歌*\n JaroW(0.95000) Jaro(0.91667) PairD(0.83333) *henkango*:*変換後/返還後*\n JaroW(0.95000) Jaro(0.91667) PairD(0.83333) *henkanbu*:*変換部*\n JaroW(0.95000) Jaro(0.91667) PairD(0.66667) *henkabun*:*変化分*\n JaroW(0.95000) Jaro(0.91667) PairD(0.83333) *henkanji*:*変換時*\n JaroW(0.95000) Jaro(0.91667) PairD(0.83333) *henkanki*:*変換器/変換機*\n JaroW(0.95000) Jaro(0.91667) PairD(0.66667) *henkaten*:*変化点*\n JaroW(0.95000) Jaro(0.91667) PairD(0.66667) *henkouan*:*変更案*\n&gt; henkann\n閾値 = 0.940000 探索件数(1176)\n----------\n JaroW(0.97143) Jaro(0.95238) PairD(0.90909) *henkan*:*変換/返還*\n JaroW(0.95556) Jaro(0.92593) PairD(0.71429) *henkanten*:*変換点*\n JaroW(0.94286) Jaro(0.90476) PairD(0.80000) *henka*:*変化/返歌*\n JaroW(0.94000) Jaro(0.90000) PairD(0.66667) *henkantani*:*変換単位*\n&gt; funiki\n閾値 = 0.940000 探索件数(2851)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *funiki*:*雰囲気/氛圍氣;「雰」別字、「囲」「気」旧字*\n JaroW(0.97143) Jaro(0.95238) PairD(0.72727) *funinki*:*不人気*\n JaroW(0.94167) Jaro(0.91667) PairD(0.66667) *funehiki*:*船引*\n JaroW(0.94167) Jaro(0.91667) PairD(0.66667) *funabiki*:*船曳*\n&gt; funniki\n閾値 = 0.940000 探索件数(2851)\n----------\n JaroW(0.96667) Jaro(0.95238) PairD(0.90909) *funiki*:*雰囲気/氛圍氣;「雰」別字、「囲」「気」旧字*\n JaroW(0.96667) Jaro(0.95238) PairD(0.66667) *funinki*:*不人気*\n&gt; fuinki\n閾値 = 0.940000 探索件数(2851)\n----------\n JaroW(0.95556) Jaro(0.94444) PairD(0.40000) *funiki*:*雰囲気/氛圍氣;「雰」別字、「囲」「気」旧字*\n&gt; tokyo\n閾値 = 0.940000 探索件数(3795)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *tokyo*:*トーキョー/東京*\n JaroW(0.96667) Jaro(0.94444) PairD(0.88889) *tokyou*:*都響;[略語*東京都交響楽団]\n JaroW(0.96111) Jaro(0.94444) PairD(0.66667) *tokiyo*:*時世*\n JaroW(0.96111) Jaro(0.94444) PairD(0.88889) *tokkyo*:*特許*\n JaroW(0.95333) Jaro(0.93333) PairD(0.57143) *toko*:*床/常*\n JaroW(0.94667) Jaro(0.93333) PairD(0.57143) *toyo*:*豊/樋/豐;「豊」の旧字*\n&gt; toukyouto\n閾値 = 0.940000 探索件数(3795)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *toukyouto*:*東京都*\n JaroW(0.95556) Jaro(0.92593) PairD(0.75000) *toukyougo*:*東京語*\n JaroW(0.95556) Jaro(0.92593) PairD(0.85714) *toukyou*:*東京/東教*\n JaroW(0.95000) Jaro(0.91667) PairD(0.84211) *toukyoutomin*:*東京都民*\n JaroW(0.95000) Jaro(0.91667) PairD(0.84211) *toukyoutonai*:*東京都内*\n JaroW(0.95000) Jaro(0.91667) PairD(0.84211) *toukyoutosyo*:*東京図書*\n&gt; tokyoto\n閾値 = 0.940000 探索件数(3795)\n----------\n JaroW(0.94286) Jaro(0.90476) PairD(0.80000) *tokyo*:*トーキョー/東京*\n JaroW(0.94074) Jaro(0.92593) PairD(0.57143) *toukyouto*:*東京都*\n&gt; change\n閾値 = 0.940000 探索件数(4109)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *change*:*チェンジ*\n JaroW(0.97143) Jaro(0.95238) PairD(0.90909) *changer*:*チェンジャー*\n JaroW(0.96667) Jaro(0.94444) PairD(0.88889) *chang*:*チャン/チャング*\n JaroW(0.95000) Jaro(0.91667) PairD(0.83333) *changeup*:*チェンジアップ*\n&gt; chance\n閾値 = 0.940000 探索件数(4109)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *chance*:*チャンス*\n&gt; tokugawaie\n閾値 = 0.940000 探索件数(3795)\n----------\n JaroW(0.96000) Jaro(0.93333) PairD(0.87500) *tokugawa*:*徳川*\n JaroW(0.96000) Jaro(0.93333) PairD(0.77778) *tokugawake*:*徳川家*\n JaroW(0.96000) Jaro(0.93333) PairD(0.77778) *tokugawaki*:*徳川期*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaienari*:*徳川家斉;11th(1787-1837)*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaienobu*:*徳川家宣;6th(1709-12)*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaiemitu*:*徳川家光;3rd(1623-51)*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaietugu*:*徳川家継;7th(1713-16)*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaietuna*:*徳川家綱;4th(1651-80)*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaieyasu*:*徳川家康;1st(1603-05)*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaieharu*:*徳川家治;10th(1760-86)*\n JaroW(0.94286) Jaro(0.90476) PairD(0.81818) *tokugawaiesada*:*徳川家定;13th(1853-58)*\n&gt; gengosyori\n閾値 = 0.940000 探索件数(1487)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *gengosyori*:*言語処理*\n JaroW(0.95385) Jaro(0.92308) PairD(0.85714) *gengosyorikei*:*言語処理系*\n&gt; nihongo\n閾値 = 0.940000 探索件数(2278)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *nihongo*:*日本語*\n JaroW(0.95556) Jaro(0.92593) PairD(0.85714) *nihongoon*:*日本語音*\n JaroW(0.95556) Jaro(0.92593) PairD(0.85714) *nihongoka*:*日本語化/日本語可*\n JaroW(0.94286) Jaro(0.90476) PairD(0.80000) *nihon*:*日本/二本*\n JaroW(0.94286) Jaro(0.90476) PairD(0.83333) *nihonga*:*日本画*\n JaroW(0.94286) Jaro(0.90476) PairD(0.83333) *nihongi*:*日本紀;六国史、または日本書紀のこと*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *nihongoban*:*日本語版*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *nihongobun*:*日本語文*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *nihongomei*:*日本語名*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *nihongofuu*:*日本語風*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *nihongoron*:*日本語論*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *nihongotuu*:*日本語通*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *nihongoyou*:*日本語用*\n JaroW(0.94000) Jaro(0.90000) PairD(0.66667) *nihonsaigo*:*日本最後*\n&gt; kanakanji\n閾値 = 0.940000 探索件数(7813)\n----------\n JaroW(1.00000) Jaro(1.00000) PairD(1.00000) *kanakanji*:*かな漢字/仮名漢字*\n JaroW(0.95556) Jaro(0.92593) PairD(0.85714) *kanakan*:*かな漢/仮名漢*\n&gt; kanakannji\n閾値 = 0.940000 探索件数(7813)\n----------\n JaroW(0.98000) Jaro(0.96667) PairD(0.94118) *kanakanji*:*かな漢字/仮名漢字*\n JaroW(0.94000) Jaro(0.90000) PairD(0.80000) *kanakan*:*かな漢/仮名漢*\n&gt; kanakenji\n閾値 = 0.940000 探索件数(7813)\n----------\n JaroW(0.95556) Jaro(0.92593) PairD(0.75000) *kanakanji*:*かな漢字/仮名漢字*\n&gt; kajinhenkan\n閾値 = 0.940000 探索件数(7813)\n----------\n JaroW(0.97576) Jaro(0.96970) PairD(0.70000) *kanjihenkan*:*漢字変換*\n&gt; kanjihekan\n閾値 = 0.940000 探索件数(7813)\n----------\n JaroW(0.96182) Jaro(0.93636) PairD(0.84211) *kanjihenkan*:*漢字変換*\n JaroW(0.94000) Jaro(0.90000) PairD(0.66667) *kanjika*:*漢字化*\n&gt; q\nquit.\n$ \n\n参考資料\nJaro–Winkler distance - Wikipedia, the free encyclopedia (英語)\n AWK Users JP :: Jaro-Winkler 距離の計算\n スペルミス修正プログラムを作ろう\nソースコード\n[Nendo]で書いている。ライブラリはKyoto Cabinetとamatchを使っている。\n src/aimai at d537aa2d48789eaca6aa8de7301b84a0ae2819b4 from kiyoka's sekka - GitHub\n課題\n送り仮名の綴り間違いをどうするかが課題だなあ。",
    "url": "/2010/8/10/2010-08-10-post/"
  },
  {
    "id": "2010-08-12-post",
    "title": "TDD(テスト駆動開発)の重要性",
    "date": "2010-08-12",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-08-12-post.md",
    "content": "実験中の新しい日本語入力メソッド Sekka(仮名)を[Nendo]で作ろうとしているが、そのために[Nendo]に足りない機能を足している。\nSekkaはちゃんとTDD(テスト駆動開発)で開発していく予定なので、unit testフレームワークが必要になった。\nそこで、gauche.testの基本機能をポーティングしたところ。\n リンク: Gauche ユーザリファレンス: 9.22 gauche.test - 単体テスト\n実は、恥ずかしながらSumibi.orgはunit testの様に再現可能なテストスイートは持っていないので、ソースコード規模が大きくなるほどメンテナンスに対する心理的負担が大きくなっていった。リファクタリングもなかなか困難になっていた。\n[Nendo]で完全にTDDを実践し、いまではTDD以外の開発は考えられなくなった。プログラミング言語処理系の開発にはテストスイートが必須だと思う。おそらく複雑なアルゴリズムを使ったソフトウェアには同様にそれなりの量のテストスイートが無いとどこかで必ず開発が破綻するだろう。\nSekkaもTDDで開発していつでもリファクタリングできる状態を維持しよう。\n参考: テスト駆動開発 - Wikipedia",
    "url": "/2010/8/12/2010-08-12-post/"
  },
  {
    "id": "2010-08-24-post",
    "title": "Rackについて学ぶ",
    "date": "2010-08-24",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2010-08-24-post.md",
    "content": "現在、新しい日本語入力メソッド(Sekka)を試作中なのだが、サーバとクライアントの通信はHTTPにしようと考えている。([Sumibi.org]もHTTPであったが)\n 日本語入力メソッドは[Nendo]で書いているので、WebサーバはRubyで書かれたものが使える。というか使えるようにする。\nその中でも、Ruby界ではRackというフレームワークが標準になっているようなので、それを試しに使ってみることにした。\n\nRackって何? という方はこのyharaさんの良記事を読んで頂ければ即理解できるだろう。\n Route 477 - 5分でわかるRack , シュレーディンガーの猫たち\n今は、それに合わせて、[Nendo]の世界で定義したLisp関数をRubyから呼び出す手段を準備中。\nこんな感じで、[Nendo]にちょこちょこ手を入れつつ、日本語入力メソッドを作りつつ、Rubyのライブラリについて学ぶという有意義なループを回している。\nそれにしてもRubyのコミュニティーはRailsからハジケて金回りが良くなっているからか、どんどんライブラリが整備されてきているのでいろいろ便利になっているなぁーと実感する。\nこれは学習して利用しない手は無いぞぅ。\nその他参考記事:\n Ruby Freaks Lounge：第23回　Rackとは何か（1）Rackの生まれた背景｜gihyo.jp … 技術評論社\n Ruby Freaks Lounge：第24回　Rackとは何か（2）Rackの使い方｜gihyo.jp … 技術評論社\n Ruby Freaks Lounge：第25回　Rackとは何か（3）ミドルウェアのすすめ｜gihyo.jp … 技術評論社",
    "url": "/2010/8/24/2010-08-24-post/"
  },
  {
    "id": "2010-08-25-post",
    "title": "Nendoで定義した関数をRubyから呼べるようになった",
    "date": "2010-08-25",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-08-25-post.md",
    "content": "私がRubyで書いているLisp方言、 [Nendo]について。\nタイトルの通り、[Nendo]で定義した関数をRubyから呼べるようになった。\nこれで、Nendoで書いたコードをRubyのライブラリとして呼べるようになる。\n以下はサンプルプログラム * export-lisp-functions.rb *\n#!/usr/local/bin/ruby\n\nrequire 'nendo'\n\ndef main\n core = Nendo::Core.new()\n core.loadInitFile\n lst = * &quot;a&quot;, &quot;b&quot;, &quot;c&quot;,\n [ &quot;d&quot;, &quot;e&quot; *.to_list\n ].to_list\n core.evalStr( '(define (sexpToString sexp) (write-to-string sexp))' )\n core.evalStr( '(export-to-ruby sexpToString)' )\n core.evalStr( '(use text.tree)' )\n core.evalStr( '(define (treeToString sexp) (tree-&gt;string sexp))' )\n core.evalStr( '(export-to-ruby treeToString)' )\n puts core.sexpToString( lst )\n puts core.treeToString( lst )\nend\n\nmain\n\nNendoの世界で (export-to-ruby シンボル) と宣言すると、Nendo::Coreクラスのインスタンス(サンプルでは core) に同名のメソッドが動的に増えるのだ。\n動的にメソッドが生えるというのはなんか気持ち悪いけれど、Rubyの世界では普通なのです。ほんとほんと。\n※ 現状は、引数の数が固定の関数しか export できないルールにしている。まあ困らんだろう。\n実行結果\n$ ./export-lisp-functions.rb \n(&quot;a&quot; &quot;b&quot; &quot;c&quot; (&quot;d&quot; &quot;e&quot;))\nabcde\n\nこれで、Nendoで書いたアプリを、RackやSinatra(Webアプリケーションフレームワーク)に乗せることができるようになったはず。\n早速、Sekkaという新しい日本語変換エンジンをのせていくところから始める予定。",
    "url": "/2010/8/25/2010-08-25-post/"
  },
  {
    "id": "2010-08-27-post",
    "title": "Sekkaを[Rack](http://rack.rubyforge.org/)に載せて、試験運用中",
    "date": "2010-08-27",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-08-27-post.md",
    "content": "現在、新しい日本語入力メソッド(Sekka)を開発中だ。\nとりあえずRackに載せることができた。(結局先日書いた方法で[Nendo]の定義関数をRackからうまく呼びだすことができたのである)\n\nsekka.elを1日程度ででっちあげて、このブログはEmacs+Sekkaで書いている。(勝手知ったるsumibi.elを改造したのでそんな期間でできたのだが…)\nまだまだ使いにくい所がたくさんあるので、結論は出しにくいけれど、まあまあ希望が持てそうな使い心地だ。\nSKKを使ってきた人なら数分もあれば、慣れるんじゃないかと思う。\nSekkaはこの2010年という統計的自然言語処理全盛の時代にあって、統計的処理をほとんど使わない。(ローマ字キーワードの曖昧検索を使っているが、それは統計処理ではない)\n要するに時代を逆行する日本語入力メソッドなので、今開発すること自体どうなのかと思うところはあるけれど、Google日本語入力のような凄いものが出てきた今だからこそ、逆を狙うのも面白いのではないかと思う。\n私は立場的に自然言語処理の研究者でもないし、特に咎められることは無い。\nそれにしても、はやくも小指が痛くなってきたぞ。これがSKKライクな入力方式の最大の欠点だ。\nこれを解決する手段を早く考えないといけない…(笑)\nSticky-Shiftという手段があるそうで、それで緩和するのかどうかも試してみる予定だけど、もっといいアイデアは無いかなぁ。",
    "url": "/2010/8/27/2010-08-27-post/"
  },
  {
    "id": "2010-08-30-post",
    "title": "Sticky-shiftを試してみたら、小指が痛くなくなった。",
    "date": "2010-08-30",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-08-30-post.md",
    "content": "Sekka(石火)はSKKと同じように、大文字で送り仮名の位置を指定するので、SKKと同じで Shiftキーを使いすぎて小指が痛くなるという問題がある。\n例えば、\"行う\" を入力したい場合はローマ字で、 \"OknaU\" と入力しないといけない。\nOkonaU*Ctrl-J*\n\nと入力すると\n行う\n\nという文字列に変換される。(Ctrl-Jキーはカーソル位置の直前のローマ字を日本語に変換するキー)\nこの小指酷使問題に決着を付けるべく、SekkaでSticky-shiftを使えるようにしてみた。\n\";\" というキーがShiftの代わりの役割をするのだが、本物のShiftキーとの違いは、Shiftを押しっぱなしにしなくても良いところだ。\n例えば、 \"A\" を入力したい場合、 \";\" と \"a\" を順番に入力すれば \"A\" になる。\n上記の例の、\"行う\"を入力する場合は、\n;okona;u*Ctrl-J*\n\nと入力すればよい。\n結論としては、小指を酷使することがなくなって小指が痛くなる問題がなくなった。\nこれでSekkaによる快適な日本語入力ライフが送れそうだ。\nSekkaはあくまで実験的な日本語入力メソッドなので、まだリリースの形がイメージできていないが、多分始めのうちは、gem installして動かすというものになりそう。\nまだまだ先になりそうだけど。\n使ってみたい人はどれくらいいるのかなぁ。かなりニッチな入力方法だと思うのだけど…",
    "url": "/2010/8/30/2010-08-30-post/"
  },
  {
    "id": "2010-09-06-post",
    "title": "個人的なNoSQL(KVS)のライセンス調査",
    "date": "2010-09-06",
    "categories": [
      "KVS"
    ],
    "file_path": "_posts/2010-09-06-post.md",
    "content": "[Sekka]をBSDLにしたいのと、将来どこかのSaaSでホスティングしたいという観点から、どのNoSQL DBを選べば良いか調査してみた。\nドライバはRubyのみを想定している。\nまた、SekkaはRuby 1.9.xでしか動かないので、1.9.x に対応したドライバが欲しい。\nちょっと偏ったコメントが混ざっているので、その点だけご注意下さい。\n\nポイントは、SekkaサーバにリンクするドライバのライセンスがGPL2 or GPL3以外のものであること。\nちなみに現在開発中のSekkaで使っているKyotoCabinetはRubyのクライアントライブラリがGPL3なのですでにNG。\nKyotoCabinetの商用ライセンスを買えばOKになるが、目的は配布するSekkaをBSDLにすることなので、そのオプションは無しとする。\nまた、今後の運用のことを考えて、なるべくSaaS環境で利用できるDBを優先して選択したい。\nそんなわけで、最近流行りにNoSQLサーバを順番に当たってみた。\nmemcached\n永続化機能が無いので、Sekkaの辞書DBには利用できない。\nしかし多くのDBがこのmemcachedの互換プロトコルをサポートしているので、クライアントだけ調査しておく。\nライセンス的にも修正BSDLなので問題ない。\nもしかしたら、Sekkaがこの互換プロトコルの範囲で十分やっていけるのであれば、DBを選ばないこのライブラリがベストという可能性もある。\n- クライアントライブラリ: gem install memcache-client でインストール可能。\n- ライセンス: 修正BSDL (3条項)\n- Ruby1.9.x対応: 〇\nmemcachedb\n上記のmemcachdに永続化機能を追加したもの。\n- memcachedの互換プロトコル: 〇\nKyoto Cabinet\n現在も活発に開発が進んでいるDBである。\n高速だし、Rubyから使いやすいので、ライセンスの問題が無ければこのDBを使い続けたかった。\n- クライアントライブラリ: kyotocabinet-ruby-1.17.tar.gz\n- ライセンス: × GPLv3\n- Ruby1.9.x対応: 〇\n- memcachedの互換プロトコル: × \n- 提供SaaSベンダ: なし\nTokyo Cabinet\n開発はKyoto Cabinetに移行しているはずなので、今更使いたくない。\nライセンスはLGPLのためGPL感染せず問題ない。\nmemcachedのクライアントからアクセスするという方法もある。\n- クライアントライブラリ: tokyocabinet-ruby-1.30.tar.gz\n- ライセンス: 〇 LGPLv2.1\n- Ruby1.9.x対応: ？\n- memcachedの互換プロトコル: 〇\n- 提供SaaSベンダ: EngineYard\nmongoDB\nHeroku上でmongoHQというadd-onsで利用可能なので、SaaS環境もOK。\n少し、RDBMSに近い使いかたもできるので、将来的にも学習のしがいがある。\nパフォーマンスがKyoto Cabinetoに比べて遜色無いかどうかは不明。\n- クライアントライブラリ: gem install mongo でインストール可能。\n- ライセンス: 〇 Apache License 2.0\n- Ruby1.9.x対応: ？\n- memcachedの互換プロトコル: × \n- 提供SaaSベンダ: mongoHQ(herokuのオプションとして使用可能)\ncouchDB\nクライアントは、複数ある(RubyLibrary - Couchdb Wiki)ようだ。\nあまり、高速ではないという噂があるので、Google Suggestのようなリアルタイム検索が主体のSekkaには向いていないと思う。\n- クライアントライブラリ: 例えば、CouchObject であれあば\n- ライセンス: 〇 MIT\n- Ruby1.9.x対応: ？\n- memcachedの互換プロトコル: × \n- 提供SaaSベンダ: Cloudant: CouchDB hosting(herokuのオプションとして使用可能)\nKumofs\n特に、専用クライアントは無いようだ。memcahced互換プロトコルなので、memcachedクライアントを使う。\n- memcachedの互換プロトコル: 〇\nROMA\nまだまだ、楽天以外で使っているという声を聞いたことがないROMA。\nまだ使うべきではない気がする。クライアントライセンスが何故 GPLv3 なのか。\n楽天以外で使ってもらう気があるのであれば、ライセンスを変更したほうがいいと思うけど、そこまで言うのはおせっかいか。\n但し、memcached互換プロトコルでアクセスできるらしいので、上記Kumofsと同じになる。\n- クライアントライブラリ: gem install roma-client でインストール可能。\n- ライセンス: × GPLv3\n- Ruby1.9.x対応: ？\n- memcachedの互換プロトコル: 〇\nCassandora\nクライアントライブラリが、ThriftからAvroに移行していくらしいのだが、用途としてはちょっと大袈裟で合わない感じがする。\n使う気は無いのでスルー。\nredis - Project Hosting on Google Code\n参考:永続化対応のインメモリDB「Redis」が登場\nKyoto CabinetよりももっとInMemory DBの要素を強くした感じのDB。\n複数のサーバ間で、数分おきにDISKに書きこむなどの仕組みを持つ。\nmemcahced互換プロトコルではないので、どうかとも思ったが、EngineYardとherokuの両方がサポートしている。\n- クライアントライブラリ: gem install redis でインストール可能。\n- ライセンス: 〇 the very liberal BSD license\n- Ruby1.9.x対応: 〇\n- 提供SaaSベンダ: EngineYard、heroku\n- memcachedの互換プロトコル: ×\nAmazon SimpleDB - Wikipedia\nSekkaには向いていないかも。Amazonにロックインされるという問題もあり。\n以下略。\nHypertable - Wikipedia\nBigtableの互換オープンソース製品。SekkaをJRuby+GAEで動かす予定ならこれもあり。\nまだまだRubyでGAEを利用しようとすると、パフォーマンス面で苦労するそうなので、スルー。\n以下略。\n後、数日考えてみて、どうするか決めよう。\nmongoDBかredis対応が優勢かな。それともmemcachedとredisの両方のクライアントで動くようにしておこうかな。",
    "url": "/2010/9/6/2010-09-06-post/"
  },
  {
    "id": "2010-09-09-post",
    "title": "Nendo 0.3.4 リリース",
    "date": "2010-09-09",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-09-09-post.md",
    "content": "[Nendo] 0.3.4をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nチュートリアルと、リファレンスマニュアルを少し加筆しました。\nまだまだ ##(todo)項目が多いですが、最低限の情報は記載したつもりです。(それから、そのうち英語版も作らないといけないですね…)\nかなりの部分で、[Gauche]のAPIを参考にしているので迷ったらGaucheのユーザリファレンスを参照していただくと解決すると思います(笑)\n[Nendo.Tutorial] \n[Nendo.ReferenceManual] \n今回のポイントはgemライブラリを利用する上で全般的に足りなかった機能が追加されたことでしょう。\n0.3.3以後はKyoto Cabinetを使った[Sekka]という日本語入力メソッドを作りながら足りない部分を補いました。\n中でも、 (&amp;block ...)構文は重要な機能追加です。\n(&amp;block ...) 構文を使えば、Rubyのブロックその物が生成可能です。\n&amp;block構文を用意した理由は、多くのRuby gemライブラリがブロックを引数に取るメソッドを持っているためです。\n例えば、入力テキストsample.rb の全行をコメントアウトするプログラムは以下のように書くことができます。\n Ruby\nopen (&quot;sample.rb&quot; ) {|f|\n f.readlines.each {|line|\n puts &quot;# &quot; + line.chop\n }\n}\n\nNendo\n(.open &quot;sampel.rb&quot;\n (&amp;block (f)\n (f.readlines.each\n (&amp;block (line)\n (print (&quot;# &quot; + (line.chop)))))))\n\n次は、Kyoto CabinetのAPIを使う例です。\n Ruby\n#!/usr/local/bin/ruby\n# -*- coding: utf-8 -*-\n\nrequire 'kyotocabinet'\ninclude KyotoCabinet\n\ndb = DB::new\n\n# データベースを開く\nunless db.open('numbers.kch', DB::OWRITER | DB::OCREATE)\n printf(&quot;open error: %s\\n&quot;, db.error)\nend\n\n# 書きこみ\n(0..99999).each { |num|\n db* num * = num\n}\n\np db*1000*\np db*10000*\n\nNendo\n#!/bin/sh\n:; #-*- mode: nendo; syntax: scheme -*-;;\n:; exec /usr/local/bin/nendo $0 $*\n\n(require &quot;kyotocabinet&quot;)\n\n(define db (KyotoCabinet::DB.new))\n\n(define (main argv)\n (define (_create)\n (if (not (db.open &quot;numbers.kch&quot; (+ KyotoCabinet::DB::OWRITER KyotoCabinet::DB::OCREATE)))\n (printf &quot;open error: %s\\n&quot; db.error)\n ;; 書きこみ\n (Range.new 0 99999\n (&amp;block (num)\n (db.store num num)))))\n (_create)\n (print (hash-table-get db 1000))\n (print (hash-table-get db 10000)))\n\n何とか、使える処理系に近づいてきた気がしませんか？(速度は別にして…)\n今後もアプリケーションを作りながら、少しづつ実用的な処理系にしていく予定です。",
    "url": "/2010/9/9/2010-09-09-post/"
  },
  {
    "id": "2010-09-10-post",
    "title": "Web+DBのRails3特集が良い",
    "date": "2010-09-10",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2010-09-10-post.md",
    "content": "WEB+DB PRESS vol.58 はオススメ。\n自分はRailsで開発したことは無いのだけど、この特集は現在のRailsがどのようなものかを全方位で把握できる素晴しい特集だ。\nPHPとか、RubyとかJavaとか別の言語でWebアプリを作っている人も読んどいて損は無いと思う。今迄Railsを横目に見ていたひとは特に。\n今後はスーツな人の間でもWebアプリというとRailsが候補に挙がる状況が想像できるので、チラ見しておこう。\nRails2と違ってRails3は相当モジュラリティが上がっているようで、どんな部品を組みあわせてもRailsに収容されてしまう。\n自分に関係するところでは、仕事でRails3を使うということもそうだけど、Rails3にNendoを組み込むこともできそうだ。\n今回の特集はRubyで[Nendo]という処理系を作っている関係上、Railsに親近感を持てるようになった。\nRails3でちょっとアプリを作ってみて、感覚を掴んだらNendoとtext.htmlでView部分をコーディングしてみようかな。\nKahuaライクなEmacsからreplする開発スタイルが簡単に構築できたらいいな。",
    "url": "/2010/9/10/2010-09-10-post/"
  },
  {
    "id": "2010-09-17-post",
    "title": "小さなチーム、大きな仕事",
    "date": "2010-09-17",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-09-17-post.md",
    "content": "図書館で借りた。最近は近隣の図書館(大阪府立図書館など)からも探して貸してくれるので便利になった。\nこの本を読んで、ビジネス用途のアプリサイトを作ってみたいと本気で思った。勿論それで儲けることができ、うまくいけば生活できるようなものを想定している。\n一番の収穫は、自分がビジネスについて勘違いをしていたことに気づかさせてくれた事。\n「どんな良いビジネスアプリケーションサイトを作っても、大手がそのうちクローンを作ってきて自分の弱小サイトなんか潰される」とぼんやり思っていたけど、その不安は杞憂だと分かったこと。\nそう。数人で回しているサイトのクローンを大手が作ろうコスト構造が違うので無理なんだよな。\n自分も中堅のソフトウェア開発企業にいて、肌感覚で知っているけれども、中堅以上の企業というのは管理費やら何やらで弱小企業がやっているアプリのクローンを作っても決して利益が出せない宿命なのだ。\nそうそう、今の時代、クラウドがあるので個人もしくは数人で回すというのはアリというより、むしろ有利な時代になってきたのかもしれん。\nアイデアはあるので、いっちょやってみるかな。\nまずは、自分が欲しいアプリケーションをメモ用紙にスケッチして本当に欲しいのか確認するところから始めよう。",
    "url": "/2010/9/17/2010-09-17-post/"
  },
  {
    "id": "2010-09-18-post",
    "title": "NoSQL(KVS)の選定の続き",
    "date": "2010-09-18",
    "categories": [
      "KVS"
    ],
    "file_path": "_posts/2010-09-18-post.md",
    "content": "先日の記事 「[kiyoka.2010_09_06]KVSSekka 個人的なNoSQL(KVS)のライセンス調査」で、[Sekka]用のKVSをどれにすればいいのかという件について書いた。\n選定の観点は、二つだった。\n[Sekka]をBSDLにしたい(BSDLにしたい理由は、[Sekka]で書いたコードを[Nendo]に輸入したいため)\n将来どこかのPaaSでホスティングしたい(Heroku/EngineYardなど)\n結局、KyotoCabinetとMemcached互換プロトコルの両方をサポートする方針でプログラム変更中。\nただ、KyotoCabinetのクライアントライブラリを使ってしまうと、SekkaがGPLに感染する懸念を払拭できないため、最終的にはKyotoCabinetの代わりを探してKyotoCabinetから離脱する必要がある。\nKyotoCabinetのRubyクライアントライブラリは1.9.2対応しているし，非常に使いやすいAPIを持っているのに残念。ライセンス問題なんで致しかたない…\n代わりとしてKyotoCabinetをやめてTokyoCabinetに戻るという方法もありかなと思っている。まあTokyoCabinetの方が枯れているし、EngineYardでサポートされているし、Linuxディストリビューションの多くでパッケージが用意されている等、考えてみるとメリットも多い。\n\nそれから、前回はKVS以外にamatchという曖昧検索ライブラリがGPLv2なのを書き忘れていたが、これも代替製品を探している。なかなか代替が見つからないのだが…\namatchは[Sekka]と一緒に配布するわけではなくgem installするので、GPLv2を気にする必要はないのかも知れないが、それでもamatchはメモリリークを起こすのが問題だ。漢字変換を繰り返す度にどんどんメモリ使用量が増えていく。amatchをリンクしないでも動くように代替手段を用意しておくほうがいいだろう。\n将来amatch相当のものをPure Rubyで書くか、リークしないC言語版ライブラリを作るかしないといけないが、それぞれパフォーマンス面と手間の面で一長一短ある。\n振りかえってみると、[Sekka]はちょっとした寄り道プロジェクトと軽く見ていたが、やってみると意外と色々問題が立ちはだかり、修行になる。\n[Sekka]は毎日使ってみて自分では気にいっているので、何とか手軽にインストールできるようにして一人でも多くの人に試してもらいたいなあと思っている。\n[Sekka]は[Sumibi.org]と違って、反応速度にも気を遣っているので、その部分ももうちょっと拘り続けたい。KVSの特性を理解するのにも良い題材だし。\n追記:\n上記の「KyotoCabinetのクライアントライブラリを使ってしまうと、SekkaがGPLに感染する懸念を払拭できない」は私の勘違いです。\nKyotoCabinetのクライアントライブラリがGPL2でもGPL3でもSekkaはBSDLのままでOKであり、ライセンス変更する必要はありません。\nGPLとBSDLはライセンスに整合性があるので、リンクした時の相性が良いです。\nFUDを流してしまってすみません。OSSである限り、GPL感染を心配する必要はありません。\n\nコメント by kiyoka:\n自分でコメントします。\nその後、KyotoCabinetからTokyoCabinetに変更する作業をしてみたら、30分ほどでテストまで終わった。やっぱりTest Driven Developmentのメリットが効いている。",
    "url": "/2010/9/18/2010-09-18-post/"
  },
  {
    "id": "2010-09-21-post",
    "title": "NendoがSekkaの足を引っぱっている",
    "date": "2010-09-21",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-09-21-post.md",
    "content": "[Sekka]は一応、反応速度が良くなるように気を遣って開発している。\nなので、高速が売りのKVSをバックエンドに使っているのだが、いかんせん[Nendo]が速度面で足を引っぱっている。\nどうしても高速に処理したい部分はRubyで書いて問題回避しているのだが(笑)、いつまでもそれでは悲しい。\nNendo処理系まだまだチューニングが足りないので、チューニングも必要になってきたぞ。\n\nこの修行のループを耐えれば実用言語に育つと信じてがんばっていこう。",
    "url": "/2010/9/21/2010-09-21-post/"
  },
  {
    "id": "2010-09-28-post",
    "title": "テスト駆動開発入門",
    "date": "2010-09-28",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-09-28-post.md",
    "content": "大阪府立図書館から借りた。\nAmazonの書評では、翻訳が酷いので原文で読んだほうが良いと買いてあったのだけど、翻訳自体は文章のリズムがかなり悪い所を除けばそれほど悪いところは無く、普通に読めると感じた。\nこの本は、テスト駆動開発(テストファーストとリファクタリングの繰りかえし)を一歩づつ具体的な手順を踏んで進めていくという流れで書いてあるので、サンプルコード部分に間違いが無ければそれほど問題ないだろう。\nときかくKent Beckのテストのグリーンの状態を維持しながらコード変更していく気概がわかって良い。\n良くも悪くも、なるべく手順を省略せず、現場でテスト駆動開発を実践したらどうなるかというのを、愚直に解説してあるのが良い。\n手元に置いておいて、迷ったら何度も参照しながら使う本だと思う。\nテストファーストが重要なのは頭ではわかっていても、実際にやってみると正しい手順通りやるのは難しく、臨機応変にテストを後回しにしたりして容易にテストファーストのレールから外れて作業してしまいがちだ。\nこの本は正しい手順を確認しながらテストファーストを体得するのに有用な本だと思う。",
    "url": "/2010/9/28/2010-09-28-post/"
  },
  {
    "id": "2010-10-04-post",
    "title": "俺言語処理系開発に挑戦したいなら「見るまえに跳べ」",
    "date": "2010-10-04",
    "categories": [
      "言語"
    ],
    "file_path": "_posts/2010-10-04-post.md",
    "content": "Peter Norvig のエッセイを読んだのだが、自分の過去ならどう感じただろうかと思ったので…\n俺言語処理系を作ってみた後では、当時高い壁だと思っていたものが、そうでも無いことを知った。\n少しでも興味がある人は実際にトライしてみるべきだと思う。\n((Pythonで) 書く (Lisp) インタプリタ) から引用。\n * Lispyはとても小さい。コメントや空行を除くと90行で、ソースコードは\n 4Kバイト以下だ。(最初のバージョンは96行だったが、Eric Cooperの示唆\n により、Procedureのクラス定義をなくし、代わりにPythonのlambdaを使う\n ことで短くなった。) 私がJavaで書いた最小のSchemeであるJschemeのソー\n スは1664行で57Kバイトあった。Jschemeは当初SILK (Scheme in Fifty\n Kilobytes、50キロバイトのScheme)と呼んでいたが、この制限を満たして\n いたのはソースコードではなくバイトコードで数えたときだけだった。\n Lispyはずっと良くなっている。これはアラン・ケイが「世界で最も強力な\n 言語」を「1ページのコード」で定義できると1972年に言った言葉に合って\n いると思う。\n bash$ grep &quot;^\\s**^#\\s*&quot; lis.py | wc\n 90 398 3423\n\n上のエッセイでも全ソースが掲載されているが、言語処理系の中でもLispは非常に少ないコードでおもちゃの処理系が作れる。特にPythonなどのスクリプト言語で書いた場合は特にそう。\n言いたいことは、言語処理系を作ってみたいと思っているひとは躊躇せず一度試してみるべき、ということ。\nおもちゃバージョンを作るところまでは上のエッセイ同様に余暇の数日でできるレベルだ。\nその先は、飛び込んでみてから決めても遅くはない。実際に言語処理系を作ってみると、おもちゃバージョンの完成を迎えるころには、そこで終るのはもったいないほど楽しいことがわかってくる。まあ、そこから先、どう進むかは人それぞれだと思うけど。\n 「見るまえに跳べ」\n現在は[Nendo]というRubyで書いたLisp処理系を開発しているのだが、私の思い出を語ると、当初なかなか始められなかったのを思いだす。\n過去記事から、なんか自分がグチグチ書いているところを抜粋してみた。カッコわるい…(笑)\nどうも、最初から完全オリジナルなフルセットの処理系を作ろうとか考えてたみたいだ。そんなこと考えたら誰にとっても壁は高いだろうに。\n2008年8月くらいからグチグチ言いはじめて、実際に決心が付いたのが2009年2月末だった。\n[kiyoka.2008_08_09]言語 そろそろオレ言語でもやっておくか(1)\n オレ言語(いわゆる言語を自作すること)に興味が出てきた。自分が実際に作っ\n てみるという観点で有名どころの言語仕様とか言語設計者のプレゼン資料と\n かを見ると、なかなか素人には恐ろしく高い壁に見える。\n [kiyoka.2008_08_31]言語 そろそろオレ言語でもやっておくか(2)\n [kiyoka.2008_09_03]言語 そろそろオレ言語でもやっておくか(3)\nここで[Gauche]作者のshiroさんからもコメントを頂いたり。有り難いです。\n [kiyoka.2008_09_23]言語 そろそろオレ言語でもやっておくか(4)\n なぜ、多くの処理系実装者が『オレ言語をデザインするのは大変なので\n Schemeを言語仕様どおり実装しました』という 結論になるのかという質問へ\n の答えにもなっていると思う。\n オレ言語に手を出すのは楽しいけど、あまりにハードルが高いということだ\n なぁ。どうするかなぁ。\n [kiyoka.2009_02_28]言語 そろそろオレ言語でもやっておくか(5)\n [kiyoka.2009_03_20]言語 そろそろオレ言語でもやっておくか(6)\nこのあたりで、作るものの方向性が見えてきて、[Nendo]という名前に落ちついたみたいだ。\n [kiyoka.2009_03_25]言語Nendo そろそろオレ言語でもやっておくか(7)\n で、結局なにを作りたいの？\n S式でRubyプログラミングができたらどんな感じかを一度体験してみたいと\n いうのが作り始めた動機だ。S式のどこの節を千切って、あっちへ接木して\n というような柔軟なプログラミング体験はRubyではできない。\n Rubyの良い面も有るのでRubyのコードと混在できるようにするつもり。\n なので、ユーザインタフェース的な実験がメインになる。ということで、実\n 用言語としてのパフォーマンスとかはあまり興味がないの。\n S式でプログラミングをするのは好きなんだけど、例えばTokyoCabinetみた\n いな最近話題のDBでちょっと使って遊んでみたいというような場合には、\n Rubyのようにバインディングが量産されてくる言語にのっかるのが楽という\n 事情もある。\n[kiyoka.2009_03_30]言語Nendo そろそろオレ言語でもやっておくか(8)\n [kiyoka.2009_04_01]言語Nendo そろそろオレ言語でもやっておくか(9)\n [kiyoka.2009_04_07]言語Nendo そろそろオレ言語でもやっておくか(10)\n [kiyoka.2009_04_10]言語Nendo そろそろオレ言語でもやっておくか(11)\nまあそんなわけで、躊躇してるくらいなら「見るまえに跳べ」ですよ。",
    "url": "/2010/10/4/2010-10-04-post/"
  },
  {
    "id": "2010-10-13-post",
    "title": "fuzzy-string-match 0.9.0 リリース",
    "date": "2010-10-13",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2010-10-13-post.md",
    "content": "二つの文字列同士を曖昧比較するライブラリ(gem)をリリースしました。\n\nlucene-3.0.2からJaro-Winkler distance アルゴリズムだけをポーティングしたものです。\nキーワード検索でユーザーのタイプミスをある程度許容したい時なんかに使えると思います。\nちなみに、私は[Sekka]という日本語入力メソッドで使っています。\n結果は上々で、ローマ字にタイプミスが混在してもそれなりに合っていれば漢字を探しだしてくれるので重宝しています。\n限界速度ぎりぎりまで打鍵スピードを上げてもそれなりに漢字変換ができてしまうので非常に効果を感じています。\nインストール方法\nこれだけです。\ngem install fuzzy-string-match\n\n依存ライブラリ群も自動的に解決されてインストールされます。\n使いかた\nfactoryメソッドでインスタンスを作って、getDistance()メソッドに比較したい2つの文字列を渡すだけです。\n結果が 0 ≦ x ≦ 1.0 の近似度で返ってきます。(1.0で完全一致です)\nrequire 'fuzzystringmatch'\njarow = FuzzyStringMatch::JaroWinkler.new.create( :native )\np jarow.getDistance( &quot;jones&quot;, &quot;johnson&quot; )\n\nソースコード\ngithubにあります。\n kiyoka's fuzzy-string-match at master - GitHub\nJaro-Winkler以外のアルゴリズムが欲しい人はこのモジュールに追加して頂ければ幸いです。\n作業はluceneのオリジナルJavaソースを慎重にRubyとＣ言語に変換するという簡単なお仕事です(笑)\nRubyの汎用的なライブラリをリリースしたのは今回が初めてです。([Nendo]は汎用的だけどちょっと毛色が違うからね)\n微力ながらRubyコミュニティーに貢献できた気がして嬉しいです。",
    "url": "/2010/10/13/2010-10-13-post/"
  },
  {
    "id": "2010-10-15-post",
    "title": "Nendoのベンチマークを開始",
    "date": "2010-10-15",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-10-15-post.md",
    "content": "Nendoで書いたプログラムがPure rubyと比べてどれくらい遅いかを調べ始めた。\nまずは最初の結果を示そう。\n竹内関数の処理時間は以下の通り。 ※ 引数は tak( 10, 5, 0 )\n Ruby 0.03秒\n Nendo 38.89秒\nその差 およそ1296倍。スゲー。\nソースコードは以下の通り。コーディングの仕方でどちらかが有利になるようなことはないだろう。\nRuby\n def tak( x, y, z )\n if y &gt;= x\n y\n else\n tak( tak( x-1, y, z ),\n tak( y-1, z, x ),\n tak( z-1, x, y ))\n end\n end\n\nNendo\n(define (tak x y z)\n (if (&gt;= y x)\n y\n (tak (tak (- x 1) y z)\n (tak (- y 1) z x)\n (tak (- z 1) x y))))\n\nまず、何から手を付けるか。\ntakは関数呼び出しが全て固定長なので、Nendoの引数の渡しかたを固定長の場合だけ最適化するだけで相当高速化するハズ。とういか以前、Nendoの出力したRubyコードを手で最適化した際にかなり効果があったので、その案を進めてみる。\n難しい箇所としては、既にNendoに組込んである末尾再帰最適化を壊さないように今回の仕組みを入れないといけないところ。\n2日程度で作業完了できればいいのだけどなぁ。そんなに簡単ではないんだろうなぁ。",
    "url": "/2010/10/15/2010-10-15-post/"
  },
  {
    "id": "2010-10-19-post",
    "title": "Nendoパフォーマンスチューニングメモ(1)",
    "date": "2010-10-19",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2010-10-19-post.md",
    "content": "[Nendo]処理系のパフォーマンスチューニングを実施した際のメモを晒しておく。(こういう記録はブログとかWikiに書いとくのが一番だと思う)\nNendoの特性について\nまず、何と比較するかという問題であるが、[Nendo]は1つのS式ごとにrubyプログラムを自動生成し、rubyでevalしながら走るので、手書きのrubyプログラムと速度比較するのがわかりやすだろう。\nただ、そうはいっても[Nendo]を極限まで最適化しても、手書きのプログラムに勝ることは不可能であることは明白なため、[Nendo]の生成コードとして最大限狙える限界のコードと比較してみることにした。(参考までに手書きのコードも同時に示す)\n[Nendo]が手書きコードに勝てない理由を書いておくと、動的にエラーチェックをする必要があることと、四則演算なども関数なので'+'や'-'を記述しただけでも関数呼び出しになる(Schemeのサブセットとして考えるとそうしないといけない)ので、同じアルゴリズムを記述した場合でも、[Nendo]のほうが多くの処理をする必要がある。\n計測方法\n計測ツールにはruby-profを使った。\nマイクロベンチマークプログラムには、階乗計算と竹内関数(別名:たらいまわし関数)を使う。\nその他のベンチマークプログラムは、この次考えることにしよう。\n計測に使ったコード\ntak(竹内関数)への引数は全て tak(10, 5, 0) とした。\nruby-tak\n 人間がrubyでプログラミングした一般的なコード\n def tak( x, y, z )\n if y &gt;= x\n y\n else\n tak( tak( x-1, y, z ),\n tak( y-1, z, x ),\n tak( z-1, x, y ))\n end\n end\n\nruby-tak3\n Nendoが目指すべき生成コード\n def tak3( x, y, z )\n @inner_minus = Proc.new { |_a,_b|\n _a - _b\n }\n @inner_ge = Proc.new { |_a,_b|\n _a &gt;= _b\n }\n @inner_tak = Proc.new { |_x,_y,_z| \n if ( @inner_ge.call( _y, _x ))\n _y\n else\n @inner_tak.call(\n @inner_tak.call( @inner_minus.call(_x,1), _y, _z ),\n @inner_tak.call( @inner_minus.call(_y,1), _z, _x ),\n @inner_tak.call( @inner_minus.call(_z,1), _x, _y ))\n end\n }\n @inner_tak.call( x, y, z )\n end\n\nnendo-tak\n 人間がNendoでプログラミングした一般的なコード\n(define (tak x y z)\n (if (&gt;= y x)\n y\n (tak (tak (- x 1) y z)\n (tak (- y 1) z x)\n (tak (- z 1) x y))))\n\n計測結果\nマシン環境\n Hardware: MacBook Pro 13inch\n OS: MacOS X Snow Leopard version 10.6.4\n CPU: 2.4GHz Intel Core 2 Duo\n Memory: 4GB 1067MHz DDR3\n ruby: ruby 1.9.3dev (2010-10-14 trunk 29498) x86_64-darwin10.4.0\n* 最適化前\nNendo 0.3.4リリース版の結果である。\ntak (ruby version)\n user system total real\n 0.040000 0.000000 0.040000 ( 0.039284)\n\ntak3 (ruby version)\n user system total real\n 0.220000 0.000000 0.220000 ( 0.214475)\n\ntak (nendo version)\n user system total real\n 34.130000 0.730000 34.860000 ( 34.848524)\n\nruby-tak3 : nendo-tak = 1.0 : 155.13 (約155倍遅い)\n* 引数リストを Listではなく、Arrayで渡すようにした。\nruby-profで計測した結果、引数リストをList型で渡しているところが重いことがわかった。\n現状: callProcedure( 'func', @_func, * a, b, c .to_list ) 形式は (cons a (cons b (cons c '()))) のようなList形で引数を渡している。\n最適化後: 固定長引数の場合は、@_func.call( a, b, c ) というlistを使わない呼びだし形式にした。\n当然、ArrayのほうがRubyの組み込みクラスなので処理が軽い。\n最適化の結果は以下のようになった。\ntak (ruby version)\n user system total real\n 0.030000 0.000000 0.030000 ( 0.032908)\n\ntak3 (ruby version)\n user system total real\n 0.210000 0.000000 0.210000 ( 0.215441)\n\ntak (nendo version)\n user system total real\n 22.200000 0.720000 22.920000 ( 22.908085)\n\nruby-tak3 : nendo-tak = 1.0 : 105.71 (約106倍遅い)\n* シンボル変換処理をコンパイル時に持っていった。\nまだ重い部分があったので調べてみると、tak関数が呼ばれる度に、Nendoの関数名をrubyの名前空間でのメソッド名に変換する処理が走っていることに気がついた。\nNendoの関数名はSchemeの識別子と同様に、'-' や '' などのように rubyの識別子に使える範囲外の文字が使えるため、それらを変換してやる必要がある。\n(例: aa-bb を aa_MIMARK_ASMARKbb_METHOD に変換する処理)\n最適化の結果は以下のようになった。\ntak (ruby version)\n user system total real\n 0.030000 0.000000 0.030000 ( 0.033190)\n\ntak3 (ruby version)\n user system total real\n 0.210000 0.000000 0.210000 ( 0.217253)\n\ntak (nendo version)\n user system total real\n 10.020000 0.120000 10.140000 ( 10.130185)\n\nruby-tak3 : nendo-tak = 1.0 : 47.71 (約48倍遅い)\nまとめ\n引数リストの受け渡しにオーバーヘッドの大きいList型を使っていた問題と、シンボル変換をコンパイル時ではなくランタイム時に行っていた問題を改善することによって、takの計算時間を約1/3に改善することができた。\n今後の高速化アイデア\n今回の計測で、Nendoのビルトインの四則演算関数は可変長引数を受けるバージョンしかないため、可変長引数を扱うオーバーヘッドが依然大きいことがわかっている。\n(+ 2 2) などのようにソースコード上で引数の数はわかっているわけなので、四則演算の２引数固定バージョンなどを用意して、コンパイル時に選択すればtakなどのマイクロベンチマークではかなり高速化できそうである。\nただ、メンテナンスの面からあまり良い方法とはいえないので、もっと良い方法が何か検討する。\nほかにも、mapやfilterなどはNendoで実装するのではなくRubyのネイティブのmapやselectをうまく利用してRubyの速度に近づけるアイデアもある。\n但し、rubyのmapが使えるのは mapに1個のリストが与えられた場合のみであるが、それでもほとんどのNendoプログラムではmapやfilter関数に複数のリストを与えることは稀であることから十分有効なアイデアだと考える。\nちなみに、今回の改善は 0.3.5に入る予定です。",
    "url": "/2010/10/19/2010-10-19-post/"
  },
  {
    "id": "2010-10-22-post",
    "title": "Nendo 0.3.5 リリース",
    "date": "2010-10-22",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-10-22-post.md",
    "content": "[Nendo] 0.3.5をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\n今回の目玉は高速化です。\ntak(竹内関数)でversion 0.3.4に対して約３倍の高速化が実現しました。\n個人的に[Nendo]でいろんなものを書いているので、今後も日々必要になったものを優先して実装していくつもりです。\nおそらく、これから[Sekka]をgem化する時に見つかった不満点を追加していきます。\n[Sekka]がリリースできた時点で 0.4.0 というバージョン番号を付けてもいいかなと考えています。",
    "url": "/2010/10/22/2010-10-22-post/"
  },
  {
    "id": "2010-11-01-post",
    "title": "石火(Sekka)の日本語入力のデモビデオ公開",
    "date": "2010-11-01",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-11-01-post.md",
    "content": "[Sekka]で日本語入力ビデオに撮った。\nこれを見れば、リアルタイムで変換候補が表示されるというのがどんな感じなのかが、イメージできると思う。\nこれで、[Sekka]に興味を持ってくれる人が一人でも増えると嬉しい。\nただ、ミスタイプした場合にそれを救済してくれる機能の「心地良さ」は実際に使って体験してもらわないとわからないと思うので、興味がある人もリリースまで待って頂きたい。\nこういう、「使いやすさ」のような、文章やブログでは表現しにくいものをネットで共有したい場合はどうすればいいのかを漠然と考えているところ。\nやっぱり、Shibuya.lisp Hackathon #1 : ATNDのようなイベントに参加してわいわいいいながら開発すれば良いものができるんだろうな。\n第一段階として、Twitterで触ってみたファーストインプレッションを呟いてもらえればかなりのことは分かるのかもしれないのでTwitterも活用して良い方法に改善していく努力をしてみたい。",
    "url": "/2010/11/1/2010-11-01-post/"
  },
  {
    "id": "2010-11-02-post",
    "title": "AZIK対応に挑戦",
    "date": "2010-11-02",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-11-02-post.md",
    "content": "今回は、地味でニッチな話題なので、興味がある人は限られると思うのだけど、自分用メモとして。\nローマ字入力方式として、AZIKという方式がある。\n\n詳しくはWikipediaと、るびきちさんの記事を参照。\n AZIK - Wikipedia\n もっと早くタイピングしたい人へ贈る習得容易な拡張ローマ字入力『AZIK』\n AZIKとは\n AZIKは、現行の入力方式の資産を生かしつつ、入力を改善していくスタイルを\n とります。現行の方法を保持したまま、より打ちやすいように改善していくの\n で、移行期間でも作業ができます。いわば拡張ローマ字入力といったところで\n す。日本語の読みを研究しつくし、頻出のパターンを打ちやすく最適化してい\n るので、より高速に、より疲れにくくなります。\nこのようなAZIKの紹介文を真に受けて、[Sekka]では通常のローマ字入力とAZIK(拡張ローマ字入力)は共存できるという目標を持っている。\nそこで気を付けないといけない点を発見したので、メモっておく。\n\"ん\" の扱い\nSekkaでは \"ん\" を \"n\"/\"nn\"/\"q\" の3種類で指定できるようにしたいと考えている。\nつまり、\"n\" 1個でも極力 \"ん\" と認識してほしいのだ。\n\"n\" と \"nn\" の両方を \"ん\" としたいが、AZIKが入ることによって、\"n\" が \"ん\" と認識されないパターンが減ってしまう。\nなぜかというと、AZIKでは \"nj\" が \"ぬい\" にマッピングされていたりして、\"ん\" が \"nn\" で指定されないと全体が整合しない仕様になっている。\n例えば \"kanji\" という文字列を通常のローマ字で解釈すると \"かんじ\" となるが、AZIKで解釈すると \"かぬんい\" となってしまう。\n(前述の説明の通り、\"kannji\" のように \"ん\" を \"nn\" で入力するとAZIKでも \"かんじ\"となるのだが…)\n※ これは、辞書を引かない平仮名入力と送り仮名入力の箇所だけで問題となる話題であって、辞書引きされる部分においては曖昧検索で救済される。\n対策案\n案1: 辞書引きされない箇所では \"ん\" を \"nn\" で入力してもらう\n案2: AZIKを優先するか否かというユーザー設定を儲ける\n結論は？\nまだ、決めてないけれど 案1が有力かなぁ。\nAZIK対応を入れることによって標準ローマ字の使い勝手が落ちるというのは少し残念ではあるけれども…\nその他\n\"ぁ\" を \"xa\"でも\"la\"でも両方許容しようと思ってたけど、これもAZIK対応で \"xa\" がコンフリクトするので \"la\" だけを許容することになるだろう。\n\nコメント by kiyoka:\n自分でコメントします。\nやっぱり案2が使いやすいだろうと思い直したので、案2で実装してみることにしました。\n\nコメント by Daiane:\nThat's a smart way of loonkig at the world.\nコメント by kiyoka:\n自分でコメントします。\nやっぱり案2が使いやすいだろうと思い直したので、案2で実装してみることにしました。",
    "url": "/2010/11/2/2010-11-02-post/"
  },
  {
    "id": "2010-11-08-post",
    "title": "関西Ruby会議03でNendoのライトニングトークをした",
    "date": "2010-11-08",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2010-11-08-post.md",
    "content": "Rubyで書いたLisp処理系の[Nendo]についてLTさせてもらった。\nスライドはこちらでどうぞ。\n Nendo At Kansai Ruby Kaigi03(SlideShare)\n\n※ スライドの色合い等が@kakutaniさんのスライドに似ていますが、気にしないでください。@kakutaniさんのプレゼンばっかり見ていたら自然とこうなってしまいました。(笑)\n[Nendo]に少しは興味を持って頂いたみたいだった。(一人、プレゼンの後に技術系な質問を頂いたりした)\nただ、Rubyistが集まるイベントでのLisp紹介なので、実際に[Nendo]を使ってもらえるかどうかは未知数なのだが…\n[Nendo]で書いたプログラムとして途中[Sekka]のデモをしたところ、使ってみたいという方のほうが多かった。\nSKKユーザーってまだまだ多いのだなということがオフラインでも確認できた。SKK根強いなぁ。\nEmacsとvimユーザーは半々だったのでvimスクリプトも誰かに作ってもらわねばと思った次第である。\nまあSekkaServerはREST APIなので誰か作ってくれるだろう…と期待。\n機会があれば、[Nendo]と[Sekka]のどちらかで今度は40分くらいのプレゼンをやってみたいと思う。",
    "url": "/2010/11/8/2010-11-08-post/"
  },
  {
    "id": "2010-11-11-post",
    "title": "load-pathまわりの仕様",
    "date": "2010-11-11",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-11-11-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n今回、[Sekka]というローマ字漢字変換エンジンをgem化するにあたって、[Nendo]のload-pathまわりの仕様を整理した。\n全面的にGaucheを真似てすっきりさせた。\nload関数、add-load-path関数、グローバル変数load-path は同じ仕様にした。\nまた、[Nendo]が起動した直後の load-path はRubyの$LOAD_PATHの情報をコピーして作ることにした。\nこうすることで、Rubyのライブラリが置かれる同じ場所に[Nendo]のライブラリファイル(拡張子.nnd/.nndc)も置けることになり、[Nendo]独自の置き場所を考えなくてよくなる。\nこれの最大のメリットは、Nendoで書いたスクリプトやライブラリをgem化した時にgemのルールにすんなり馴染むというところだ。\nRubyと[Nendo]を混在させたプロジェクトのgem化が非常にスムースにできるようになり満足。\nこの仕様は近日公開する Nendo-0.4.0 に入る予定。",
    "url": "/2010/11/11/2010-11-11-post/"
  },
  {
    "id": "2010-11-14-post",
    "title": "Nendo 0.4.0 リリース",
    "date": "2010-11-14",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-11-14-post.md",
    "content": "[Nendo] 0.4.0をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nライブラリをロードする関数 load の仕様を整理しました。\n結局、Rubyの$LOAD_PATHの値を[Nendo]も継承するようにしたので、NendoのユーザーライブラリもRubyのライブラリパスに置くという設計にしました。\n※ 詳細は、[Nendo.ReferenceManual]を参照してください。\nこれで、[Nendo]で作ったコマンドラインアプリをgem化できるようになりました。\nこれは[Sekka]をGem化するにあたって、必須だったので手を付けました。\nついに、実用アプリケーションが[Nendo]へ依存するようになったので、今後のNendoの開発は後方互換性にも気を配らないといけなるなりそうです。\nそう考えると、有名な処理系作者の気苦労はもっと大きなものなんでしょうね。\n今のところ、[Nendo]ユーザーは自分一人のはずなので、まだ融通は効くでしょうが…\nユーザーは増えて欲しいけど、増えて欲しくない。[Nendo]は悩ましいお年頃を迎えました。",
    "url": "/2010/11/14/2010-11-14-post/"
  },
  {
    "id": "2010-11-16-post",
    "title": "Sekka 0.8.0 リリース",
    "date": "2010-11-16",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-11-16-post.md",
    "content": "[Sekka] 0.8.0をリリースしました。\n初回リリースで、かつβリリースです。\n\nまだ、いくつかバグを残した状態ですので、使いやすさを重点的に見ていただいてフィードバックをもらえたら嬉しいです。\nEmacs Lispに覚えのある方がいらっしゃったら、手加減せずどんどん改良して頂けると幸いです。\nなお、既知のバグは [Sekka.TODO] を見てください。\nさて、現SKKユーザーの方の心をつかむことができるのでしょうか。ドキドキです。",
    "url": "/2010/11/16/2010-11-16-post/"
  },
  {
    "id": "2010-11-23-post",
    "title": "相対性理論というバンドについて",
    "date": "2010-11-23",
    "categories": [
      "音楽"
    ],
    "file_path": "_posts/2010-11-23-post.md",
    "content": "久々に緩い記事でも書こうと思います。\n坂本龍一も認めるバンド。(NHKの番組で名前を挙げて褒めるなどしていた)\n非常に歌詞が斬新。なかなか気楽に聞けて良い。\n「シンデレラ」とかおもしろい。\n例えば、\nシンデレラをバイクの後ろに乗せてタンデムでお城まで行く歌詞なんだけど、\n「no no シンデレラ遅刻はいけないタイ タイ タイムカード押せないわ」とか\n「テレ東」とかもいいです。\n「マイハートハードピンチ」もなかなか。",
    "url": "/2010/11/23/2010-11-23-post/"
  },
  {
    "id": "2010-11-29-post",
    "title": "Sekka 0.8.1 リリース",
    "date": "2010-11-29",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-11-29-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.1をリリースしました。(リリースノート [Sekka.ReleaseNote])\n主な改善点は3つです。\nAZIKの定義間違いを多数修正\n英語キーボードのサポート\n確定undoできる件数を100件までサポート\n確定undoについては動画を見てもらったほうが早いでしょう。\nまだ、β版なので不備な点はあるでしょうが、気軽に試してもらえればと思います。\n(特に、SKKユーザーの方はキー操作が似ているのですぐ慣れると思います)\n※ 私がロタウィルスにやられている間に、作業が2日間ほど止まり、図らずも肉(29日)リリースとなってしまいました。",
    "url": "/2010/11/29/2010-11-29-post/"
  },
  {
    "id": "2010-11-30-post",
    "title": "「modeless SKK」を着想してから「Sekka」が具現化するまで道のり",
    "date": "2010-11-30",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-11-30-post.md",
    "content": "この数ヶ月は、SKKライクな日本語入力メソッド Sekka* を開発してきた。\n今日は、その着想から今に至るまでを振り返ってみようと思う。\n\n前々からmodelessは自分好みのスタイルだったし、[Sumibi.org]というmodelessな日本語入力方式も作った。\nその後[Sumibi.org*]を毎日使っているうちに、modelessの弱点も同時に見えてきたので、さらに良い入力方式が存在し得るハズと思い続けてきた。\nどうにかブレイクスルーできないかと試行錯誤した足跡を辿ってみよう。\n時系列で振り返る\n初歩的なアイデアをblogで文章化したのは、次の記事が初めてだったようだ。\n[kiyoka.2010_05_08] 創作心理 今作りたいもの\n better SKK\n [Sumibi.org]と同じ様な統計的アプローチを使うが、連文節変換ではないも\n の。コード量はSumibiよりもはるかに少なそうな気がする。私が個人的に\n SKKのキライな所である、大文字小文字を駆使して送りがなを指定する部\n 分を、統計的に解決してほしい。使うキーもずっと減らして基本的に\n Ctrl-Jだけにしたい。\nこの時は、まだsticky-shiftを試しておらず、なんとか統計的手法で送り仮名の自動推定をさせようと考えていたみたいだ。\nCtrl-Jだけを使うというアイデアは、現在のSekkaで実現できている。\nその後、modeless SKKという言いかたでなんとかmodelessとSKKの両立を考えるようになった。\n[kiyoka.2010_08_08] 創作心理 今創りたいもの(2) 『modeless SKK』\n 前にも書いたがSKKライクな日本語入力メソッドを試しに作ってみたいと思っ\n ている。\n次の8月10日の記事で、Sekkaという仮名が使われている。\nこのあたりで、modelsssな日本語入力方式をローマ字でやろうとすると、ミスタイプをどうにかしないとダメだと思い致ったようだ。\nそれで、結局Jaro-Winkler編集距離に行きついたみたい。\n[kiyoka.2010_08_10] 創作心理SKK modeless SKK\n 昔からある yc.el や ゆでたまご等の modeless 入力メソッドの弱点は、\n 目視では変換前のローマ字綴り間違いに気づきにくいというところ。\n 例えば、『しぜんげごしょり』なら間違いにきがつきやすいが、\n 『shizengegosyori』では全くどこが抜けたのかわからないだろう。\n8月下旬には、プロトタイプを使って日本語入力ができていたようだ。\n[kiyoka.2010_08_27] NendoSekka SekkaをRackに載せて、試験運用中\n sekka.elを1日程度ででっちあげて、このブログはEmacs+Sekkaで書いてい\n る。(勝手知ったるsumibi.elを改造したのでそんな期間でできたのだが…)\n[kiyoka.2010_11_16] Sekka Sekka 0.8.0 リリース\n 初回リリースで、かつβリリースです。\nついに、β版がリリースされた。\n感想\n振り返ってみると、案外短期間で開発できていると感じた。8月から11月末で、しかも、[Nendo]の開発をメインにやっていたので、そこそこ開発速度は早いかもしれない。\n成果物を、今日の時点で再評価してみても自分の狙ったものに近いソフトウェアになってきているし、経過は上々といったところ。\n[Sumibi.org]で満足しなかったのが良かったのだろう。過去に自分で作ったものを否定するのは勇気がいる。過去の自分を否定することになるからだ。\nしかし、自分を否定しないと超えられない壁がある。\n頭の中にずっと良いイメージが浮かんだのなら具現化してみたくなるこの性分の影響も大きいだろう。これは後生大事にしないといけないなぁ。\n教訓\nアイデアを具現化してみることが重要。(実際に具現化しないと、自分が何を欲しがっているのかは見えにくい)\n過去の自分の作品を否定する勇気も必要。",
    "url": "/2010/11/30/2010-11-30-post/"
  },
  {
    "id": "2010-12-01-post",
    "title": "ユーザー語彙登録UIについて考える",
    "date": "2010-12-01",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-12-01-post.md",
    "content": "[Sekka] 0.8.1には、まだユーザー語彙登録UIがない。\nそろそろ、ユーザー語彙登録UIを追加したいと考えている。\n最初、DDSKKの再帰的語彙登録とかを参考にしようと思った。\n初めてSKKの再帰的語彙登録は私も素晴しいアイデアだと関心させられた。\nしかし、マニアックなギーク魂を脇に置いて考えてみると、現在ではInternet上に便利なサービスがあり、SKKのような内向きアプローチで自己解決しなくても良いだろう。\n[Sekka]ではもっとユーザーのことを考えて楽な方法を考えてみる。(実装者=(私)のことも、ちょっとだけ考えたんだけどね)\nそれはGoogle日本語変換APIを使うというアイデアだ。\nもちろん、オフラインの場合はGoogleは使えないが、オンラインであれば未知語を解決するのにこんなパワフルなものは無い。\nプライドなんか捨てればいい。負けるが勝ち。使えるものはなんでも使う。\nとりあえず、送り仮名付きの単語については、登録頻度は少ないだろうから保留として、一番頻度の高いカタカナ語と、複合語、それに固有名詞の取り込みをGoogle様経由にしてしまうおうと考えている。\n現段階で思いつきで書いているので実際にうまくいくかは未知数なのだが、これからやってみようと思っている。\n状況は追って(恥といっしょに)晒していくよ。(笑)",
    "url": "/2010/12/1/2010-12-01-post/"
  },
  {
    "id": "2010-12-05-post",
    "title": "ユーザー語彙登録UIについて考える(続き)",
    "date": "2010-12-05",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-12-05-post.md",
    "content": "前回「 [kiyoka.2010_12_01]Sekka ユーザー語彙登録UIについて考える 」 の続き。\nSekkaの未知語登録にGoogleのAPIを使おうと調べた。\n Google 日本語入力 - CGI API デベロッパーガイド\n Google CGI API for Japanese Input は、日本語変換をインターネット上で\n 実現するための、CGI サービスです。\nJSONを返してくれるので、Ruby 1.9.2のJSONライブラリを使えば楽勝だと思っていた。\nしかーし。APIが返すJSONがおかしいのだ。\n CGI API の 返す JSON が RFC4627 違反 - Google 日本語入力 公式ヘルプフォーラム\nJSONの規約から外れているので、普通にやるとパースエラーとなる。(恐らくJavaScriptでevalすれば通るから放置されているんだろうけど)\nさて、どうしたものか…\nしょうがないので、Perlの人とかはJSONパーサーのチェックを甘くする機能を使ったりして後ろ向きの対応が多い。\n 参考: WebService::Simpleを使ってGoogle CGI API for Japanese Input - アリ\nただ、Rubyの標準添付のJSONライブラリには、そんなオプションは無い。\n直るのを待つか、バグ回避のコードを入れて作っちゃうか考え中。",
    "url": "/2010/12/5/2010-12-05-post/"
  },
  {
    "id": "2010-12-06-post",
    "title": "Sekka 0.8.2 リリース",
    "date": "2010-12-06",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-12-06-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.2をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n主な改善点は2つです。\nSekka Web APIのベンチマークツールを追加\n巨大なユーザー辞書ファイル(.sekka-jisyo)を登録可能にした\nいろんな環境でのパフォーマンスを知りたいので、珍しい環境や古めのコンピュータをお持ちの方は、ベンチマークを取っていただけると幸いです。\nベンチマークの取りかたは、[Sekka.Benchmark]を参照してください。",
    "url": "/2010/12/6/2010-12-06-post/"
  },
  {
    "id": "2010-12-07-post",
    "title": "Cacooを使ってみた。Cacoo超優秀。",
    "date": "2010-12-07",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-12-07-post.md",
    "content": "Cacoo(カクー)でSekkaのソフトウェアアーキテクチャ図を描いてみた。\n\n大変優秀なサービスで度肝を抜かれた。ブラウザで動くソフトなので、もっと貧弱だと予想していたのだが。\n普段こういう図はPowerPointもしくはOOo Impressで描いていて十分満足していたのだが、それよりも使いやすい。\nVisioは使ったことは無いのでわからないが、比べられないけど、Webブラウザ上でスタンドアロンアプリ並に使いやすい図形エディタが作れるのが驚き。\nWebサービスならではの、最新の図のエクスポート画像(png形式)がパーマリンクになる機能もサポートされている。\n何も隠す必要のないオープンソースソフトウェアにとって、この機能はぴったりハマる。\n無料の範囲でも25シートまで保存できるので、一度使ってみられては？\n\nコメント by Gautam:\nWham bam thank you, ma'am, my qeusitnos are answered!",
    "url": "/2010/12/7/2010-12-07-post/"
  },
  {
    "id": "2010-12-08-post",
    "title": "処理系開発者は「言語設計者たちが考えること」を読もう",
    "date": "2010-12-08",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2010-12-08-post.md",
    "content": "処理系開発者は絶対読んで後悔しないと思う。とにかくどのページを読んでも楽しく、深い。\n言語をデザインしている人なら読んでいるに違いないよね。そんな本。\nもちろん、言語マニアでなくてもプログラミング経験者なら誰でも楽しめると思う。\nどの言語開発者のインタビューもいいのだが、特にLarry Wallが凄い。Perl 6がここまで高い目標に向かって設計されようとしているのかと感心した。\nPerlのデザインに賛同しない人でも読んで驚くと思う。例えば正規表現のリファクタリングの話とかは凄い。誰もそこまでやらんだろう。\n正規表現のパターンマッチを拡張するために多くのメタ文字が割りあてられてきたため、ユーザーがどれがメタ文字か覚えられなくなっている問題に対してこう話している。\n P.410から引用\n Unix文化が初めて正規表現構文を発明したときは、メタ文字はほんの少しだ\n けだったので、簡単に覚えることができました。パターンマッチにより多く\n の機能を付け加えていくに従い、メタ文字として使うASCII記号文字の数を増\n やしたプログラムもあれば、かつては正規表現と認められていなかった長い\n 文字列を正規表現に採用して後方互換性を維持しようとしたプログラムもあ\n りました。これでは無理もありませんが、結果はひどいものでし\n た。…(略)… 混乱したユーザは正規表現の中ではどんな記号文字であっても\n バックスラッシュをつけてしまうかもしれません。どの文字が実際にメタ文\n 字だったか覚えられないからです。Perl 6では、パターンマッチの構文にリ\n ファクタリングをかけていくにつれて、ASCII記号の大半が何かしらの形です\n でにメタ文字として使われていることに気がつきました。そこで、我々はア\n ルファベットでも数字でもないすべての文字をメタ文字として予約し、プロ\n グラマが暗記するための負担を軽くしました。今後はどの文字がメタ文字な\n のかを示す一覧がいらなくなるので、構文がはるかにきれいになります。\n全ての言語デザイナの一段上のレベルで物を考えている気がする。尊敬に値するなぁ。人類の宝だ。\n次に、AWKの3人のインタビューも良い。言語だけでなくプログラミング一般の話もしていて、示唆に富む内容になっている。\nまあとにかく、インタビューを一通り読むと、成功した言語は深く考え抜かれていることがわかるし、なぜこうも対極的な言語が生み出されるのかも納得した。みなプログラミングに対する考えかたが違うので違う言語が生まれて当然かなと納得。\n自分も[Nendo]という処理系を作っており、自由にデザインできる立場にいるので、もっと高い目標を設定して時間をかけて育てていこうという気になった。\n当初の目標だった、immutable宣言による副作用の存在チェックなどは追求してみたい。\n詳細は過去記事参照。「[kiyoka.2009_09_02]Nendo オレオレ参照透明性というアイデア(immutable宣言)」",
    "url": "/2010/12/8/2010-12-08-post/"
  },
  {
    "id": "2010-12-26-post",
    "title": "Schemeのportをportingするには？",
    "date": "2010-12-26",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2010-12-26-post.md",
    "content": "Schemeのportって何を抽象化しているんだろう。\nRubyのFileオブジェクトをちょっとラップしただけでもできるもんなのだろうか。\nもうそろそろ、portが無いとGaucheのライブラリのAPIを近似できない事態が増えてきた。rfc.jsonとか。\nちょっと、ここらでじっくりportについて考えてみたほうが良いのではないかというフェーズに入った。\nきっかけは、[Sekka]で未知語登録UIのために、google ime apiを使いたいと思った事で、\ngoogle ime apiが返却するうJSONファイルがおかしいのに気付き、\ngoogle ime apiを修正するプロキシサービスをheroku.com上に立ちあげ、\n同時にGaucheの0.9.1でjsonライブラリが公式APIになったので、\n[Nendo]にjsonライブラリをGaucheと同一APIでサポートしようとして、\nportという概念まで合わせ込みたくなった。\nという状況。\n[Nendo]の開発は常にアプリケーションドリブン。オレ処理系の開発としては当面これでいいよね。\n言語としてのとんがった部分は平行に別の脳の部位を使って考えとります。\nそれにしても、[Sekka]の未知語登録UIのサポートまでの手順が長過ぎる。まあ仕方ない。",
    "url": "/2010/12/26/2010-12-26-post/"
  },
  {
    "id": "2010-12-27-post",
    "title": "IM飲み会2010に参加した",
    "date": "2010-12-27",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2010-12-27-post.md",
    "content": "[Sekka]についてトークさせて頂きました。\nスライドを今日、公開しました。\n IM飲み会2010 Sekka開発秘話\n\nyoriyukiさんが当日のメモを書いていらっしゃるので、リンクしておきます。\n2010-12-27 - yoriyukiの日記\nSekkaをもっとインストールしやすくする必要があるという助言を頂いたので、なんか考えないとですね。\n凄く楽しかったです。また来年も参加したいです。",
    "url": "/2010/12/27/2010-12-27-post/"
  },
  {
    "id": "2010-12-30-post",
    "title": "]を公開した",
    "date": "2010-12-30",
    "categories": [
      "Google"
    ],
    "file_path": "_posts/2010-12-30-post.md",
    "content": "Google IME APIをRubyやPerlなどから使おうとしている方は、このプロキシをお使い下さい。\n自宅サーバーではなくHerokuでホスティングしているので、サービスの安定性も高いでしょう。\nこのプロキシサービスを作った動機は次の過去記事をご参照下さい。\n 「 [kiyoka.2010_12_05]Sekka ユーザー語彙登録UIについて考える(続き) 」\nGoogle社が修正してくれるまでの繋ぎとしてお使いください。",
    "url": "/2010/12/30/2010-12-30-post/"
  },
  {
    "id": "2011-01-09-post",
    "title": "2011年の抱負",
    "date": "2011-01-09",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2011-01-09-post.md",
    "content": "ブログを書くほどの気力が無かったのでちょっと遅いけど抱負を。\n今年は普通に仕事をして普通に収入を得ることを目標にしよう。\nあまり多くを望まないようにして、無理をしないことが重要かな。\n\n2011年中はアクセルを50%くらい踏んだ感じでゆっくりいこう。\n年始から手始めに、テレビを見ないようにした。それで睡眠時間がちょっとだけ増えたかな。\n音楽を聴くことが自分の精神回復に効くことがわかってきたので、なるべく良い音楽に接するようにも心がけよう。",
    "url": "/2011/1/9/2011-01-09-post/"
  },
  {
    "id": "2011-01-13-post",
    "title": "まじめにSchemeのportをサポートする時間が無いので保留",
    "date": "2011-01-13",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-01-13-post.md",
    "content": "NendoのjsonライブラリをGaucheのrfc.jsonライブラリと互換にしたかったのだが、時間が無いので保留にすることにした。\nNendoの他のライブラリと同じように、portの変わりにRubyのFileオブジェクトでお茶を濁すことにした。\n優先すべきはSekkaからGoogle IME APIにアクセスして未知語を獲得する機能なので、今は寄り道はやめておこう。\n毎日30分だけNendoに割り当てる方針で、本当に少しづつだけど前進している。\nちなみに、portを実装するには peek-char を正しく対応しないといけないが、労力の少ない方法が思いつかない。",
    "url": "/2011/1/13/2011-01-13-post/"
  },
  {
    "id": "2011-01-20-post",
    "title": "Flareのリンク",
    "date": "2011-01-20",
    "categories": [
      "KVS"
    ],
    "file_path": "_posts/2011-01-20-post.md",
    "content": "仕事で使いそうなので、リンクだけ張っておく。\n一度大量のデータをサーバーに入れてみて検証しなければ。\n最低でも3台くらいのマシンが欲しいなあ。VMでもいいから用意できればいいんだけど。\n本家サイト\nFlare - GREE Labs\n有用情報を提供しているブログ\nFlareを使う(flush_allコマンドの不具合) &gt;&gt; さくらインターネット研究所\nFlareを使う(マルチテナント化編) &gt;&gt; さくらインターネット研究所\nFlareを使う(データ分散度合評価編) &gt;&gt; さくらインターネット研究所\nFlareを使う(性能測定編) &gt;&gt; さくらインターネット研究所\nFlareを使う(複数台構成) &gt;&gt; さくらインターネット研究所\nFlareを使う(インストール編) &gt;&gt; さくらインターネット研究所\nKey Value Storeについて &gt;&gt; さくらインターネット研究所\nmemcachedプロトコルについて &gt;&gt; さくらインターネット研究所\nvideoなど\ncloudstudy #3-2, cloudstudy #3-2 gihyojp on USTREAM. 会議\n Sakura Internetのエンジニアの方の発表部分\ncloudstudy #3-3, cloudstudy #3-3 gihyojp on USTREAM. 会議\n GREEの方の発表部分",
    "url": "/2011/1/20/2011-01-20-post/"
  },
  {
    "id": "2011-01-28-post",
    "title": "Nendo 0.4.1 リリース",
    "date": "2011-01-28",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-01-28-post.md",
    "content": "[Nendo] 0.4.1をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\n今回の目玉はjsonのライブラリを追加したことです。(rfc.json)\n[Sekka]で必要になったので追加しました。\nそんなわけで、Nendoの開発は[Sekka]のニーズによってドライブされています。",
    "url": "/2011/1/28/2011-01-28-post/"
  },
  {
    "id": "2011-02-04-post",
    "title": "JRuby 1.6.0-RC1のバグの切りわけができない",
    "date": "2011-02-04",
    "categories": [
      "JRuby"
    ],
    "file_path": "_posts/2011-02-04-post.md",
    "content": "久々にブログを書いてみました。\nNendoのテストスイートを走らせているのだが、JRuby 1.6.0-RC1のバグっぽい挙動に悩されている。\nなぜか、次のように失敗する。( CRuby 1.9.2-p136では正常にパスする )\nexpectedとgotの文字列を見ても同じように見えるのだが。\n現象\nruby -I ./lib /usr/local/bin/rspec -b ./test/nendo_spec.rb\n.........F.F..................FFFFFFFFFFFFFFFFFFFFFFF\n\nFailures:\n\n 1) Nendo when call evalStr() with literals should\n Failure/Error: @nendo.evalStr( ' &quot;日本語&quot; ' ).should eql( '&quot;日本語&quot;' )\n\n expected &quot;\\&quot;\\xE6\\x97\\xA5\\xE6\\x9C\\xAC\\xE8\\xAA\\x9E\\&quot;&quot;\n got &quot;\\&quot;\\xE6\\x97\\xA5\\xE6\\x9C\\xAC\\xE8\\xAA\\x9E\\&quot;&quot;\n\n (compared using eql?)\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-expectations-2.4.0/lib/rspec/expectations/fail_with.rb:29:in `fail_with'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-expectations-2.4.0/lib/rspec/expectations/handler.rb:19:in `handle_matcher'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-expectations-2.4.0/lib/rspec/expectations/extensions/kernel.rb:27:in `should'\n # ./test/nendo_spec.rb:226:in `(root)'\n # org/jruby/RubyBasicObject.java:1682:in `instance_eval19'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example.rb:49:in `run'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example.rb:98:in `with_around_hooks'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example.rb:46:in `run'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example.rb:91:in `with_pending_capture'\n # org/jruby/RubyKernel.java:1208:in `rbCatch19'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example.rb:90:in `with_pending_capture'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example.rb:45:in `run'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example_group.rb:261:in `run_examples'\n # org/jruby/RubyArray.java:2471:in `collect19'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example_group.rb:257:in `run_examples'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/example_group.rb:231:in `run'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/command_line.rb:27:in `run'\n # org/jruby/RubyArray.java:2471:in `collect19'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/command_line.rb:27:in `run'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/reporter.rb:12:in `report'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/command_line.rb:24:in `run'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/runner.rb:55:in `run_in_process'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/runner.rb:46:in `run'\n # /usr/local/stow/ruby-1.6.0.RC1-jruby/lib/ruby/gems/1.8/gems/rspec-core-2.4.0/lib/rspec/core/runner.rb:10:in `autorun'\n\nUTF-8の文字列の扱いがうまくいかないのかな？\nNendoの処理系は instance_eval() を使っているので、次のようなspecファイルでも失敗すると予想したが、失敗しない。\n t_spec.rb\n#!/usr/bin/env ruby\n# -*- encoding: utf-8 -*-\n#\ndescribe Kernel, &quot;when call evalStr() with literals&quot; do\n it &quot;should&quot; do\n instance_eval( ' &quot;\\&quot;abc\\&quot;&quot; ' ).should == '&quot;abc&quot;'\n instance_eval( ' &quot;\\&quot;日本語\\&quot;&quot; ' ).should eql '&quot;日本語&quot;'\n end\nend\n\n実行結果\n $ rspec t_spec.rb \n.\n\nFinished in 0.01 seconds\n1 example, 0 failures\n $\n\nそんなわけで、バグ報告したいけど問題を絞り込めないのでちょっと保留かなー。\nCRubyでは動くので、JRuby側に問題があると思うだけどなー。",
    "url": "/2011/2/4/2011-02-04-post/"
  },
  {
    "id": "2011-02-12-post",
    "title": "Sekka 0.8.3 リリース",
    "date": "2011-02-12",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-02-12-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.3をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n* 概要\nユーザー定義語彙の登録UIを追加。\nGogole IME APIを使った未知語の解決をサポート。\npopup.elを使った候補選択をサポート。\nやっとユーザー語彙登録のユーザ・インタフェースを追加しました。\nこれで、辞書に無い単語を簡単に追加できるようになります。\nどれくらい簡単かお見せしましょう。\n変換候補に期待した単語が無いぞと思ったら、すぐにCtrl-Rを押しましょう。\n次の画面のように変換候補を外部(GoogleImeAPI)から取得してリストアップしてくれます。\n\nこの中から「これだ!」と思う単語を選ぶだけで自分のユーザー定義語彙登録が完了します。\nGoogleImeAPIが最新の流行語や有名人、会社名なんかもリアルタイムで追いかけてくれているのでかなり強力です。\nまた、Sekkaの辞書に登録された単語は曖昧検索が可能になるので、さらにパワーが増幅されます。\nEmacsでSKKを使っている方は、SKKでは得られないこのパワーを体験してみてください。\n単語登録が楽しくなりますよ。",
    "url": "/2011/2/12/2011-02-12-post/"
  },
  {
    "id": "2011-02-22-post",
    "title": "自分的に超重要な eshell 用設定",
    "date": "2011-02-22",
    "categories": [
      "Emacs"
    ],
    "file_path": "_posts/2011-02-22-post.md",
    "content": ".emacsにこれを定義している。\n個人的に最も多様するキーシーケンスだ。\nキーシーケンス \"Ctrl-C d\" で今いるバッファと同じディレクトリに change-directory しながら eshellを起動する。\n(defun eshell-cd-default-directory ()\n (interactive)\n (let ((dir default-directory))\n (eshell)\n (cd dir)\n (eshell-interactive-print (concat &quot;cd &quot; dir &quot;\\n&quot;))\n (eshell-emit-prompt)))\n(global-set-key &quot;\\C-cd&quot; 'eshell-cd-default-directory))\n\n(twitterには文字数の関係上、無理があるのでblogに書いた)\n追記:\nこちらのブログで引用されている。\n 2011-02-22 - わからん\n eshell と直前のバッファを行き来するコマンド改造版\neshellバッファから元のバッファに戻るというのはいいアイデアだねぇ。\n自分も同様コマンドを作りたくなってきた。\nただ、自分の好みは eshellのコマンドラインから特定のshellコマンドで戻るのが好みかな。\n良いアイデアを思いついたら作ってみる予定だ。",
    "url": "/2011/2/22/2011-02-22-post/"
  },
  {
    "id": "2011-02-24-post",
    "title": "Sekka 0.8.4 リリース",
    "date": "2011-02-24",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-02-24-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.4をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n* 概要\nローマ字表記に xa xi xu xe xo xya xyu xyo xwa xtu を追加した。\nそれぞれ、「ぁぃぅぇぉゃゅょゎっ」に対応する。\nSekka最新版のインストールパスを返す sekka-path コマンドを追加した。(Emacs用load-path設定用)\nその他、バグ修正。\n今回はバグ修正がメインです。\n残りのTODO項目がだいぶ減ってきましたねー。([Sekka.TODO])\n残りの大きな変更は、10kagetuを 10ヶ月に変換する、数字混じりの変換機能くらいになってきました。\nそれから、sekka-serverがインストール済みのVirtualBox仮想イメージのほうも、そろそろリリースしたいですね。\n\nコメント by Joviliana:\nGee wlielikrs, that's such a great post!",
    "url": "/2011/2/24/2011-02-24-post/"
  },
  {
    "id": "2011-02-26-post",
    "title": "「10分でコーディング」をやってみた",
    "date": "2011-02-26",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-02-26-post.md",
    "content": "１０分でコーディング｜プログラミングに自信があるやつこい！！\n 今日の問題はかなり簡単です。\n できるだけ早い時間でエレガントなコードを書きましょう。\n あまりに簡単なので制限時間を１０分としてやってみてください。\n これ以上かかった人は\n 自分はかなりプログラミングができない。\n とつらい事実を認識しましょう。\nNendoで書いてみた\n5分くらい考えて5分くらいでコードを書いた。\nやっぱり時間を切ると、いつものコーディングパターンになっちゃうなあ。\n副作用をなるべく起こさないように、そして、計算量は気にしないスタイル。\n[Sekka]の辞書作成に時間がかかるのもきっと、それに違いない。と、思った…\nソースコード:cards.nnd\n(use srfi-1)\n\n(define (deal players deck)\n (let* ((lst (to_list (deck.split &quot;&quot;)))\n (idx (append-map\n (lambda (x)\n (range players))\n (range (/ deck.size players))))\n (idx-lst (zip idx lst)))\n (map\n (lambda (p)\n (string-join\n (filter-map\n (lambda (x)\n (when (= p (first x))\n (second x)))\n idx-lst)))\n (range players))))\n\n(define (main argv)\n #?=(deal 3 &quot;123456&quot;)\n #?=(deal 3 &quot;1234567&quot;)\n #?=(deal 2 &quot;&quot;)\n #?=(deal 1 &quot;012345012345012345&quot;))\n\n実行結果\n$ nendo cards.nnd \n#?=&quot;cards.nnd&quot;:24:(deal 3 &quot;123456&quot;)\n#?- (&quot;14&quot; &quot;25&quot; &quot;36&quot;)\n#?=&quot;cards.nnd&quot;:25:(deal 3 &quot;1234567&quot;)\n#?- (&quot;14&quot; &quot;25&quot; &quot;36&quot;)\n#?=&quot;cards.nnd&quot;:26:(deal 2 &quot;&quot;)\n#?- (&quot;&quot; &quot;&quot;)\n#?=&quot;cards.nnd&quot;:27:(deal 1 &quot;012345012345012345&quot;)\n#?- (&quot;012345012345012345&quot;)\n\nGaucheで書いてみた\nこのプログラムを作ってみて感じたのは、Gaucheには、ぴったりのライブラリがあるので凄く早く書けそうだということ。\nそれは、slicesとtakeだ。\nちょっと書いてみよう。\nソースコード:cards.scm\n(use srfi-1)\n(use util.list)\n\n(define (deal players deck)\n (let1 lst (map (lambda (x) (string x))\n (string-&gt;list deck))\n (if (or (eq? 1 players)\n (eq? 0 (length lst)))\n deck\n (take\n (map (lambda (x) (apply string-append x))\n (slices lst (quotient (length lst) players)))\n players))))\n\n(define (main argv)\n #?=(deal 3 &quot;123456&quot;)\n #?=(deal 3 &quot;1234567&quot;)\n #?=(deal 2 &quot;&quot;)\n #?=(deal 1 &quot;012345012345012345&quot;))\n\n実行結果\n$ gosh cards.scm\n#?=&quot;./cards.scm&quot;:16:(deal 3 &quot;123456&quot;)\n#?- (&quot;12&quot; &quot;34&quot; &quot;56&quot;)\n#?=&quot;./cards.scm&quot;:17:(deal 3 &quot;1234567&quot;)\n#?- (&quot;12&quot; &quot;34&quot; &quot;56&quot;)\n#?=&quot;./cards.scm&quot;:18:(deal 2 &quot;&quot;)\n#?- &quot;&quot;\n#?=&quot;./cards.scm&quot;:19:(deal 1 &quot;012345012345012345&quot;)\n#?- &quot;012345012345012345&quot;\n\nうーん、そうでもないか。\nライブラリが自分の思うような仕様でなく、リファレンスを調べたりしているうちに結構時間がかかってしまった。\nstring-splitのデリミタに空文字列が指定できない制限と、slicesが1で切れない制限とであまり短かく書けなかった…\n[Nendo]にutil.listライブラリを追加したら、Rubyのライブラリとの組み合わせでもっと短かく書けそうだ。\nやっぱり短い時間で書き捨てスクリプトを作るにはライブラリだなぁと再認識した次第。\nutil.list は takeとか日常的によく出会うリスト処理が入っているので、そろそろ[Nendo*]にポーティングしよう。\n追記:Gauche版修正\nもっと綺麗に書けるだろうと思ってリファクタリングしてみた。\n(use srfi-1)\n(use util.list)\n\n(define (deal players deck)\n (let1 lst (string-&gt;list deck)\n (if (null? lst)\n lst\n (take (map (lambda (x) (list-&gt;string x))\n (slices lst (quotient (length lst) players)))\n players))))\n\n(define (main argv)\n #?=(deal 3 &quot;123456&quot;)\n #?=(deal 3 &quot;1234567&quot;)\n #?=(deal 2 &quot;&quot;)\n #?=(deal 1 &quot;012345012345012345&quot;))\n\nちょっとだけ短かくなったかな。\n[Nend]oにutil.listライブラリを追加したら、さらに再度[Nendo]で書いてみよう。",
    "url": "/2011/2/26/2011-02-26-post/"
  },
  {
    "id": "2011-03-06-post",
    "title": "個人プロジェクトこそTDDでやるべき",
    "date": "2011-03-06",
    "categories": [
      "オープンソース"
    ],
    "file_path": "_posts/2011-03-06-post.md",
    "content": "個人プロジェクトは、プライベートな空き時間にちょっとづつ開発を進めていくというスタイルが大半だろう。\nそういう場合こそ、TDDを積極的に使おう。\n\nTDDの一番大きなメリットは、プロジェクトに戻る時の心理的障壁が低いこと。\nこれは、自分のプライベートな時間を使って自主的に進めていくプロジェクトでは、特に重要だ。\n全てを頭の中にいれてなくてもプロジェクトに戻って、コードに手を入れることができるので、気軽にコードを変更できる。\n大量のテストケースが、コードを守ってくれているおかげだ。\n時間が細切れになり、まとまった時間があまり取れない場合は、特にTDDのメリットを感じることができる。\nドカッとまとまった時間が取れる場合は、TDDのメリットが見えにくいかもしれないが、それでも数日後にプロジェクトに戻る時の負荷が非常に少ない。\n自分の場合は一番下位レイヤーの数行のライブラリ関数までテストケースを残しているので、細かい挙動を後で確認するのにも役立つ。\n実際に、自分の過去のプライベートプロジェクトで、コード変更に対する心理的負荷が上がりすぎたため止まってしまったプロジェクトもいくつかある。\n私の個人プロジェクトを振りかえってみよう。\nTDDでやらなかったプロジェクト\n\n[Stowspec] ( GNU Stowのヘルパーアプリ )\nSumibi ( 新感覚日本語入力メソッド )\n\n[OldType] ( OldTypeのためのWikiシステム。GaucheベースのWikiClone )\n\nR@eply.org ( iモードメール専用Webリーダー )\n\nPredoc ( 軽量ドキュメントフォーマット )\n\nTzWatch ( Lingr用の時刻表示アプリ )\n\nOneliner ( Emacs shell mode )\nCmmi (configure ; make ; make install)\nSxmlcnv (SXML XML)\n\nTDDでやっているプロジェクト(過去2年間くらいの大半)\n\n[Nendo] ( Rubyで実装されたLisp処理系 )\n[Sekka] ( SKKライクな日本語入力メソッド )\n[google-ime-api-normalizer] ( Google IME APIのJSON正常化サービス )\nfuzzy-string-match ( 曖昧文字列マッチングライブラリ for Ruby )\n\nやっぱりTDDは重要。これからの個人プロジェクトは全てTDDでやります。\nもちろん本業でもTDDでやるつもり。(って今までできてないんか！ってつっこみもありながら)\n参考文献\nこれは絶対読んでおいたほうが良い。\n TDDを実践する上で手順を実際にスローモーションで見せてくれるという感じの本。\nTDDでやっていない過去のコードをいかにTDDに直すかという内容の本。\n これを読んだからといって、苦労はするんだけどね。\n いかんともしがたいほどテストしにくいコードをいかに壊さないようにTDDに持っていくかという本なので、本業では非常に参考になると思う。\nズ株式会社\n\nコメント by sion:\n前から気になってたので、この機会にと、早速 Amazon で購入。読んでみました。普段の開発工程と、かなりの部分で、酷似していて、明確に「テスト」を意識するかどうか、程度の違いだけだったため、うんうん、そうそう、と、抵抗なく読み進められました。ペアプロにも興味深々なのだけど、なかなか、踏み切れない・・・。\nアカデミックで、ホットな情報、いつも感謝しています。\n\nコメント by kiyoka:\n文脈からいくと、読まれた本は「テスト駆動開発入門」のほうですね。\nsionさんは普段からテスト駆動に近い開発スタイルなんですね。\n私の場合、本業ではテスト駆動かどうかは人依存だったり（まあ、スキル依存もありますが...) なかなかうまくいっておらず、「レガシーコード」が発生しがちです。\nこの状況をなんとかして、打開したいと思っています。\n個人プロジェクトやオープンソースプロジェクトは期限が無い分、徹底的にこだわることができるので、TDDを実践できて結果的にうまくまわせるのですが、本業だとどうしても負の連鎖に陥りがちです。\nうーん。いまそこにあるホットな課題なんです。\nコメント by sion:\n前から気になってたので、この機会にと、早速 Amazon で購入。読んでみました。普段の開発工程と、かなりの部分で、酷似していて、明確に「テスト」を意識するかどうか、程度の違いだけだったため、うんうん、そうそう、と、抵抗なく読み進められました。ペアプロにも興味深々なのだけど、なかなか、踏み切れない・・・。\nアカデミックで、ホットな情報、いつも感謝しています。",
    "url": "/2011/3/6/2011-03-06-post/"
  },
  {
    "id": "2011-03-07-post",
    "title": "R君語録",
    "date": "2011-03-07",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2011-03-07-post.md",
    "content": "R君、2歳半になっていろんな言葉を覚えた。おもしろいのでその一部を紹介。\nえがめ → 眼鏡\n ままご → 卵\n おぺと → ポテト\n はうんこ → 半分こ\n しっだうん → sit down\n ぐっじょぶ → good job!\n ぴっぴー → tea please(おかわり全般に使う)\n まえもん → ドラえもん\n もにょ → ポニョ\n でーしゃ → 電車\n ででーしゃ → 自転車\n てぃんかんちぇん → 新幹線\n おいか → トミカ\n いかく → 四角\n しっぱーこ！ → しゅっぱーつ！\n しゅっぱい → 失敗\n めーしゃい → ごめんなさい\n ありとう → ありがとう\n いーく → ミルク\n たーしゅ → トーマス\n かーしー → パーシー(機関車トーマスの登場キャラ)\n かーしー → お菓子\n とっぱっと → トップハム・ハット卿(機関車トーマスの登場キャラ)\n はなぱっか → はなかっぱ\n えーむ → ゲーム(iPod touchのこと)\n全体的に最初の子音が抜けるのは基本なのかな？\n英語がちょくちょく混じるのは、ピジョンの英語系のプレスクールに行っているせいだ。\ngood job!と言って褒められた時は、なんか変な気分だったぞ。\nあと、ポニョの歌とトーマスの歌を歌うのだけど、ちゃんと日本語バージョンの歌詞を歌うときもあれば中国語バージョンらしき歌詞に切りかえるときもある。\nなぜかポニョの歌は倍速が基本のようだ。\n\nコメント by Kolawole:\nI feel so much hapepir now I understand all this. Thanks!",
    "url": "/2011/3/7/2011-03-07-post/"
  },
  {
    "id": "2011-03-10-post",
    "title": "Sekka 0.8.5 リリース",
    "date": "2011-03-10",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-03-10-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.5をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nversion 0.8.5\n辞書中の「数字+単位」の変換をサポート\n例)\n \"20ko\" → \"二十個\" や \"２０個\" など\n \"5kagetu\" → \"5ヶ月\" や \"五ヶ月\" など\n \"10gatu10ka\" → \"１０月１０日\" や \"10月10日\" など\n数字文字列を漢数字に変換する\n\"123450000\" → \"１２３４５００００\" や \"一二三四五〇〇〇〇\" 、 \"一億二千三百四十五万\" に変換するなど\nバグ修正\n-- sekka.el: 変換確定動作で、メジャーモードのfaceを上書きしてしまうバグを修正した。\nやっと「数字+単位」の変換ができるようになりました。\n個人的には欲しい機能はほとんど入ったので、今後辞書の更新もあまり無いでしょう。\n[Sekka]の開発で[Nendo]処理系に足りないところがたくさん見付かったので、しばらく[Nendo]を補強する作業に戻る予定です。\nSekka 0.9.x 系ではバグフィックスと、新しい[Nendo]処理系への追従くらいになると思います。",
    "url": "/2011/3/10/2011-03-10-post/"
  },
  {
    "id": "2011-03-31-post",
    "title": "syntax-rulesの実装中。難航中。",
    "date": "2011-03-31",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-03-31-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\nchibi-scheme 0.3のer-macro-expanderとsyntax-rulesをそのままNendoに移植中。\n今は、make-syntactic-closureをどう実装していいかわからないので、正解を探しているところ。\nsyntactic-closures\n Macros offer a way to extend the Scheme language by introducing new\n forms of syntax that are transformed into the simpler base\n language. Since Scheme's syntax is defined in terms of Scheme objects\n -- lists &amp; symbols, mainly --, one would imagine that procedures that\n perform such transformations, known as macro transformers, should be\n easy: they just operate on lists &amp; symbols, especially in the presence\n of quasiquote. However, this is not quite the case: macros need to\n also be aware of the underlying lexical scoping of the programs they\n transform. This article will not go into the need for that; see my\n article hygiene-versus-gensym for discussion of that matter. Macros\n need to work with more than S-expressions: they need S-expressions\n annotated with lexical scoping information.\n (以下略)\nこの文章を読んでも、具体的にどう実装すればいいのかわからん。\nMIT Schemeとchibi-scheme 0.3のソースをじっくり読めばわかるのだろうか。\n多分、クロージャを作ってそのレキシカル環境でバインドした変数名を返せばいいのだろう。\nで、それは具体的にRubyでどう実装すればいいのかという問題。\n受け取ったシンボルを、グローバル環境で(gensym)した変数名に代入してから、その(gensym)したシンボルを返してもいけるかも。\nちなみに、今の嘘実装はこれ。\n(er-macro-expanederとsyntax-rulesはchibi-scheme 0.3のコードそのまま動いたので、本ブログへの引用は省略)\n(define (make-syntactic-closure mac-env use-env identifier)\n (let* (*id-str (symbol-&gt;string identifier)*\n *alias-data (assq-ref id-str mac-env)*)\n (if alias-data\n (string-&gt;symbol (car alias-data))\n identifier)))\n\nグローバルバインドされたシンボル(ifなどの予約語)は別名 /nendo/macroenve/if などを返し、\nそれ以外の未定義のシンボルは、そのままシンボルを返している。\n簡単な例では一見動いてように見える。\n(define-syntax nil!\n (syntax-rules ()\n ((_ x)\n (set! x '()))))\nnendo&gt; (define a 1)\n\nnendo&gt; (macroexpand '(nil! a))\n(/nendo/macroenv/set! a (/nendo/macroenv/quote ()))\nnendo&gt; (nil! a)\n()\nnendo&gt; a\n()\n\n試しに、以下のchibi-schemeのcutの定義はそのまま通るので、動かしてみた。\n(define-syntax %cut\n (syntax-rules (&lt;&gt; )\n ((%cut e? params args)\n (lambda params args))\n ((%cut e? (params ...) (args ...) &lt;&gt; . rest)\n (%cut e? (params ... tmp) (args ... tmp) . rest))\n ((%cut e? (params ...) (args ...) )\n (%cut e? (params ... . tmp) (apply args ... tmp)))\n ((%cut e? (params ...) (args ...) . rest)\n (error &quot;cut: non-terminal &quot;))\n ((%cut #t (params ...) (args ...) x . rest)\n (let ((tmp x)) (%cut #t (params ...) (args ... tmp) . rest)))\n ((%cut #f (params ...) (args ...) x . rest)\n (%cut #t (params ...) (args ... x) . rest))))\n(define-syntax cut\n (syntax-rules () ((cut args ...) (%cut #f () () args ...))))\n(define-syntax cute\n (syntax-rules () ((cute args ...) (%cut #t () () args ...))))\n\nexpandしてみる\n(pretty-print\n (macroexpand\n '(map (cut + 1 &lt;&gt;) '(1 2 3 4))))\n\n結果\n(map\n (let\n ((tmp 1))\n (lambda\n (tmp)\n (+ tmp tmp)))\n ('\n (1 2 3 4)))\n\nヒドい。なんでもかんでもtmpになる\n勿論、計算結果もでたらめ。\nnendo&gt; (map (cut + 1 &lt;&gt;) '(1 2 3 4))\n(2 4 6 8)\n\nまだまだ挑戦は続くのであった。",
    "url": "/2011/3/31/2011-03-31-post/"
  },
  {
    "id": "2011-04-06-post",
    "title": "syntax-rulesが動いた日",
    "date": "2011-04-06",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-04-06-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\nchibi-scheme 0.3のer-macro-transformerとsyntax-rulesをそのままNendoに移植を試みていたのだが、ついに成功した。\nmake-syntactic-closureの実装方法は別段難しくなかった。\nトップレベルにbindされた変数なら、その識別子をシンボルで返し、そうでなければ(gensym)したシンボルを返せばいいだけだった。\nRubyで書いた関数なので、これだけでは意味がわからんだろうけど、雰囲気だけでも伝わるかと思うので、コードを貼っておく。\n def _make_MIMARKsyntactic_MIMARKclosure( mac_env, use_env, identifier )\n if _pair_QUMARK( identifier )\n raise RuntimeError, &quot;Error: make-syntactic-closure requires symbol only...&quot;\n else\n if mac_env.to_arr.include?( identifier )\n identifier\n else\n sym = toRubySymbol( identifier ) + _gensym( ).to_s\n sym.intern\n end\n end\n end\n\n苦労した主な敗因は、chibi-schemeのsyntax-rulesの定義を自分がよく理解しないままポーティングしようとしていたことだ。\nこんな複雑な手続きが、一発で動くほど甘い世界ではない。\n結局、デバッグコード挿入しつつ少しづつ原因を追いこんでいった。\nNendoにポーティングする時に考慮する必要があったのは以下の点。\n* ... というシンボルをあらかじめグローバルに定義しておく必要があった\nsyntax-rulesを評価する直前に、次のような定義を置いた。\n(define ... '...)\n\n* NendoのScheme非互換仕様に対しての手当が必要だった\nマクロ展開時 v.1 や v.2 のようなローカル変数を抑制する必要があった。\nNendoには instance.method の様な表記をRubyのメソッド呼び出しとして特別扱いしている。\n(これは、Schemeとは非互換な部分である)\nNendoでは syntax-rulesで展開したコード中の v.1 などの形式が vというインスタンスの1というメソッド呼び出しになってしまう。\nまあ、数値リテラルのメソッドなんてものは無いので、v.1のような表記は特別に:\"v.1\"というシンボルとして扱えばいいのだけど、そういう例外も気持ち悪いので特例は入れないつもり。\n結局 v__1 や v__2 のような変数名を生成するように変更した。\n (rename (string-&gt;symbol (string-append &quot;v.&quot; (number-&gt;string count)))))\n\n↓\n (rename (string-&gt;symbol (string-append &quot;v__&quot; (number-&gt;string count)))))\n\n* chibi-scheme 0.3のany関数にバグがあった。\nchibi-scheme 0.3のsyntax-rulesの定義中で何回か any が使用されているが、実はchibi-schemeのanyにはバグがある。(これは、chibi-schemeのMLでバグ報告しないといけない)\nこれを見つけるのに苦労したのだよ。\n次のような場面で使われている。\n(define-syntax syntax-rules\n (er-macro-transformer\n .\n .\n (cond\n ((any (lambda (v) (compare t (car v))) vars)\n =&gt; (lambda (cell)\n (if ( #t\n (any integer? '(a 3.1 b 2.7)) =&gt; #f\n\nとうわけで、このように修正した。\n 誤り:\n ((any (lambda (v) (compare t (car v))) vars)\n\n正解:\n ((find (lambda (v) (compare t (car v))) vars)\n\n参考:\n $ chibi-scheme\n&gt; (any even? '(1 2 3 4))\n2\n\n $ gosh\ngosh&gt; (any even? '(1 2 3 4))\n#t\n\n $ nendo\nnendo&gt; (any even? '(1 2 3 4))\n#t\nnendo&gt; (use srfi-1)\n20000\nnendo&gt; (any even? '(1 2 3 4))\n#t\n\nさて、これでsrfi-2とかGaucheのutil.listがポーティングできるぞー。\nNendoでできる世界がさらに広がること間違いナシ。\n高い壁をひとつ越えた気がする。すごい充実感。",
    "url": "/2011/4/6/2011-04-06-post/"
  },
  {
    "id": "2011-04-10-post",
    "title": "「言語設計者たちが考えること」の再読",
    "date": "2011-04-10",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2011-04-10-post.md",
    "content": "PealのLarry Wallの章と、RubyのMatzの章を再度読んだ。\n言語デザインの楽しさを再認識した。有意義でかつ楽しい。お金もかからず、知的好奇心を満たしてくれる最高の遊びだと思う。仕事では役に立たないけど...\n私のようにSchemeのような仕様が既に決まっている言語の処理系を作るだけでも楽しいが、言語をデザインする作業も楽しいだろうなと想像する。\n時々は、こういう本を読んで、単ならうScheme処理系の開発というレベルから一段引いて、言語デザインレベルから言語を考えることも必要だなと思う。\nそのためには、Schemeの仕様に囚われずに、どんな機能が有用かを考える癖も付けていきたい。\nHaskellとかも本格的に使い込んでHaskellの良い点を理解する時間を取る頃合いかなぁ。",
    "url": "/2011/4/10/2011-04-10-post/"
  },
  {
    "id": "2011-04-14-post",
    "title": "Sekka 0.8.6 リリース",
    "date": "2011-04-14",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-04-14-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.6をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nversion 0.8.6\n\ngemの依存規則で、Nendoの依存バージョンとして0.4.1のみとした。\n 今後、NendoのライブラリAPIの仕様変更で動かなくなる可能性があるため。\nsekka-server起動時、sekka-serverが使用中のNendoバージョンを表示するようにした。\n\n機能的には、0.8.5から何も変わらないので特にバージョンアップする意味はありません。\n今後リリースするNendoに下位互換性が無くてもSekkaに影響が無いようにするためです。(実際、一部APIで下位互換性が失われている)\n実験したところNendo 0.4.1とNendo 0.5.0の両方がインストールされていても、Sekka 0.8.6はNendo 0.4.1を使うことを確認しました。gemってよくできてるなぁーと思います。\n~ $ gem list nendo\n\n*** LOCAL GEMS ***\n\nnendo (0.5.0, 0.4.1)\n\n~ $ sekka-server\n----- Sekka Server Started -----\n Sekka version : 0.8.6\n Nendo version : 0.4.1\n dict-db : /home/kiyoka/.sekka-server/SEKKA-JISYO.SMALL.tch\n memcached : localhost:11211\n listenPort : 12929\n proxyHost : \n proxyPort : \n--------------------------------\n*2011-04-14 06:14:15* INFO WEBrick 1.3.1\n*2011-04-14 06:14:15* INFO ruby 1.9.2 (2011-02-18) *i686-linux*\n*2011-04-14 06:14:15* INFO WEBrick::HTTPServer#start: pid=11284 port=12929",
    "url": "/2011/4/14/2011-04-14-post/"
  },
  {
    "id": "2011-04-17-post",
    "title": "ゆっくり階段を登るがごとく",
    "date": "2011-04-17",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-04-17-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\nGaucheのutil.listが動いた。\nsyntax-rulesも動くようになったし、他にもバグをいくつか修正したので一旦リリースするべきだろう。\n実は、let-syntaxとletrec-syntaxのようなレキシカルスコープでのみ有効なsyntax定義が実装できていないので、片手落ちなんだけど、リリースした後に取りかかろう。\nといっても、実装はそんなに簡単では無さそうだ。\n恐らく、let-syntaxされたsyntaxだけ先に実行可能コードにコンパイルされ、他の部分は、S式のままの状態を作り出す必要があるのだろう。(関数の一部だけ溶け出したような状態？)\nマクロ展開用のプロシジャはコンパイルしないと実行できないし、マクロの操作対象はS式でないといけない。うーん、なんか勘違いしていないかな。\n過去に「[kiyoka.2011_04_06]NendoScheme syntax-rulesが動いた日」でdefine-syntaxとdefine-rulesが動いた話を書いたが、let-syntaxを実現しようと思ったらだいぶ書き直さないといけないだろう。\n不完全でもいいので仮実装をして初めて syntactic-closures で書かれている内容がわかるようになってきた。\n凡人はこういう風に、一歩一歩階段を登るしか無いんだろう。\n今の自分にとっては、好きでやっていれば下手でも一応前進するという実績が大事かも。",
    "url": "/2011/4/17/2011-04-17-post/"
  },
  {
    "id": "2011-04-25-post",
    "title": "Nendo 0.5.0 リリース",
    "date": "2011-04-25",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-04-25-post.md",
    "content": "[Nendo] 0.5.0をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの目玉\n健全なマクロ(hygenic macro)を追加したことです。\n結果、次の3つをサポートできました。特にutil.listは普段のコーディングで自分でも無いと困るライブラリでした。\n* srfi-2\nSRFI-2 AND-LET: ローカル束縛を伴う AND、条件付き LET 特殊フォーム\n* srfi-26\nSRFI-26 カリー化を伴わないパラメータ特殊化の記法 (cutとcute)\n* util.list\nGaucheのutil.listのサブセットです。Nendoはマルチメソッドディスパッチ機能が無いので、assoc-refの引数指定順序が逆バージョン等は外してあります。\ntake drop take-right drop-right split-at* slices intersperse cond-list alist-&gt;hashtable hash-table-&gt;hash-table が使えます。\nただ、サポートできたのはdefine-syntaxのみでレキシカルな構文定義(let-syntaxとletrec-syntax)は未だサポートできていません。\n次の目標(let-syntaxとletrec-syntax)\nこれが動けば、util.match が動くのでRubyに強力なパターンマッチが導入できます。\nNokogiriとutil.matchの組み合わせができると凄いことができるでしょう。\nこれから挑戦していきます。",
    "url": "/2011/4/25/2011-04-25-post/"
  },
  {
    "id": "2011-04-30-post",
    "title": "let-syntaxの実装方法の検討",
    "date": "2011-04-30",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-04-30-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\n( ※ この記事中のやりかたは全くの間違いだとわかったので、信じないようにお願いします。後日、正しい内容をまとめます )\nlet-syntaxの実装方法を検討中。\n概要\n次のような手順でマクロ展開しようと考えている。\n ソースコード → 内部表現1 → 内部表現2 → 展開形\nソースコード → 内部表現1\nソースコード\n(define (a-topleve-func arg1 arg2 ...)\n (let-syntax ((name1 (syntax-rules ...))\n (name2 (syntax-rules ...)))\n ... body1 ...\n (letrec-syntax ((name1 (syntax-rules ... ))\n (name2 (syntax-rules ... )))\n ... body2 ...)))\n\nRubyでマクロ展開する時に少しでも楽をするために、Nendoの初期化スクリプト(init.nnd)でlet-syntaxとletrec-syntaxを両方とも%lexical-define-syntaxを使った内部表現に変換する。\nlet-syntaxとletrec-syntaxの二つは伝統的マクロで以下の形に変換する。\nlet-syntaxのほうだけ、束縛するキーワードの数だけネストさせた形にする。\nletrec-syntaxのほうは、キーワードが %lexcal-define-syntaxになるだけで、フォームの変形は行わない。\n内部表現1 → 内部表現2\n内部表現1\n(define (a-toplevel-func arg1 arg2 ...)\n (%lexical-define-syntax ((name1 (syntax-rules ...)))\n (%lexical-define-syntax ((name2 (syntax-rules ...)))\n ... body1 ...\n (%lexcal-define-syntax ((name1 (syntax-rules ...))\n (name2 (syntax-rules ...)))\n ... body2 ...))))\n\nRubyで実装したマクロ変換器で、%lexcal-define-syntaxの (syntax-rules ...)部分を実行形式にコンパイルする。\n実行形式へのコンパイルはNendoのBuilt-in関数であるevalを呼べばいいので、Rubyとinit.nndのどちらでも書ける。\n(Nendoではsyntax-rules手続きを呼びだせば、LispSyntaxクラスのインスタンスが返ってくる)\n変換後は以下のような内部表現になる。(#は説明用の便宜上の表現)\n内部表現2 → 展開形\n内部表現2\n(define (a-toplevel-func arg1 arg2 ...)\n (%lexical-syntax ((name1 . #))\n (%lexical-syntax ((name2 . #))\n ... body1 ...\n (%lexcal-syntax ((name1 . #)\n (name2 . #))\n ... body2 ...))))\n\nここまで来れば簡単だ。\nRubyでのマクロ変換器を拡張して、%lexical-syntaxにぶら下がっているキーワードを拾いながら再帰的に body1 や body2 の S式を変換していけばいい。\nもちろん、レキシカルスコープを持っているので同名のキーワードが出現すれば内側のキーワードでシャドウしながら適用する。\nブログを書いている時点では内部表現1→内部表現2→展開形の部分だけ動いている。(キーワードがちゃんとレキシカルスコープになっているかまではテストできていないが)\nさて、実際に全体が動くかやってみよう。",
    "url": "/2011/4/30/2011-04-30-post/"
  },
  {
    "id": "2011-05-19-post",
    "title": "matchライブラリのデバッグ中",
    "date": "2011-05-19",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-05-19-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\nlet-syntaxの実装がだいぶ進んだ。\n現在はchibi-scheme 0.3のmatchライブラリであるmacth.scmを変更無しで動かそうとしている。\nあと、もうすこしで動きそうなんだけどなー。\nchibi-scheme 0.3のテストスイートを動かしてみたら、半分以上は動いている。が、なにかが間違っている。\nsyntax-rulesのパターン部に\n'symbol\n\nのようなS式が来ると、正しくマッチしないようだ。\nほかにも、一部のsyntax-rulesの再起定義において、マクロ展開が無限に行われ、S式が際限なく成長してしまうという問題がある。\nうーん。マクロのデバッグは本当に難しい…\nテストスイートのソースコード\n(match-test* &quot;any&quot; (match 'any (_ 'ok)) 'ok)\n(match-test* &quot;symbol&quot; (match 'ok (x x)) 'ok)\n(match-test* &quot;number&quot; (match 28 (28 'ok)) 'ok)\n(match-test* &quot;string&quot; (match &quot;good&quot; (&quot;bad&quot; 'fail) (&quot;good&quot; 'ok)) 'ok)\n .\n (略)\n .\n .\n\n実行結果 (問題のあるテストケースはpendingにして通している)\n------------------------------------------------------------------------\ntest any, expects ok ==&gt; ok\ntest symbol, expects ok ==&gt; ok\ntest number, expects ok ==&gt; ok\ntest string, expects ok ==&gt; ok\n(pending) *literal symbol*\ntest null, expects ok ==&gt; ok\ntest pair, expects ok ==&gt; ok\ntest vector, expects ok ==&gt; ok\ntest any doubled, expects ok ==&gt; ok\ntest and empty, expects ok ==&gt; ok\ntest and single, expects ok ==&gt; ok\ntest and double, expects ok ==&gt; ok\ntest or empty, expects ok ==&gt; ok\ntest or single, expects ok ==&gt; ok\n(pending) *or double*\ntest not, expects ok ==&gt; ok\ntest pred, expects ok ==&gt; ok\ntest named pred, expects 29 ==&gt; ok\ntest duplicate symbols pass, expects ok ==&gt; ok\ntest duplicate symbols fail, expects ok ==&gt; ok\n(pending) *duplicate symbols samth*\ntest ellipses, expects ((a b c) (1 2 3)) ==&gt; ok\ntest real ellipses, expects ((a b c) (1 2 3)) ==&gt; ok\n(pending) *vector ellipses*\n(pending) *pred ellipses*\n(pending) *failure continuation*\ntest let, expects (o k) ==&gt; ok\ntest let*, expects (f o o f) ==&gt; ok\ntest getter car, expects (1 2) ==&gt; ok\ntest getter cdr, expects (1 2) ==&gt; ok\ntest getter vector, expects (1 2 3) ==&gt; ok\ntest setter car, expects (3 . 2) ==&gt; ERROR: GOT (1 . 2)\ntest setter cdr, expects (1 . 3) ==&gt; ERROR: GOT (1 . 2)\ntest setter vector, expects #(1 0 3) ==&gt; ERROR: GOT #(1 2 3)\n(pending) *single tail*\n(pending) *single tail 2*\n(pending) *multiple tail*\n(pending) *Riastradh quasiquote*\ntest trivial tree search, expects (1 2 3) ==&gt; ok\ntest simple tree search, expects (1 2 3) ==&gt; ok\ntest deep tree search, expects (1 2 3) ==&gt; ok\ntest non-tail tree search, expects (1 2 3) ==&gt; ok\n(pending) *restricted tree search*\ntest fail restricted tree search, expects #f ==&gt; ok\n(pending) *sxml tree search*\n(pending) *failed sxml tree search*\n(pending) *collect tree search*\nfailed.\ndiscrepancies found. Errors are:\ntest setter car: expects (3 . 2) =&gt; got (1 . 2)\ntest setter cdr: expects (1 . 3) =&gt; got (1 . 2)\ntest setter vector: expects #(1 0 3) =&gt; got #(1 2 3)\ncat test.record\nTotal: 33 tests, 30 passed, 3 failed, 0 aborted.\n\n処理系を実装するというのは、絶壁を登るような感じに似ている。\n[Nendo]ではライブラリは自分で実装せず、chibi-schemeやGaucheのライブラリをなるべく変更無しで動かすという方針を取っている。\nそのおかげで、自分のスキルが上がるよりも先に課題の難易度が上がってしまうのだ。\nしかし、思えば高いところまで来たもんだ…\nでも、まだまだ頂上は見えず、この崖はどこまで続くのやら。",
    "url": "/2011/5/19/2011-05-19-post/"
  },
  {
    "id": "2011-05-22-post",
    "title": "2歳児はフェイスブックのCEOマーク・ザッカーバーグをどう見ているか",
    "date": "2011-05-22",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2011-05-22-post.md",
    "content": "この本を2歳児のR君に見せた時の会話。\n私: 表紙を見せて、「このおっちゃん誰か知ってる？」\n R君: ...「おっちゃん違う。おばちゃん。」\n 私: 「おばちゃん？」\n R君: 「うん。おばちゃん」\n見事おばちゃんとタグ付けされましたー。\n私: 「マーク・ザッカーバーグ」\n R君: 「ハンバーグ？」\n 私: 「マーク・ザッカーバーグ」\n R君: 「ハンバーグ？ JRハンバーグ速い？」 (JRのサンダーバードが好きだけど、何故か「ハンバーグ」と覚えている)\n 私: ... \n若き天才も、若き天然には勝てませんでしたー。\n以上。",
    "url": "/2011/5/22/2011-05-22-post/"
  },
  {
    "id": "2011-05-28-post",
    "title": "Paul Grahamとサンダル",
    "date": "2011-05-28",
    "categories": [
      "Lisper"
    ],
    "file_path": "_posts/2011-05-28-post.md",
    "content": "shiroさんのブログ記事から。\n Island Life - Paul Grahamとサンダル\n コメントで、Paulが靴下にサンダルを履いてるのを突っ込んでる人たちがいて\n ふと思い出した。\n本当だ。こんな大舞台でもサンダルだ。\n Y CombinatorのPaul Graham曰く: 目がキラキラした, ふてぶてしい人でないとだめ\n\nLisperはこうでなくては。今後心がけよう。\nでも、写真のアングルが明らかにサンダルを撮っているのが可笑しい。",
    "url": "/2011/5/28/2011-05-28-post/"
  },
  {
    "id": "2011-06-15-post",
    "title": "matchライブラリが動いた日",
    "date": "2011-06-15",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-06-15-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\nやっとmatchが動いたぞ。\nchibi-scheme 0.3のmatchを変更無しで動かすことができた。\n長かったー。let-syntaxの間違った実装を直すところから始めて約３ヶ月かかった。\n忘れないうちに、Rubyのコードにトランスレートする時の注意点などを、これから数日かけて記事にしていこう。\n自分で設計したVMに変換するのとは違い、既にターゲット言語が持つレキシカルスコープに乗せるやりかた(騙しかた)は、トランスレータ系の処理系を作っている人の役に立つかも。\n※ 英語で書ければベストなんだろうけど、そこまでのスキルは無い...\n記念にmatchのテスト実行結果を貼っておこう。\ntime ruby -I ./lib ./bin/nendo ./test/match-test.nnd | tee -a test.log\nTesting match ... \nTesting match -----------------------------------------------------------------\n------------------------------------------------------------------------\ntest any, expects ok ==&gt; ok\ntest symbol, expects ok ==&gt; ok\ntest number, expects ok ==&gt; ok\ntest string, expects ok ==&gt; ok\ntest literal symbol, expects ok ==&gt; ok\ntest null, expects ok ==&gt; ok\ntest pair, expects ok ==&gt; ok\ntest vector, expects ok ==&gt; ok\ntest any doubled, expects ok ==&gt; ok\ntest and empty, expects ok ==&gt; ok\ntest and single, expects ok ==&gt; ok\ntest and double, expects ok ==&gt; ok\ntest or empty, expects ok ==&gt; ok\ntest or single, expects ok ==&gt; ok\ntest or double, expects ok ==&gt; ok\ntest not, expects ok ==&gt; ok\ntest pred, expects ok ==&gt; ok\ntest named pred, expects 29 ==&gt; ok\ntest duplicate symbols pass, expects ok ==&gt; ok\ntest duplicate symbols fail, expects ok ==&gt; ok\ntest duplicate symbols samth, expects ok ==&gt; ok\ntest ellipses, expects ((a b c) (1 2 3)) ==&gt; ok\ntest real ellipses, expects ((a b c) (1 2 3)) ==&gt; ok\ntest vector ellipses, expects (1 2 3 (a b c) (1 2 3)) ==&gt; ok\ntest pred ellipses, expects (1 2 3) ==&gt; ok\ntest failure continuation, expects ok ==&gt; ok\ntest let, expects (o k) ==&gt; ok\ntest let*, expects (f o o f) ==&gt; ok\ntest getter car, expects (1 2) ==&gt; ok\ntest getter cdr, expects (1 2) ==&gt; ok\ntest getter vector, expects (1 2 3) ==&gt; ok\ntest setter car, expects (3 . 2) ==&gt; ok\ntest setter cdr, expects (1 . 3) ==&gt; ok\ntest setter vector, expects #(1 0 3) ==&gt; ok\ntest single tail, expects ((a b) (1 2) (c . 3)) ==&gt; ok\ntest single tail 2, expects ((a b) (1 2) 3) ==&gt; ok\ntest multiple tail, expects ((a b) (1 2) (c . 3) (d . 4) (e . 5)) ==&gt; ok\ntest Riastradh quasiquote, expects (2 3) ==&gt; ok\ntest trivial tree search, expects (1 2 3) ==&gt; ok\ntest simple tree search, expects (1 2 3) ==&gt; ok\ntest deep tree search, expects (1 2 3) ==&gt; ok\ntest non-tail tree search, expects (1 2 3) ==&gt; ok\ntest restricted tree search, expects (1 2 3) ==&gt; ok\ntest fail restricted tree search, expects #f ==&gt; ok\ntest sxml tree search, expects (((href . &quot;http://synthcode.com/&quot;)) (&quot;synthcode&quot;)) ==&gt; ok\ntest failed sxml tree search, expects #f ==&gt; ok\ntest collect tree search, expects ((p ul li) ((href . &quot;http://synthcode.com/&quot;)) (&quot;synthcode&quot;)) ==&gt; ok\npassed.",
    "url": "/2011/6/15/2011-06-15-post/"
  },
  {
    "id": "2011-06-21-post",
    "title": "Coders at Work 読了",
    "date": "2011-06-21",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2011-06-21-post.md",
    "content": "読んだ。楽しすぎ。\n一流プログラマのインタビュー集だ。\nこの本に登場するような一流は私達凡人とは違う世界に住んでいるようだ。業界がそもそも違うというのもある。破天荒。多様。アウトロー。\nなんか自分の仕事を否定されているようで辛い。\nSIerでマネージャやっている人は、特に自分の仕事がえらく否定されているように感じるかもしれない。\nまあ、マネージャにはリーチしない本なので心配に値しないと思うが。\n例えば、「ソフトウェアの開発期間を見積れると信じること自体どうかしている」というようなニュアンスの意見が多かったように思う。\n本を読む時間を正確に予測できないという例を引きあいに出して、その延長線でプログラムも同様であるに違いないという感じで言っているクヌース先生とか。\nくそマジメに作業時間見積りをせざるを得ない私達はいったいどうすればいいのか… まあ、それは置いといて… ビジネスモデルの問題なので…\nC++が酷評されているのは共通しているが、形式的証明に対する評価は人によって違う。\nまあほんとんどの人が使えないと言っているが…\n一度は信じてやってみたけど、やっぱりダメだと考えなおしたという話もあって説得力がある。\n実践に基づいた意見が多く、２度読んでもたのしいだろう。\nインタビュアーも造詣が深く、質問が丁寧 ( 悪く言えば粘着係 ) なのも良い。\nインタビューがどんどん深い話題に降りていけるように誘導している。\nこれインタビューする前に相当予習しているんだろうな。\nインタビューはこうでなくちゃという見本になっている。\nページ数が多いけど、読み応えあり。オススメです。\n行儀の良さが求められる業界の人も一度読んでみては？\nあわせて読みたい。",
    "url": "/2011/6/21/2011-06-21-post/"
  },
  {
    "id": "2011-06-24-post",
    "title": "Nendo 0.5.1 リリース",
    "date": "2011-06-24",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-06-24-post.md",
    "content": "[Nendo] 0.5.1をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの目玉\nchibi-scheme 0.3のmatchライブラリをポーティングしました。\nその過程で、let-syntaxとsyntax-rulesの大量のバグが取れました。\nGaucheのmatchライブラリのサブセットです。\n 参考: Gauche ユーザリファレンス: util.match - パターンマッチング\nそのmatchを使って、Gaucheのutil.combinationsを動かしました。\n 参考: Gauche ユーザリファレンス: util.combinations - 組み合わせ\nlet-syntaxのデバッグは本当に大変でした。高い高い壁だった。\n実装方法の勘違いを正すところから始めて約2ヶ月くらいかかっています。\nおかげで、自分自身がlet-syntaxを使ったマクロがすらすら書けるようになりました。\nScheme力が上がったー。\n次の目標\n例外処理まわりをなんとかしたいです。\nguard構文をサポートして、nendo.testフレームワークでRubyの例外発生のテストケースを書けるようにしたい。今は、例外が返るテストケースはRSpecで書くか、あきらめるかという状態なので改善が必要。\ngurad構文とRubyのbegin resucue end構文の折り合いをつけないといけないのでちょっと考える必要があります。きれいに行くかなー。\n 参考: Gauche ユーザリファレンス: 6.18 例外\nしばらく休憩\n今回はutil.matchのポーティングが重かったので、Nendoの開発は休憩して[Sekka]のほうに戻ります。\nその過程で、guard構文が欲しくなるだろうから、ぼちぼち[Nendo]側を対応していきます。",
    "url": "/2011/6/24/2011-06-24-post/"
  },
  {
    "id": "2011-06-26-post",
    "title": "Sekka 0.8.7 リリース",
    "date": "2011-06-26",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-06-26-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.7をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nversion 0.8.7\n\ngemの依存規則で、Nendoの必須バージョンを0.5.1のみとした。\n組み合わせ関数を自前で持たず、Nendoのutil.combinationsを使うようにした。\nmemcacehdプロトコルで辞書を保存する機能を廃止した。\nTokyo Cabinetの辞書ファイルが壊れている場合、sekka-server起動時に自動修復するようにした。\n\nプラットフォームとして [Nendo] 0.5.1 を使うようにし、リファクタリングしました。\n辞書ファイルを自動修復する機能が追加されているのを除いて大きな変更はありません。\n次の目標\n特に目標を立てずに、思いついたことをいろいろトライしていきます。\n試してみたいことは、漢字だけでなく「しています」等の平仮名キーワードもタイプミス訂正をすると使いやすくなるのだろうかとか、Tokyo Cabinet以外のKVSに対応してみたらどうかとか、興味は尽きません。\n将来はタイプミス訂正アルゴリズムは自分で実装せず、曖昧検索を持ったデータベースに全部やってもらったらどうかなどのアイデアもあります。Jaro-Winklerが計算できれば十分なので。\nなるべくSekkaのコードベースが小さくなるのであれば、それもありかな、と思っています。",
    "url": "/2011/6/26/2011-06-26-post/"
  },
  {
    "id": "2011-06-30-post",
    "title": "頭の中にプログラムを入れる",
    "date": "2011-06-30",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2011-06-30-post.md",
    "content": "Creative Commons|Attribution Photo by Mario Pleitez\nいまプロジェクト全体の技術面を把握して設計とコードレビューする立場にいるので、全体像を全部頭に入れながら生活している。\n意識していてもいなくても、風呂に入っている時、本を読んでいる時など、裏で脳が勝手に処理しているらしい。\n突然不整合に気づいたり、ぼんやりしていた全体像がクリアになったりする。\nこの脳に入れた状態で生活することを含めて自分の価値なのかも。それを含めて報酬を受けとっていると考えられなくもない。\nそれは明文化されているわけではないけれど、実際はそういう人間が抜けるとプロジェクトはカオスになるわけで、実際問題はそうだ。\nなんか因果な商売だなあと思う。\nちょっと違うけど、SFの短編「記憶屋ジョニィ」を思いだした。ジョニィとは違って記憶するだけではだめなんだけど。(参考:JM (映画) - Wikipedia、クローム襲撃 - Wikipedia))\nこの手の話は達人たちがちゃんと言語化してくれているので、自分の状況に置きかえて考えて\nみると楽しい。まずはポール・グラハム。\n 頭の中にプログラムを入れる\n プログラムを頭の中に入れるのは容易なことではない。プロジェクトを何ヶ月\n か放っておいたなら、戻ったときに再び深い理解を取り戻すのには何日もかか\n る。そのプログラムに積極的に取り組んでいる場合でさえ、その日その日に取\n り掛かるとき頭の中にプログラムをロードするのには30分もかかるかもしれな\n い。そしてこれはいい場合での話だ。\nこの本にも関連するクヌース先生の発言がある。\n第15章 ドナルド・クヌース\n クヌース TeXを開発している間にい膨大なことを学びました。学んだことの１\n つは、ソフトウェアが脳のどれほど大きな部分を占めるかということです。こ\n れは私が思っていたよりも難しい仕事でした。授業をフルタイムで教えながら\n ソフトウェアを書くことはできませんでした。私は授業をフルタイムで教えな\n がら本をフルタイムで書くことはできましたが、ソフトウェアは細部への注意\n をずっと多く必要としたのです。ソフトウェアが私の頭の大部分を満たしてし\n まい、ほかのことが追い出されることになりました。だから私は大規模ソフト\n ウェアプロジェクトをやっている人たちには格別の経緯を抱いています。自分\n で直面してみるまで、そんなことは想像もしていませんでした。\nきっと脳に一度にロードできる情報の限界というものがあるのだろう。\n今やっているプロジェクトが大規模かというとそれほどでも無いかもしれないが、かなりの事柄を頭に保持していないといけないのは事実だ。\n自分でコードを書く事はあまり無くなってしまったけど、コードの細部まで整合を見ていかないといけない。\n望んでいたわけでは無いが、実際にこういう立場になってみると、案外悪くないと思えるようになった。\n自分の手でコードは書かないけど、できあがってきたコードを全部見れていて問題があれば修正してもらえる。\nそんなわけで、プライベートで大きなプログラムをもうひとつ頭に入れることは無理っぽいなぁ、という感想。\n解決策は、プライベートでは実現したいことを外部のライブラリやミドルウェアの機能で補ったり、コードを極限まで圧縮できるマクロを使って脳の消費スペースを少しでも抑えてやるしかないかなぁーと考えているところ。仕事柄、自分でコードをゴリゴリ書いて解決するよりも、オープンソースのパッケージを上手く選定して解決するほうが重要なので、実は利害は一致している。\nまあ、二つ入ったほうがいいのは事実なんだけど、こればっかりはHDDじゃないので増設とかできんしなぁ。",
    "url": "/2011/6/30/2011-06-30-post/"
  },
  {
    "id": "2011-07-04-post",
    "title": "chibi-schemeのsyntax-rulesをポーティングする方法",
    "date": "2011-07-04",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-07-04-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\nchibi-schemeのsyntax-rulesをポーティングした時のメモ。\n[Nendo] 0.5.1時点での実装を解説となっている。\n以下の実装で、chibi-scheme 0.3のsyntax-rules関連のテストケースが通り、さらに、match.scmも修正無しでテストケースをパスしている。\n背景\n[Nendo]はRubyで書かれたScheme処理系である。サブセットではあるが。\nsyntax-rulesの処理は複雑で、自分で新しくコードを書くのはメンテが大変なので、できれば別の処理系で書かれたポータブルな実装を使いたい。\n探した結果、chibi-schemeのsyntax-rulesがScheme自身で書かれたいて、機能的にもGaucheのライブラリを動かすのに十分であったため採用した。\nただ、ポータブルなSchemeで書かれているため、マクロ展開が重いという課題もあるが、[Nendo]ではマクロ展開の処理速度には重きを置かない方針なので、とにかく動かすことを最優先とした。\nchibi-scheme 0.3のsyntax-rulesについて\nchibi-schemeのsyntax-rulesは、explicit macro transformerを使って書かれている\n(define-syntax syntax-rules\n (er-macro-transformer\n (lambda (expr rename compare)\n (let ((ellipsis-specified? (identifier? (cadr expr)))\n (count 0)\n (_er-macro-transformer (rename 'er-macro-transformer))\n .\n (略)\n .\n .\n\n従って、er-macro-transformerが正しく動くことが必須となる。\n但し、syntax-rulesが使われる場所は、define-syntaxとlet-syntaxのルール記述部分になるので、処理系には大域的syntaxと局所的syntaxのマクロ展開の機能が必要になる。\n[Nendo]は伝統的マクロの展開とあわせて3種類のマクロ展開をサポートしている。\n[Nendo]のマクロ展開エンジンはRubyで書かかれている。\nsyntaxのサポート\nsyntaxは、マクロ展開フェーズで実行される特別なプロシジャである。\n処理系の都合で、lambdaで定義されたプロシジャとは別の特別な型が使われることが多いようだ。\nGaucheでは #という型が使われる。ユーザ定義関数は #となる。\n$ gosh\ngosh&gt; if\n#\ngosh&gt; (define (func1) #t)\nfunc1\ngosh&gt; func1\n#\n\nNendo(0.5.1)でも、それぞれ以下のように、それぞれNendo::LispSyntaxとProcという型が使われる。\n$ nendo\nnendo&gt; syntax-rules\n#\nnendo&gt; (define (func1) #t)\n#\nnendo&gt; func1\n#\n\nchibi-schemeでは、syntaxは構文エラーになってしまうがprocedureとは別ものとして扱われていることにはかわりない。\n$ chibi-scheme\n&gt; if\nERROR: invalid use of syntax as value: if\n&gt; (define (func1) #t)\n&gt; func1\n#\n\nこれを実現するために、[Nendo]ではLispSyntaxという型をProcから継承して実装した。中身は空。\n class LispSyntax )\n 構文: は次の形式をとること。\n (( ) … )\n 各 は識別子である。各 はsyntax-rules のインス\n タンスである。 は１個以上の式からなる列であること。束縛されるキー\n ワードの並びの中に一つの が複数回現れることはエラーである。\n 意味: let-syntax 式の構文環境をマクロで拡張することによって得られる構\n 文環境の中で， が展開される。ただし，それらのマクロはそれぞれ をキーワードとし，仕様が規定する変換子に束縛されている。各 の束縛は をその領域とする。\n```lisp\n(let-syntax ((when (syntax-rules ()\n ((when test stmt1 stmt2 ...)\n (if test\n (begin stmt1\n stmt2 ...))))))\n (let ((if #t))\n (when if (set! if 'now))\n if))\n\n=&gt; now\n(let ((x 'outer))\n (let-syntax ((m (syntax-rules () ((m) x))))\n (let ((x 'inner))\n (m))))\n\n=&gt; outer\n ※ これがinnerとなっては駄目\nこれを実現するには、let-syntax された syntax は let で束縛された変数も考慮した環境を保持する必要がある。\nマクロ展開に求められる要件\n上記の仕様を満たすマクロをRubyのようなレキシカル変数を持った言語にトランスレートするには次の要件を満たす必要がある。\n\n要件\n局所的syntaxが展開される場所でも、let-syntaxで定義された場所のレキシカル環境を擬似的に復元する必要がある。\n\n[Nendo]での実現方法とそのメリット\nマクロ展開エンジンはletとletrecで束縛されたレキシカル変数を全て抜き出しておいて、syntaxがRubyのメソッドとしてコンパイルされる時に、\nレキシカル変数の環境をRubyのレキシカル変数の環境として復元する。\n\n[Nendo]\n(let ((x 'outer))\n (let-syntax ((m (syntax-rules () ((m) x))))\n (let ((x 'inner))\n (m))))\n\n↓\nRubyでのマクロ展開中イメージ(説明のためかなり簡略化している)\n# 新しいS式に変換するマクロ m\nm = LispSyntax.new {|expr,use_env,mac_env|\n # let-syntaxの定義環境で expr の式を展開して返す\n # 外部の環境が m の内部の x に影響を与えない。\n _tmp = lambda {|x| # マクロ定義の環境を再現(start)\n x\n } ; tmp( :outer ) # マクロ定義の環境を再現(end)\n}\n\n# マクロ展開フェーズで、callProcedure部分が展開される\n_tmp = lambda {|x|\n _tmp = lambda {x|\n callProcedure ( m,\n Cell.new, # mの引数\n [].to_list, # use_envは常に空\n # mac_envはグローバル変数、ローカル変数の全シンボルリスト\n (global_variables() + local_variables()).to_list\n )\n }\n _tmp( :inner )\n}\n_tmp( :outer )\n\nRubyへのマクロ展開結果(説明のためかなり簡略化している)\nマクロ展開フェーズで、callProcedure部分が展開される\n_tmp = lambda {|x|\n _tmp = lambda {x|\n :outer\n }\n _tmp( :inner )\n}\n_tmp( :outer )\n\n=&gt; 結果S式評価結果は outerとなる。\n[Nendo]ではLispのlambdaをRubyのlambdaで置きかえる方式のため、上記のような方法でレキシカル環境をマクロ展開する場所に埋めこむ。\nもし、VMのバイトコードに変換する方式を採用した場合は、環境フレームを処理系が管理するやりかたが恐らく一般的だろう。(chibi-schemeもそうなっている)\n[Nendo]では最大限Rubyとの親和性を担保しやすいこと、環境フレームを管理することの実行時オーバヘッドを軽減するという観点から、VM方式は採用していない。\n\nデメリット\n処理系が環境フレームを管理しない場合のデメリットは次の通り。\n複数の場所で局所的syntaxが使われた時は、それぞれが別の環境になる。\n環境フレームを自前で管理する方式では、同一のフレームは一つのインスタンスを共有することができるが、[Nendo]のようにマクロ展開する場所に環境を復元するコードを埋めこんでいく方式では、全て別々のインスタンスとなる。\n\nこれは、局所的syntaxが使われる回数によっては、展開後コードが肥大化するというデメリットがある。\n\n注意点\nマクロ展開の結果、let-syntaxを含むS式が変革される場合は注意が必要となる。\nさらには、let-syntaxで定義したsyntax-rulesの部分でlet-syntaxで束縛したsyntaxを(再帰的に)使用している場合を考慮すると、環境復元コードも再帰的に展開されることになる。\nそのため、環境復元コードの中に同一の変数が見つかったものをリダクションする必要がある。\n\nいいかえると、結局のところ必要に応じて環境フレームの共有(融合)を行う必要がある。\ner-macro-transformer(hygienic explicit renaming transformer)に必要な関数\nchibi-scheme 0.3のREADMEに記載されているように、以下の関数を実装する必要がある。\nSYNTAX-RULES macros are provided by default, with the extensions from\n SRFI-46. In addition, low-level hygienic macros are provided with\n a syntactic-closures interface, including SC-MACRO-TRANSFORMER,\n RSC-MACRO-TRANSFORMER, and ER-MACRO-TRANSFORMER. A good introduction\n to syntactic-closures can be found at:\nhttp://community.schemewiki.org/?syntactic-closures\nIDENTIFIER?, IDENTIFIER-&gt;SYMBOL, IDENTIFIER=?, and\n MAKE-SYNTACTIC-CLOSURE and STRIP-SYNTACTIC-CLOSURES are provided.\n[Nendo]で実装した関数と、その解説を行う。\nVM方式のLisp処理系とは違った考慮が入っている可能性がある。そのため、VM方式を採用しているLisp処理系にはそぐわない可能性があることに注意すること。\n\ner-macro-transformer\nchibi-scheme 0.3のコードは全てlambda式で書かれており、意味が汲み取りにくい。\n読みやすいように改変してはいるが、本質的な意味においては chibi-scheme 0.3のコードから改変なし。\n\n;; readable code for nendo. (original code is chibi-scheme-0.3)\n(define er-macro-transformer\n (lambda (f)\n (%syntax (expr use-env mac-env)\n (define (expander-main rename compare)\n (f expr rename compare))\n (define (_rename renames)\n (lambda (identifier)\n (let (*cell (assq identifier renames)*)\n (if cell\n (cdr cell)\n ((lambda (name)\n (set! renames (cons (cons identifier name) renames))\n name)\n (make-syntactic-closure mac-env '() identifier))))))\n (define (_compare x y)\n (identifier=? use-env x use-env y))\n\n (expander-main\n (_rename '())\n _compare))))\n\nidentifier?\nシンボルとidentifierの区別は不要。\n\n(define (identifier? x)\n (symbol? x))\n\nidentifier?\nシンボルとidentifierの区別は不要なので、無変換。\n別の型が入ってきたことに気づけるようにエラーチェックを入れているのみ。\n\n(define (identifier-&gt;symbol id)\n (when (not (symbol? id))\n (error &quot;Error: identifier-&gt;symbol requires only symbol&quot;))\n id)\n\nidentifier=?\nシンボルとidentifierの区別は無いため、シンボル同士のeq?でOK。\n\n(define (identifier=? use-env-x x use-env-y y)\n (eq? x y))\n\nmake-syntactic-closure\nRubyで実装している。\nリストは (syntax-quote ...) しか許さず、\nシンボルで、マクロ環境で束縛された変数なら、その束縛を含むレキシカルフレームのラップ 「(let (let (let ...)))」 で包んで返し、\nシンボルで、マクロ環境で束縛された変数でないなら、SyntacticClosureを返す。\n上記以外の式は許さない。(型エラー)\nこれにより、chibi-schemeのsyntax-rulesでrenameされるシンボルはマクロ環境の束縛状態においてidentifierの健全性が保たれる。\n\n def _make_MIMARKsyntactic_MIMARKclosure( mac_env, use_env, identifier )\n if _pair_QUMARK( identifier )\n if :&quot;syntax-quote&quot; == identifier.car\n identifier\n else\n raise TypeError, &quot;make-syntactic-closure requires symbol or (syntax-quote sexp) only. but got: &quot; + write_to_string( identifier )\n end\n elsif _symbol_QUMARK( identifier )\n if mac_env.to_arr.include?( identifier.intern )\n found = @lexicalVars.find { |x| identifier == x*0* }\n if found\n lexvars = @lexicalVars.clone\n __wrapNestedLet( identifier, lexvars )\n else\n identifier\n end\n else\n SyntacticClosure.new( identifier, (toRubySymbol( identifier ) + _gensym( ).to_s).intern )\n end\n else\n raise TypeError, &quot;make-syntactic-closure requires symbol or (syntax-quote sexp) type.&quot;\n end\n end\n\nちなみに、SyntacticClosureは次のように定義され、[Nendo]独特のトリックが使われてる。\nSyntacticClosureはリネーム前のシンボルと、リネーム後のシンボルが保持されており、\nマクロ展開後に、quoteされたSyntacticClosureは、originalSymbol側が使用され、quoteされずに変数名として使用されるとgensymでリネームされた(健全性が保たれた)ほうが使用される。\n class SyntacticClosure\n def initialize( originalSymbol, renamedSymbol )\n @originalSymbol = originalSymbol\n @renamedSymbol = renamedSymbol\n end\n\n def to_s\n @renamedSymbol.to_s\n end\n\n def intern\n @renamedSymbol\n end\n\n attr_reader :originalSymbol, :renamedSymbol\n end\n\nstrip-syntactic-closure\nRubyで実装している。\nリストをトラバースしてSyntacticClosure型が見つかったら、sexp.internでリネームされた側のSymbolに変換する。\n\n def _strip_MIMARKsyntactic_MIMARKclosures( sexp )\n case sexp\n when Cell\n if _null_QUMARK( sexp )\n sexp\n else\n Cell.new(\n _strip_MIMARKsyntactic_MIMARKclosures( sexp.car ),\n _strip_MIMARKsyntactic_MIMARKclosures( sexp.cdr ))\n end\n else\n if sexp.is_a? SyntacticClosure\n sexp.intern\n else\n sexp\n end\n end\n end\n\n再帰的にマクロ展開する箇所\nマクロ展開エンジンで下記の箇所を再帰的にマクロ展開しなければならない。\n (let-syntax\n (( (syntax-rules (ellipse)\n (( )\n ( ))\n ...))\n ( (syntax-rules (ellipse)\n (( )\n ( ))\n ...)))\n )\n、 を の定義と大域シンタックスを使ってマクロ展開する必要がある。(再帰的マクロ展開も考慮すること)\n、 を の定義と大域シンタックスを使ってマクロ展開する必要がある。(再帰的マクロ展開も考慮すること)\nをの定義、の定義、大域シンタックスを使ってマクロ展開する必要がある。\n制限事項\n上記の方式ではletrec-syntaxはサポートできていない。\n※ 現時点で、chibi-schemeとGaucheのライブラリを確認したところ、letrec-syntaxを使ったライブラリは無かったため、[Nendo]ではサポートは保留とした。\nまとめ\nschemeで書かれた、ポータブルなsyntax-rulesを、Rubyのようなレキシカルスコープを持つ言語にトランスレートする方法を解説した。\n簡略化しているもののchibi-scheme 0.3のsyntax-rulesをポーティングする際に実装が必要となる関数群を[Nendo]の実装例とともに解説した。",
    "url": "/2011/7/4/2011-07-04-post/"
  },
  {
    "id": "2011-07-06-post",
    "title": "平仮名フレーズ辞書を追加してみようかな(1)",
    "date": "2011-07-06",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-07-06-post.md",
    "content": "現在の[Sekka] (version 0.8.7)は、漢字の語彙ならば、曖昧辞書検索を使ってミスタイプを補正してくれる。これがSKKに対するアドバンテージになっていると思う。\nしかし平仮名のフレーズ、例えば「しました」とか「なっています」などのように平仮名のフレーズは辞書に無いのでミスタイプを救えない。\n「なっています」のように少々長めのフレーズだとかなりミスタイプをしてしまう。まだ改善の余地がある。\n ｎａｔｔｅｉｍａｓ (最後のuを入力せずに変換した例)\nそこで、平仮名の入力モードにおいても、辞書にあるフレーズならば曖昧辞書検索で救済することを考える。\n[Sekka]側の実装自体はそんなに手間では無いと思うが、辞書をどうやって入手するか、もしくは作るかが問題。\nそんなおり、@nokunoさんがこんな記事を書いてくださっていたので、ここから選ぶことにし\nた。(NLP関係のリソースまとめ - nokunoの日記)\nざっと中を見てみた。ライセンス的に使えなさそうなものは最初から除外した。\nN-gram コーパス - 日本語ウェブコーパス 2010\n1-gramで頻度まで求めてくれているので非常に使いやすく、なんの加工もなしにフレーズ辞書に使えそう。\n但し、日本語として美しくないものも大量に含まれていて、今回のアプリケーションには適さない。曖昧辞書検索で間違いを正そうとしているので、書き言葉でないフレーズに補正されるのはいただけない。\n一部抜粋してみてみよう。\nxz -cd ./nwc2010/ngrams/word/over999/1gms/1gm-0000.xz | head -1000\n\n.\n .\n ぁり 9140\n ぁりがと 4256\n ぁりがとぅ 4372\n ぁりがとぅござぃました 2241\n ぁりがとぅござぃます 3422\n ぁりがとう 1224\n ぁりがとうございます 1497\n ぁりがとぉ 3532\n ぁりました 1084\n ぁります 3322\n ぁりません 1482\n .\n .\nIPAdic\nここから美しい書き言葉の組み合わせを生成できそう。\nただ、付属のドキュメント ipadic-ja.pdf を見た限りでは、かなりの作業がいりそう。\nまあ形態素解析用の辞書から、全組み合わせのコーパスを作りだそうというのだから目的が違いすぎる。\nほかのデータを見てから再度検討。\nと、ここまで来てふと考えた。\n上記のコーパスの1-gramをIPAdicに付属のChasenで解析し、正しく解析しきれたものを採用すればいいのではないかな？\nそれなら頻度1000以上ではなく頻度100以上の1-gramに対して解析してもそんなに大量の語彙数にならないのではないか。\n他にもWikipediaとかのコーパスもあるので、もう少し見てから決めよう。",
    "url": "/2011/7/6/2011-07-06-post/"
  },
  {
    "id": "2011-07-07-post",
    "title": "平仮名フレーズ辞書を追加してみようかな(2)",
    "date": "2011-07-07",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-07-07-post.md",
    "content": "昨日のエントリ「[kiyoka.2011_07_06]Sekka 平仮名フレーズ辞書を追加してみようかな(1)」の続き。\n平仮名フレーズ辞書の作りかただが、再度 矢田さんのウェブコーパスを調べてみた。\n 日本語ウェブコーパス 2010から引用\n 本コーパスの作成においては，様々なウェブサービス，ツール，コーパスを利\n 用させていただきました．開発者・研究者の皆様に感謝いたします．\n\nコーパスの作成・保存・配布には Amazon Web Services を利用しています．\nウェブ検索には Yahoo! JAPAN 検索 Web API を利用しています．\nウェブコーパスのシードには IPAdic を利用しています．\n文字コードの変換には日本語用のパッチを適用した libiconv を利用しています．\nUnicode の正規化には ICU を利用しています．\n形態素解析には MeCab を利用しています．\nコーパスの圧縮には XZ Utils を利用しています．\n他にも様々なソフトウェアを利用しています．\n\nなんか勘違いしていた。IPAdicとMeCabが使われている。\nうまくフィルタリングすれば有用なデータが取れることがわかってきた。\n[Sekka]用に一番集めたいフレーズは、「なりました」「しました」などの文末に出てくる定型フレーズ。自分としては使用頻度が高く、かつミスタイプでグダグダになりやすい傾向がある。\nこれは「なり」「まし」「た」などのような形態素を結合したものになるのだが、N-gramコーパスの 6-gramの (文境界マーク) 付きの高頻度共起データから取れそう。\nまず、を見つけて、その直前の平仮名だけで構成される形態素を結合すれば良いかな。\n例外として 「と」「の」「て」「に」「お」「は」 の形態素は捨てるべきかな？ これは結果データを見てから決めよう。[Sekka]のユースケースから考えると付いている/付いていないの両方があったほうがいいのかも。\n「6mg-0000.xzの抜粋」\n .\n .\n % OFF と なり ます 1222\n % OFF に なり ます 2189\n .\n .\n \" 監督 やり たい \" 1800\n \" 現象 \" で ある 1319\n .\n .\n % 減少 し て いる 1973\n % 減少 し まし た 1714\n % 近く 上がり まし た 3594\n .\n .\n % と なっ て いる 27945\n % と なり まし た 8012\n % な ん です か 1184\n % に すぎ なかっ た 1546\n % に すぎ ませ ん 2356\n % に とどまっ て いる 4109\n % に なっ て いる 2149\n % に なり まし た 3459\n % に も なり ます 1126\n % に も 満た ない 1974\n % に 上っ て いる 1020\nその次には「しかし」「もっとも」などの接続詞や副詞、や「こういう」などのような連体詞、その他使用頻度の高いフレーズが欲しい。\nそれは 1-gramから単純に取るのでいいのか、2-gramくらいから抜き出したほうがいいのか… これも推測より実験かな。\nなんとかあまり労力をかけずにデータを集めれそうだ。いい時代になったなあと思う反面、便利すぎて大規模データに触れるチャンスが…\nもっとデータの精度に拘れば、大規模データを自分で処理する必要が出るのだろう。\nうーん。このままHadoopなどを使って大規模データマイニングをやるのが先延ばしになりそう。\n\nコメント by yoriyuki:\nUnicodeの正規化にicuを使っているとのことですが、具体的にどういう正規化なのか分かりますか？\n\nコメント by kiyoka:\n残念ながら、どういう正規化が行われているかはわかりませんでした。\nウェブコーパス作成におけるICUの利用目的も書いてありませんので、手がかりがありません。\nウェブマイニングする場合の最低限の正規化が組み込まれているのでしょうか。\n\nコメント by yoriyuki:\nなるほど、どうもありがとうございました。\nコメント by yoriyuki:\nUnicodeの正規化にicuを使っているとのことですが、具体的にどういう正規化なのか分かりますか？\nコメント by kiyoka:\n残念ながら、どういう正規化が行われているかはわかりませんでした。\nウェブコーパス作成におけるICUの利用目的も書いてありませんので、手がかりがありません。\nウェブマイニングする場合の最低限の正規化が組み込まれているのでしょうか。",
    "url": "/2011/7/7/2011-07-07-post/"
  },
  {
    "id": "2011-07-13-post",
    "title": "平仮名フレーズ辞書を追加してみようかな(3)",
    "date": "2011-07-13",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-07-13-post.md",
    "content": "先日来のエントリ \n 「[kiyoka.2011_07_06]Sekka 平仮名フレーズ辞書を追加してみようかな(1)」\n 「[kiyoka.2011_07_07]Sekka 平仮名フレーズ辞書を追加してみようかな(2)」\nの続き。\n実際にWebコーパスの6-gramのデータの中から、文末に出てくる定型フレーズを集めるスクリプトを書いてみた。\n文末で、且つ、平仮名のみで構成されている形態素を連結した文字列をSekka用フレーズとした。\n文末は (文境界マーク) で判断した。\n入力例\n% が 加算 さ れ て 1152\n% が 加算 さ れ ます 1463\n% しか あり ませ ん 1995\n% だっ た そう です 1554\n% だっ た の が 、 1142\n% だっ た の に対し 、 3496\n% で 、 環境 問題 に 1898\n% で あっ た が 、 2212\n, と し て いる 1007\n, と 思い まし た 1780\n\n出力例\nしかありません ;; 7 ;; (&quot;!%&quot; &quot;しか&quot; &quot;あり&quot; &quot;ませ&quot; &quot;ん&quot; &quot;&quot; &quot;1995&quot;)\nだったそうです ;; 7 ;; (&quot;!%&quot; &quot;だっ&quot; &quot;た&quot; &quot;そう&quot; &quot;です&quot; &quot;&quot; &quot;1554&quot;)\nとしている ;; 5 ;; (&quot;!,&quot; &quot;と&quot; &quot;し&quot; &quot;て&quot; &quot;いる&quot; &quot;&quot; &quot;1007&quot;)\nました ;; 3 ;; (&quot;!,&quot; &quot;と&quot; &quot;思い&quot; &quot;まし&quot; &quot;た&quot; &quot;&quot; &quot;1780&quot;)\n\nプログラムは[Nendo]で書いたが、非常に計算が重い。(処理系の問題)\nGaucheでも動くポータブルなコードにすべきだったかも。まあ何回も動かすわけではないからいいか。\n#!/bin/sh\n:; #-*- mode: nendo; syntax: scheme -*-;;\n:; exec /usr/local/bin/nendo $0 $*\n\n(use srfi-1)\n(use sekka.roman-lib)\n\n(define (hiragana-filter words)\n (define (hiras lst)\n (cond\n ((null? lst)\n lst)\n ((is-hiragana (car lst))\n (cons\n (car lst)\n (hiras (cdr lst))))))\n\n (let1 lst (cdr (reverse words))\n (reverse (hiras lst))))\n\n(define (include-slash-s? lst)\n (any\n (lambda (x y)\n (and\n (string=? &quot;&quot; y)\n (is-hiragana x)))\n (cons &quot;&quot; lst)\n lst))\n\n(define (grep-last-phrase filename)\n (with-open\n filename\n (lambda (f)\n (for-each\n (lambda (line)\n (let* (*lst (to-list (line.chomp.split #/[ \\t*+/))]\n *freq (take-right lst 1)*\n *words (drop-right lst 1)*)\n (when (include-slash-s? words)\n (let1 phrase (apply + (hiragana-filter words))\n (printf &quot;%s ;; %2d ;; %s\\n&quot;\n phrase\n phrase.size\n (write-to-string lst))))))\n (f.readlines.to_list)))))\n\n(define (main argv)\n (if (&gt; 1 (length argv))\n (error &quot;hiragana_phrase.nnd requires *6gram web corpus file*&quot;)\n (grep-last-phrase (car (to-list argv)))))\n\nこの処理のあと、「ー」が含まれるフレーズや、「っぁぃぅぇぉ」などで終わるフレーズは固い文章を書いている時に出てくると困るので、外している。\n例えば、「どーも」とか「よろしくっ」とかが頻繁にサジェストされてると非常に困る。そういうくだけた表現は自分で故意に入力すればいい。\nまた、辞書の語彙として有意なものに限定するため ２文字から７文字までの長さのフレーズに絞り込んだ。\nプログラムはこちら。\n#!/bin/sh\n:; #-*- mode: nendo; syntax: scheme -*-;;\n:; exec /usr/local/bin/nendo $0 $*\n\n(define (writing-phrase? str)\n (not\n (or\n (rxmatch #/ー/ str)\n (rxmatch #/*ぁぃぅぇぉゃゅょっー*$/ str))))\n\n(define (writing-phrase-filter filename)\n (with-open\n filename\n (lambda (f)\n (for-each\n (lambda (line)\n (let* (*lst (to-list (line.chomp.split #/[ \\t*+/))]\n *word (car lst)*)\n (when (and ( 1 (length argv))\n (error &quot;writing_phrase_filter.nnd requires file as 'hiragana ;; ....' &quot;)\n (writing-phrase-filter (car (to-list argv)))))\n\nファイルから読みこんで1行ずつ処理するプログラムを書くことが多いので、もっと便利な関数を作りたくなってきた。\nGaucheに習って [Nendo] に port-&gt;string-list を作るかな。\nあっ、そうか portの概念をどうする決めかねていて止まっているんだった。どうするかなぁ。\nとりあえず これでお茶を濁してportとしてしまうかー。いいのかな。\n class LispPort &lt; File\n end",
    "url": "/2011/7/13/2011-07-13-post/"
  },
  {
    "id": "2011-07-14-post",
    "title": "コードゴルフならぬシステムゴルフ",
    "date": "2011-07-14",
    "categories": [
      "プログラミング"
    ],
    "file_path": "_posts/2011-07-14-post.md",
    "content": "ふと、自分のプログラミングに対する趣味・趣向について振り返ってみた。\n今まで自分の作ってきた作品には、共通項があるんじゃないか。\nその結果「なるべく短いコードでシステムを作ろうとしている」という共通項が見えてきた。\nいうなれば、コードゴルフならぬ「システムゴルフ」。\n私は実行速度にはあまり拘らないほうだ、それよりは、書いたコードが短く収まるほうを選ぶ。\nそのために、少しくらい読みにくいコードがあってもかまわない。コード行数が圧縮されれば。\n読みにくい部分が局所化されていれば。ある程度のトレードオフはあるが。\n人のライブラリを使うのも厭わないほうだ、選ぶのにも時間をかける。結果的に自分が見る範囲のコードが短くなるのなら努力を厭わない。\n最近はプログラミング言語処理系の[Nendo]開発にまで手を出してしまったが、これも考えてみればシステムゴルフのためだと言えなくもない。\nライブラリが大量にあるRuby上にLispを構築したのは自分の潜在意識の中に「システムゴルフ」があるからだろう。\n何かを作りたくなった時、MongoDBやRedisなど最新の技術を使ってみたくなる。最新の技術はとかくアプリケーション側のコードを短くするための工夫がされていることが多い。\nそれらは自分のシステムをなるべく短い行数でプログラムする努力を後押ししてくれる。\nさらには、Lispのマクロによってコードを圧縮できる。\nただし、短いコードは意味が濃縮されているので、他人からはファーストインプレッションで拒否反応を起こされることもあるのが欠点。\n実は拒否反応は括弧の多さ(見た目？)だけによるものかもしれないけど…\nとにかく、自分は今後も「システムゴルフ」の上達を目指す姿勢は変わらないんだろうなぁと思う。",
    "url": "/2011/7/14/2011-07-14-post/"
  },
  {
    "id": "2011-07-30-post",
    "title": "Nendo 0.5.2 リリース",
    "date": "2011-07-30",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-07-30-post.md",
    "content": "[Nendo] 0.5.2をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの目玉\n高速化しました。\n- 固定長引数の関数呼び出しは、末尾再帰呼び出しのトランポリンを経由せずRubyのメソッドを直接呼び出す最適化を行った。\n =&gt; ビルトイン関数の最適化のみに適用した。\n =&gt; tak関数で約6.5倍、長さ10000のリストのmap filter for-eachがversion 0.5.1に比べて4倍の高速化となった。\n全体的に体感速度が良くなっています。\nこれは[Sekka] 0.8.8の変換速度として体感することができます。([Sekka]は後日リリース予定)\n次の目標\n前回と変わらず、例外処理まわり何とかしたいです。\n(参考:[kiyoka.2011_06_24]Nendo Nendo 0.5.1 リリース)",
    "url": "/2011/7/30/2011-07-30-post/"
  },
  {
    "id": "2011-07-31-post",
    "title": "Sekka 0.8.8 リリース",
    "date": "2011-07-31",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-07-31-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.8.8をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nversion 0.8.8\n\ngemの依存規則で、Nendoの必須バージョンを0.5.2のみとした。\n Nendo 0.5.1からNendo 0.5.2に変更することで、Nendo処理系が高速化する。\nC-gで変換候補のリアルタイム表示を終了するようにした。\n\nバグ修正\n-- 変換候補の中に漢字候補(type=j)が含まれない場合、候補選択ができないバグを修正した。\n 後で平仮名から片仮名に選択し直そうと思ってもできない。\n 例えば、「とらとらとら」を「toratoratora」で入力・確定したあと、Ctrl-Jで変換候補選択に入れない。\n次の目標\ngitのブランチにて「しています」「なりました」等の平仮名キーワードもタイプミス訂正をする機能を試してみています。\nそれが安定したら 0.9.0 としてリリースしようと考えています。\n[Nendo]処理系のさらなる高速化とあわせて、もう少し反応速度も上げたいです。\n特に、辞書登録がもっさりしているので、そちらを改善するのが先かな。",
    "url": "/2011/7/31/2011-07-31-post/"
  },
  {
    "id": "2011-08-02-post",
    "title": "アサハカな日英翻訳プログラムのアイデア",
    "date": "2011-08-02",
    "categories": [
      "翻訳"
    ],
    "file_path": "_posts/2011-08-02-post.md",
    "content": "だいぶ前から考えているアサハカなアイデアがあるのだが、いくら考えてもあまり良いアイデアに昇華しない。\nこの狭い日本語圏には、きっと同じことを考えてはボツにしている人がもうひとりくらいは居るだろう。私のアイデアを晒しておこうと思う。\nアイデアは「あるルールの範囲内で日本語文章を書けば正確な(読める)対訳英文が出力される」というシステム。というか翻訳ツール。\n\n概要\nオープンソースソフトウェアなどのマニュアルなど、技術的なドメインでは定型の文章が大半を占める。\nよほど奇をてらったようなチュートリアルを書こうと思わない限り、使うフレーズのパターンは増えないと考える。\nそこで、ある制限されたルールの範囲内で日本語文章を書けば、正確な(読める)対訳英文が出せるのではないか、というのが発端。\nコンパイラ(翻訳プログラム)がルールを逸脱した文章が検出すればエラーを報告してくれれば、制限を確認しながら原文を書いていくことができる。\n※ Emacsのflymakeのようなものを使って、リアルタイムのフィードバックを見ながらシステムに文章を入力するようなイメージ。\nメリット\n\n翻訳ターゲットの言語の知識が無くても、翻訳後の文章の品質をツールが担保してくれる。(特に、a the on of in with などの用法が正確になる)\nあらかじめ日英両方の言語でメンテナンスしたい技術ドキュメントの原文を一元管理できる。\n「読める」英語を書くスキルが無い人でも英語圏に向けて発信可能なドキュメントを作ることができる。\n翻訳に人的コストが発生しない。\n\nさらなるメリット(かなり眉唾)\n日本語の原文に使える語彙や文法を限定することによって、原文の意味の解析が容易になる。それにより、英語の文章の生成だけでなく、数十言語への翻訳が可能となる。\n問題点\n* 解決できる課題は限定的\n英語圏の人間がドキュメントを読めるようになったとしても、ドキュメントを書く人間が英語でコミュニケーションできない場合、英語のメーリングリストなどを使ってコミュニケーションを取れるようになるわけではない。\n* 原文の言語は日本語のみ\n例えば、英語での校正文章をフィードバックされても、日本語がソースになっているためそのまま取り込めない。\n考察\nこのアイデアが解決する課題は非常に限定的なため、実際的な言語の壁を越えるためのツールとはなりえない。\nただし、その第一歩を踏み出すための補助ツール、翻訳の労力を削減するツール、複数言語の同期を維持管理するコストを削減するためのツールとしては十分有用と考えられる。\nしたがって、英語の読み書きのスキルが高い人であっても、うまく活用すれば非常に有用なツールとなる可能性がある。\nまとめ\n翻訳後の文章の品質をツールが担保してくれるシステムがあれば非常に有用である。\n誰か作ってください。こんなツールがあれば使いたいです。\n対訳コーパスを使った翻訳システムが全盛の時代に、今更このようなヒューリスティックな手法は費用対効果の観点から問題がありそう。\nまた、翻訳システム関連の論文を読んでいるわけではないので、似たようなことをやった論文はあるかもしれない。調べていません。あしからず...\n\nコメント by shiro:\nおもしろいアイディアですが、言語的に制限してしまうとそれはピジン日本語のような新たな方言 (および、それが翻訳される先の、独特な英語の方言) を産み出すことになって、人間の読み書きの負荷が減るかどうか疑問です。\n翻訳ツールが訳しにくい部分、解釈しきれない部分をon the flyで指摘してくれて、対話的に解決できる (例えば曖昧な文脈にアノテーションをつけるなど) ようなツールならいいかも。人工言語のように制限内/外というのを厳密に判断するのではなくて、何らかのヒューリスティックに基づいた翻訳評価関数があって、そのスコアが低い場合に注意してくれる、というような。\n\nコメント by kiyoka:\nコメント頂けて嬉しいです。どなたからも反応ないだろうなと思っていたので。^_^\nピジン日本語をWikipediaで調べてみたら、「私、中国人あるね。」のような方言のことですね。ぎりぎり通じる中国語脳にやさしい日本語表現みたいな。ちがうかな。\n確かに、翻訳ツールのコンパイルエラーを回避するために原文をいろいろこねくりまわしていたら、結果的にそういうバッドノウハウ的な日本語ライティングテクニックが見つかって、とりあえず「やりすごす」みたいなことが頻発しそうです。その結果、日本語版のマニュアルはちょっと違和感のある文章が混在している、とかはありそうです。\nこのコンパイルエラー回避で試行錯誤する時間と、変な日本語を読む負荷を考えると結構キビシいかもです。\nさすが実際に翻訳をされたり、日英両方のドキュメントをメンテし続けていらっしゃる方ならではの鋭い指摘です。\n時々、日本人でも英語の訳文のような文体の方がいますが、（私もちょっとそういう感じかも）それと似た、書き言葉としての方言が発生するような状況が予想できます。\nshiroさんの案のように、評価関数のスコアの閾値で注意してくれるというのは良さそうですね。私の案は自然言語を、まるでプログラミング言語のようにパースできるものとして扱う前提になっています。\nいつかは、自然言語処理や機械翻訳を研究されている方々が技術を前進させてくれて、私の要望に近い翻訳ツールが出てくるといいなと思っていますが、それはいつごろなのでしょうね。\n自分で作るのはきっとムリなので期待して待ちたいと思います。\n\nコメント by shiro:\nプログラミング言語のように形式的に言語を決めてマニュアルを書くってことは、そのマニュアルの内容を(翻訳が可能な程度に)コンピュータが理解できる意味論も定義されるってことで、ということは結局新しい仕様記述言語を作っているのと変わらないんじゃないかって気がします。それならそういう言語の構文とセマンティクスを定めてやれば、いちいち翻訳するよりその言語を人間が直接読んで理解する方が速いし正確だ、ってことになりそうな。\n\nコメント by kiyoka:\nなるほど、翻訳原文用の仕様記述言語を作ったほうが、目的を達成する近道になりそうというということですね。\n確かにそんな気がします。\n意味論まで定義しようとすると、原文が自然言語ではかなり効率が悪そうです。\n達成したい目的から考えるとやりかたはいろいろありそうですね。\nコメント by shiro:\nおもしろいアイディアですが、言語的に制限してしまうとそれはピジン日本語のような新たな方言 (および、それが翻訳される先の、独特な英語の方言) を産み出すことになって、人間の読み書きの負荷が減るかどうか疑問です。\n翻訳ツールが訳しにくい部分、解釈しきれない部分をon the flyで指摘してくれて、対話的に解決できる (例えば曖昧な文脈にアノテーションをつけるなど) ようなツールならいいかも。人工言語のように制限内/外というのを厳密に判断するのではなくて、何らかのヒューリスティックに基づいた翻訳評価関数があって、そのスコアが低い場合に注意してくれる、というような。\nコメント by kiyoka:\nコメント頂けて嬉しいです。どなたからも反応ないだろうなと思っていたので。^_^\nピジン日本語をWikipediaで調べてみたら、「私、中国人あるね。」のような方言のことですね。ぎりぎり通じる中国語脳にやさしい日本語表現みたいな。ちがうかな。\n確かに、翻訳ツールのコンパイルエラーを回避するために原文をいろいろこねくりまわしていたら、結果的にそういうバッドノウハウ的な日本語ライティングテクニックが見つかって、とりあえず「やりすごす」みたいなことが頻発しそうです。その結果、日本語版のマニュアルはちょっと違和感のある文章が混在している、とかはありそうです。\nこのコンパイルエラー回避で試行錯誤する時間と、変な日本語を読む負荷を考えると結構キビシいかもです。\nさすが実際に翻訳をされたり、日英両方のドキュメントをメンテし続けていらっしゃる方ならではの鋭い指摘です。\n時々、日本人でも英語の訳文のような文体の方がいますが、（私もちょっとそういう感じかも）それと似た、書き言葉としての方言が発生するような状況が予想できます。\nshiroさんの案のように、評価関数のスコアの閾値で注意してくれるというのは良さそうですね。私の案は自然言語を、まるでプログラミング言語のようにパースできるものとして扱う前提になっています。\nいつかは、自然言語処理や機械翻訳を研究されている方々が技術を前進させてくれて、私の要望に近い翻訳ツールが出てくるといいなと思っていますが、それはいつごろなのでしょうね。\n自分で作るのはきっとムリなので期待して待ちたいと思います。\nコメント by shiro:\nプログラミング言語のように形式的に言語を決めてマニュアルを書くってことは、そのマニュアルの内容を(翻訳が可能な程度に)コンピュータが理解できる意味論も定義されるってことで、ということは結局新しい仕様記述言語を作っているのと変わらないんじゃないかって気がします。それならそういう言語の構文とセマンティクスを定めてやれば、いちいち翻訳するよりその言語を人間が直接読んで理解する方が速いし正確だ、ってことになりそうな。",
    "url": "/2011/8/2/2011-08-02-post/"
  },
  {
    "id": "2011-08-04-post",
    "title": "SQLiteをKVSのストレージに使う(アイデアのみ)",
    "date": "2011-08-04",
    "categories": [
      "アイデア"
    ],
    "file_path": "_posts/2011-08-04-post.md",
    "content": "SQLiteのテストスイート項目数の多さは有名だ。項目数の多さが欠陥の少なさを示しているわけではないが相関はあるだろう。\nこいつをKVSのストレージとして使えば、ソフトウェアのバグによるデータ破損が発生しにくいKVSが実現できるのではないかというアイデア。\nKVSは星の数ほどあるが、コードの信頼性の評価は難しい。\n普及率も把握できないし、参考にできるのは、どこそこのサイトで実運用しているという情報だけというのが正直なところ。\nそこで、SQLiteをバックエンドに持つKVSを使えばSQLiteの枯れたコードを利用して信頼性を確保できる。\nSQLiteはiPhoneやAndroid、ThunderBirdにも入っているため、コードはななり枯れていると推測できる。\nそのようなソフトウェアをちゃっちゃとでっち上げるとすれば、きっとNoSQLiteという名前になるだろうなー。\nと思ってGoogleで検索してみると… もう既にあった。\nDBIx::NoSQL - search.cpan.org\n DBIx::NoSQL - NoSQL-ish overlay for an SQL database\nDESCRIPTION\n DBIx::NoSQL is a layer over DBI that presents a NoSQLish way to\n store and retrieve data. It does this by using a table called\n Store. Once connected to a database, it will detect if this\n table is missing and create it if necessary\nWhen writing data to the store, the data (a HASH reference) is first\n serialized using JSON and then inserted/updated via DBIx::Class to\n (currently) an SQLite backend\nRetrieving data from the store is done by key lookup or by searching\n an SQL-based index. Once found, the data is deserialized via JSON\n and returned\nThe API is fairly sane, though still beta\n同じ作者のgithubを見に行ってみると。\n過去の作品だと思われる、同様のものがあった。\nrobertkrimen/FutonDb - GitHub\n FutonDb - A NoSQL-ish overlay for an SQL database\n作った動機はわからないけれども、作品はあるわけで、同じことを考える人はいるんだなぁと思った。\nついでにPythonにも同様のものがあったり。これはオブジェクトをシリアライズして保存するやつだけど。\n y_serial – warehouse compressed Python objects with SQLite — y_serial v0.60 documentation\n y_serial = serialization + persistance. In a few lines of code,\n compress and annotate Python objects into SQLite; then later\n retrieve them chronologically by keywords without any SQL. Highly\n useful NoSQL “standard” module for a database to store schema-less\n data.\nさて、SQLiteをバックエンドストレージにした場合、パフォーマンスは出ないだろうからKVSである必要性が無いんだよなーという、やはり本質的なところに戻ってきてしまった。\nきっと、超高速なKVSの裏方でレプリケーションスレーブにしてバックアップ専用に使うとかが現実的なのかな。\n例えば、次のような構成かな。\n Tokyo Tyrant =&gt; レプリケーション =&gt; NoSQLite(SQLite内蔵)\n または\n Kyoto Tycoon =&gt; レプリケーション =&gt; NoSQLite(SQLite内蔵)\nなんか、KVSのインタフェースを持つ必要性がうぃんあらなくなってきたぞ。あれれアイデアが破綻した…(笑)",
    "url": "/2011/8/4/2011-08-04-post/"
  },
  {
    "id": "2011-08-10-post",
    "title": "平仮名フレーズ辞書を追加してみようかな(4)",
    "date": "2011-08-10",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-08-10-post.md",
    "content": "先日来のエントリ \n 「[kiyoka.2011_07_06]Sekka 平仮名フレーズ辞書を追加してみようかな(1)」\n 「[kiyoka.2011_07_07]Sekka 平仮名フレーズ辞書を追加してみようかな(2)」\n 「[kiyoka.2011_07_13]Sekka 平仮名フレーズ辞書を追加してみようかな(3)」\nの続き。\n前回、6-gram Webコーパスから平仮名フレーズを抜きだして[Sekka]の辞書にする件を書いた。\nそれらは、実際にSekkaに組み込んでみて使いやすくなったので採用した。(未だリリース版には入っていないので注意)\n今、この文章は平仮名フレーズ辞書が入った開発版の[Sekka]を使って入力している。\n平仮名のフレーズもスペルミスを救済してくれるので、非常に気を抜いて入力できる。非常によいです。\nさて、さらに追加でWebコーパスだけでは得られないフレーズをIPADICから取得しよう考えている。\nここまでやって初めて[Sekka]のフレーズ辞書データが揃う。\n例えば、ipadic-2.7.0のtarボールに格納されているデータから拾うと、\nNoun.adverbal.dicからは、\n (品詞 (名詞 副詞可能)) ((見出し語 (いつか 2576)) (読み イツカ) (発音 イツカ) )\n (品詞 (名詞 副詞可能)) ((見出し語 (すべて 1464)) (読み スベテ) (発音 スベテ) )\n (品詞 (名詞 副詞可能)) ((見出し語 (おとつい 3278)) (読み オトツイ) (発音 オトツイ) )\n (品詞 (名詞 副詞可能)) ((見出し語 (このごろ 2305)) (読み コノゴロ) (発音 コノゴロ) )\nNoun.others.dicからは、\n (品詞 (名詞 非自立 副詞可能)) ((見出し語 (ところ 896)) (読み トコロ) (発音 トコロ) )\n (品詞 (名詞 非自立 副詞可能)) ((見出し語 (うち 950)) (読み ウチ) (発音 ウチ) )\n (品詞 (名詞 特殊 助動詞語幹)) ((見出し語 (そう 6)) (読み ソウ) (発音 ソー) )\n (品詞 (名詞 非自立 一般)) ((見出し語 (とき 2740)) (読み トキ) (発音 トキ) )\n (品詞 (名詞 非自立 副詞可能)) ((見出し語 (はず 2915)) (読み ハズ) (発音 ハズ) )\n (品詞 (名詞 非自立 副詞可能)) ((見出し語 (かぎり 2149)) (読み カギリ) (発音 カギリ) )\n (品詞 (名詞 非自立 副詞可能)) ((見出し語 (ため 428)) (読み タメ) (発音 タメ) )\nVerb.dicからは、\n (品詞 (動詞 自立)) ((見出し語 (さしだす 3505)) (読み サシダス) (発音 サシダス) (活用型 五段・サ行) )\n (品詞 (動詞 自立)) ((見出し語 (わりきる 3505)) (読み ワリキル) (発音 ワリキル) (活用型 五段・ラ行) )\n (品詞 (動詞 自立)) ((見出し語 (ひしめきあう 3505)) (読み ヒシメキアウ) (発音 ヒシメキアウ) (活用型 五段・ワ行促音便) )\nなどの単語を取り出せればと考えている。\nそれにしても、なんでipadicのデータはS式っぽいフォーマットになっているのだろう。\nまあ、Lisperにはそのまま(read)できて処理しやすいのでいいのだけど。他の言語で読み込む場合はどうするんだろ。まあいいか。\nここらでipadicの生データをmongoDBとかに入れて検索しやすくすると試行錯誤する時、レスポンスが速くていいのではと思っていたが、[Nendo]処理系をチューニングして速くなったのと、一旦手順が確立した後の再現性を考えると、[Nendo]でスクリプトを作ったほうがいいだろう。\n[Nendo]が手に馴染むようになって、Rubyでプログラミングとかは、もうする気が起きないなぁ。\ngemは作ったり、使ったりするんだけど。",
    "url": "/2011/8/10/2011-08-10-post/"
  },
  {
    "id": "2011-08-13-post",
    "title": "Travis CIを使ってみた",
    "date": "2011-08-13",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2011-08-13-post.md",
    "content": "Travis CIはRubyのオープンソースプロジェクトの継続的インテグレーション(CI)を行うプラットフォーム。\nTravis CI - Distributed build platform for the Ruby community\n An open-source, distributed build system for the Ruby community.\n使ってみて、非常に便利だったので紹介したい。\nといっても、現段階では複数versionのRubyでビルドとテストを行う機能に限定されている。\nGithub上のオープンソースプロジェクトを持っている人に特化している。\nRuby + GitHubでない人はゴメン。\n\n私は、Rubyで書かれた[Nendo]というLisp処理系を開発していて、これまで複数のRuby処理系で全部テストするの面倒だった。\nリリースの度に複数の処理系を切り替えてテストをするのが面倒くさくなってきて、「今回はJRubyのテスト端折ろうかな」と考えたことは一度では無い。\nTravis CIを使えば、そのような面倒なプロセスを自動化してくれる。スゲー。\nGitHub上の指定したブランチのpushタイミングで、自動的に複数のRubyバージョンのビルド&amp;テストが開始する。\nまずは試しに、[Nendo]のテストスイートをCRuby 1.9.2とCRuby 1.9.3の両方でテストする設定をした。\n早速、1.9.3側だけエラーが出た。\n\nなんと Dateクラスで1970年からの通算秒のフォーマットが変わっているようだ。\nそんなテスト項目を設定している自分が悪いのだけど、まあこういう仕様変更も発見できるわけだ。\n\nその後、調子に乗ってJRubyもテストするように設定した。\nしかし、自分の手元の環境とは違い Travis CIの環境では正しく動かないテスト項目がある。\n多分JRubyの基本的なバグだと思うが、手元で再現しないのでいったん保留にしておくことにした。残念…\n\nまあ、まだTravis CIはalphaサービスなので今後の改善に期待したい。きっと直るんじゃないかな。\n\nそれにしても、このようなサービスが無料で利用できるのは凄いことだ思う。\nやっぱ、Rubyのように勢いのあるコミュニティ周辺で遊ぶのはメリット大きいなぁと感じる今日この頃です。\nそれと、Rubyコミュニティには自動テストをてんこ盛り書くという文化は良いです。",
    "url": "/2011/8/13/2011-08-13-post/"
  },
  {
    "id": "2011-08-15-post",
    "title": "Nendo 0.5.3 リリース",
    "date": "2011-08-15",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-08-15-post.md",
    "content": "[Nendo] 0.5.3をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの目玉\n高階関数の第二引数にEnumerable型を渡せるようになりました。(但し、map filter for-eachのみ)\nこれにより、巨大なIOに対する逐次処理をfor-eachで書けるようになったり、list型だけでなくvector型に対して高階関数を適用できるようになります。\nエラーが発生した時、正確な行番号がバックトレースに出るようになりました。\nこれまでは実行速度を優先して、バックトレース用の情報をあまり格納していませんでした。(未定義変数のエラー時は正確でした)\n以下リリースノートです。\nversion 0.5.3\n\nmap filter for-each の第二引数に RubyのEnumerable型を渡せるようにした。\n 例)\n\nnendo&gt; (map (lambda (x) (+ x 1)) '#( 10 20 30 ))\n#(11 21 31)\nnendo&gt; (define f (.open &quot;VERSION.yml&quot;))\n#\nnendo&gt; (map (lambda (x) (+ &quot;# &quot; (x.chomp))) f)\n#(&quot;# ---&quot; &quot;# :major: 0&quot; &quot;# :minor: 5&quot; &quot;# :patch: 3&quot;)\n\n例外が発生したソースファイルと行番号が正確にbacktrace表示されるようにした。\n 但し、0.5.2から実行速度が後退した(約1/2程度)\n以下のバグを修正した。\n-- 引数ゼロの関数に、1つ以上の引数を渡した時、Nendo::Nilが引数に渡される。\n ArgumentError例外で引数の指定個数に謝りがあることを通知するようにした。\n-- JRuby1.6.xで通らないいくつかのテストケースを修正した。\n\n次の目標\n前回と変わらず、例外処理まわりを何とかしたいです。\n(参考:[kiyoka.2011_07_30]Nendo Nendo 0.5.2 リリース)",
    "url": "/2011/8/15/2011-08-15-post/"
  },
  {
    "id": "2011-08-17-post",
    "title": "いまやTravis-CIでビルドできるLispはClojureだけじゃないぜ",
    "date": "2011-08-17",
    "categories": [
      "CI"
    ],
    "file_path": "_posts/2011-08-17-post.md",
    "content": "Travis CI - Distributed build platform for the Ruby community\n[Nendo]も使える。\n[Nendo]で書いた日本語IME、[Sekka]がTravis-CIでビルド・テストできるようになったことがその証明だ。",
    "url": "/2011/8/17/2011-08-17-post/"
  },
  {
    "id": "2011-08-18-post",
    "title": "グダグダ変換",
    "date": "2011-08-18",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-08-18-post.md",
    "content": "[Sekka]の次の機能として「なっています」等の、よく使う平仮名フレーズも辞書に持つことでミスタイプを救済しようとしているところ。\nミスタイプしまくりでグダグダになった場合でもなんとか救済して変換できてしまうことを称して、「グダグダ変換」と呼ぼうと思う。\nたぶん「グダグダ変換」というキーワードは流行らないけれども、[Sekka]のキャッチコピーとしては、わかりやすいのではないかな？\n誰もがこの動画のようなスピードで入力してみたいと一度は夢見るだろう。\n ‪Yuki Typing\n[Sekka]はここまで無茶な入力をしてもなんとか変換できるレベルを目指しています。(嘘です)",
    "url": "/2011/8/18/2011-08-18-post/"
  },
  {
    "id": "2011-08-19-post",
    "title": "例外の捕捉について",
    "date": "2011-08-19",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-08-19-post.md",
    "content": "オレ処理系の[Nendo]についての開発メモ。\n\nGaucheのguardに似せたsyntaxになるようにトライしているところ。\nたぶん、guardとunwind-protectはGaucheと同等のsyntaxになると思う。\n実際には、例外クラスにはRubyのクラスが設定されるので、ソースコードレベルで互換性が確保できるわけではない無いけど…\nGauche脳とRuby脳の両方を持つ人にはGaucheのリファレンスをちらっと見ただけでコードが書けるレベルは保てるだろう。(Nendoのリファレンスも書く予定だけど…)\nどういう風にRubyのコードにマッピングするかは実装しながら考える。\nちなみに、今回初めてsyntax-rules使ってシンタックスを定義しているのだけど、これは楽だ〜。\nやっとブロックが積みあがってきた感じがするよ〜。",
    "url": "/2011/8/19/2011-08-19-post/"
  },
  {
    "id": "2011-08-21-post",
    "title": "スペースキーによる変換確定を試す",
    "date": "2011-08-21",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-08-21-post.md",
    "content": "[Sekka]のユーザ・インタフェースの欠点として、単語単位でCtrl-Jを押す必要があるところ。\nアルファベットキーの合間にCtrl-Jを上手に入力するのは、なかなかの慣れがいる。\nあまりにもCtrl-Jを押す回数が多すぎてしんどいので、これをなんとか改善できないかと思っていた。\nこの改善策を試してみている。\n試しているのは、候補サジェスト期間に限りスペースキーで変換確定できるというユーザ・インタフェース。\n(候補サジェスト期間というのは、Ctrl-J押下後、約30秒間続く状態で、この間は変換候補がリアルタイムで表示される。Ctrl-Gで中止できる)\n自分は普段Emacsの外の世界ではGoogle日本語入力やMS-IMEを使っているので、実際やってみるとそれほど違和感が無いことに気がついた。まあ似たキー操作になるしね。\nこれはデフォルトで有効にしておいて問題なさそう。気に入らない人は初期設定で無効にしてもらう。\nもう少し慣らし運転してみて、問題無さそうなら0.9.0に入れようと思う。\n次のSekkaのバージョンは0.9.0になる。つまりマイナーバージョン番号が上がる。\n平仮名フレーズ変換を理由にメジャーバージョン番号を上げるのは大袈裟な気がしていたのだけど、このユーザ・インタフェースは大きいので、まあ適当だろう。\nそうえば、Sekkaのユーザーがどれだけいるのか見えないのだけど、フィードバックが欲しいなぁと思っているところ。\nもしかしてユーザーって自分だけ？(笑)\n一応新バージョンをリリースする度に30ダウンロードぐらいはあるんだけど、その可能性は大きい。",
    "url": "/2011/8/21/2011-08-21-post/"
  },
  {
    "id": "2011-08-23-post",
    "title": "RSpecのformatterのカスタマイズ",
    "date": "2011-08-23",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-08-23-post.md",
    "content": "最近RSpecによるテストを Emacs の M-x compile で実行するようにした。\n何がいいかというと、エラー行に飛べるようになる。\nTDDによる開発を行う時は、先にテストケースを書いて、まだ製品コードが未実装の状態でテストがFailすることを確認してから製品コードを書き始める。\nそんな中、あまりにもFailした行に飛ぶのが面倒臭くなったのでEmacsが使えないか模索してみた。\nM-x compileを実行する\nRSpecの標準フォーマッタでは、RSpecが出力する飾りの # 記号が邪魔をしてEmacsが正しいファイル名を取得できない。\nまた、#を取るだけでは、RSpecツール本体の内部関数まで出てしまってじゃまだった。\nそれら直した結果、以下のように該当する行だけをエラー行と認識し、タグジャンプできるようになった。\n\n次のエラーメッセージにTabキーで移動、Returnキーでエラーソース行に移動する\n\nここまで作ってみたけど、EmacsにはRSpec実行するモードがあるんだろうな。ちょっと調べた限りでは見つかならなかったけど。\nせっかく作ったのでカスタマイズしたフォーマッタをRSpecの本家にpull requestしてみるかな。\nしかし、ちょっとしたローカルの変更とpull requsestダブリューするまでの敷居が以外と高いのでどうするか迷い中。\n今回書いたフォーマッタはこのソース。\nRSpec formatter for Emacs E-x compile feature — Gist\n次のように特別なオプションを指定してRSpecを実行する。\ntime rspec -I ./lib -b ./test/nendo_spec.rb -r ./test/rspec_formatter_for_emacs.rb -f CustomFormatter",
    "url": "/2011/8/23/2011-08-23-post/"
  },
  {
    "id": "2011-08-24-post",
    "title": "Sekka 0.9.0 リリース",
    "date": "2011-08-24",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-08-24-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.0をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n目玉は、「平仮名フレーズ」と「スペースキーでの変換確定」です。\n平仮名フレーズ\nSekka 0.8.8 では、\nnateimasu\n\nを変換すると辞書が無いので、入力通り「なています」となります。\nまあよくあるタイプミスですね。\nSekka 0.9.0 では、\nnateimasu\n\nを変換すると平仮名フレーズ辞書から一番近い「なっています」を第一候補に挙げてきます。\nまあ、この機能を入れたからといって、いつも人間に都合の良い結果になるとは限らないのは他のIMEと同じくSekkaもその限りでは無いのですが、まあものは試しでしばらく使ってみて、辞書の内容を微調整していこうと思います。\n※ 辞書が新しくなっているので、確固バージョンのSekkaをお使いの場合は[Sekka.VersionUp]を参考に、辞書も更新してください。\nスペースキーでの変換確定\nCtrl-J以外にスペースキーでも変換確定できるようになりました。(但し、サジェストモード期間中のみスペースキーが効きます)\nこれまではCtrl-Jだけしか使えなかったためCtrl-Jを大量に押す必要があり、かなり慣れが必要でした。\nこれで、MS-IMEやことえりなどの一般的な日本語入力システムに近いタイピングで変換ができるようになりました。\n※ サジェストとは以下のようにリアルタイムで第一変換候補フィードバックされる機能のことです。\nversion 0.9.0 変更点\n\n平仮名入力時も平仮名フレーズ辞書でスペルミスを救済するようにした。\n 辞書ソースはWebCorpusとipadic-2.7.0を使用した。\n N-gram コーパス - 日本語ウェブコーパス 2010\n Index of /stable/ipadic\n 経緯など\n [kiyoka.2011_07_06]Sekka 平仮名フレーズ辞書を追加してみようかな(1)\n [kiyoka.2011_07_07]Sekka 平仮名フレーズ辞書を追加してみようかな(2)\n [kiyoka.2011_07_13]Sekka 平仮名フレーズ辞書を追加してみようかな(3)\n [kiyoka.2011_08_10]Sekka 平仮名フレーズ辞書を追加してみようかな(4)\ngemの依存規則で、Nendoの必須バージョンを0.5.3に限定した。\n継続的インテグレーションを開始した。\n Travis CIでCRuby 1.9.2とCRuby 1.9.3のテストを通るようにした。\n Travis CIのテスト環境用にkvs.rbにdbmとRubyのHash(オンメモリ)での辞書管理を追加した。\nリアルタイム候補表示中(サジェスト期間中)はスペースキーで変換可能なユーザ・インタフェースにした。\n カスタマイズ変数 sekka-kakutei-with-spacekey で有効/無効を制御できる。\n デフォルトは有効。\n\n次の目標\nユーザ・インタフェースを少しづつ改善していきます。\nまた、辞書用ストレージとしてredisも選択できるようにしたいと考えています。",
    "url": "/2011/8/24/2011-08-24-post/"
  },
  {
    "id": "2011-08-25-post",
    "title": "バグ原因調査: sekka-serverの起動時に辞書の読み込みに失敗する問題",
    "date": "2011-08-25",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-08-25-post.md",
    "content": "@mori_devさんから[Sekka]のバグ報告があったので調査。\n sekka の不具合(?)報告 — Gist\n =&gt; sekka-serverの起動時に辞書の読み込みに失敗する。\nたぶんこれだろうと当たりがついているので、再現させてみる。\n現象から、Tokyo Cabinetのバージョン不整合の問題だと考えられる。\n新しいバージョンのTokyo Cabinetで作ったデータベースを古いTokyo Cabinetで開けようとしている可能性がある。\n環境\nこの記事で使った環境は次の通り。\nRubyはrvmは使わず、ソースからインストールしている。(厳密にはstowというパッケージマネージャを使っている)\n$ cat /etc/debian_version \n6.0.2\n$ uname -a\nLinux genkan.sumibi.org 2.6.34.1 #2 PREEMPT Thu Jul 22 16:04:48 JST 2010 i686 GNU/Linux\n$ ruby --version\nruby 1.9.2p290 (2011-07-09 revision 32553) *i686-linux*\n$ which ruby\n/usr/local/bin/ruby\n$ gem --version\n1.8.8\n\nSekka 0.8.8 / 0.9.0の辞書データ\n辞書データはTokyo CabinetのHashDBのデータベースファイルそのもので提供している。\n作成に使ったTokyo Cabinetのバージョンは 1.4.47 だ。\nTokyo Cabinetはソースコードからインストールした最新版だ。\nバージョン表示\n$ tchmgr version\nTokyo Cabinet version 1.4.47 (910:1.0) for Linux\nCopyright (C) 2006-2011 FAL Labs\n\n辞書の内容を表示する。\n$ tchmgr inform ~/.sekka-server/SEKKA-JISYO.SMALL.tch\npath: SEKKA-JISYO.SMALL.tch\ndatabase type: hash\nadditional flags:\nbucket number: 131071\nalignment: 16\nfree block pool: 1024\ninode number: 6554277\nmodified time: 2011-08-25T06:30:09+09:00\noptions:\nrecord number: 3686019\nfile size: 296903328\n\n古いTokyo Cabinetでオープンしてみる\nこれをDebian squeezeに入っているバージョンでオープンしてみる。\n$ dpkg --list | grep -i tokyo\nrc libtokyocabinet 1.2.1-1 Tokyo Cabinet Database Libraries *runtime*\nrc libtokyocabinet 1.4.37-6 Tokyo Cabinet Database Libraries *runtime*\n$\n\naptitudeでインストールする\n$ su -\n# aptitude install tokyocabinet-bin libtokyocabinet8 libtokyocabinet-dev \n# exit\n\n$ dpkg --list | grep -i tokyo\nii libtokyocabinet-dev 1.4.37-6 Tokyo Cabinet Database Libraries *development*\nrc libtokyocabinet3 1.2.1-1 Tokyo Cabinet Database Libraries *runtime*\nii libtokyocabinet8 1.4.37-6 Tokyo Cabinet Database Libraries *runtime*\nii tokyocabinet-bin 1.4.37-6 Tokyo Cabinet Database Utilities\n$\n\n$ tchmgr version\nTokyo Cabinet version 1.4.37 (827:1.0) for Linux\nCopyright (C) 2006-2009 Mikio Hirabayashi\n\n$ tchmgr inform ~/.sekka-server/SEKKA-JISYO.SMALL.tch\n/usr/bin/tchmgr: -: 5: invalid meta data\n\nやはりSekkaの辞書は読みこめない。エラーが出る。\n* sekka-serverではどのようなエラーになるか。\ntokyocabinetのGemを再度ビルドしなおす。\nそのためには、再インストールすればよい。\n$ gem uninstall tokyocabinet\n$ gem install tokyocabinet\nFetching: tokyocabinet-1.29.gem (100%)\nBuilding native extensions. This could take a while...\nSuccessfully installed tokyocabinet-1.29\n1 gem installed\nInstalling ri documentation for tokyocabinet-1.29...\nInstalling RDoc documentation for tokyocabinet-1.29...\n\n結果、@mori_devさんの環境と同じエラーが出た。\n$ sekka-server\n/usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/lib/sekka/jisyo-db.nnd:176: TokyoCabinet::HDB.open error: file=/home/kiyoka/.sekka-server/SEKKA-JISYO.SMALL.tch (RuntimeError)\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/lib/sekka/kvs.rb:56:in `open'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/lib/sekka/jisyo-db.nnd:216:in `block (2 levels) in initialize'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/lib/sekka/jisyo-db.nnd:461:in `call'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/lib/sekka/jisyo-db.nnd:461:in `block in initialize'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/nendo-0.5.2/lib/nendo.rb:1598:in `call'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/nendo-0.5.2/lib/nendo.rb:1598:in `callProcedure'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/nendo-0.5.2/lib/nendo.rb:1336:in `openSekkaJisyo'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/nendo-0.5.2/lib/nendo.rb:1336:in `openSekkaJisyo'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/lib/sekkaserver.rb:57:in `initialize'\n from ./lib/sekka.ru:37:in `new'\n from ./lib/sekka.ru:37:in `block in '\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/builder.rb:51:in `instance_eval'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/builder.rb:51:in `initialize'\n from ./lib/sekka.ru:1:in `new'\n from ./lib/sekka.ru:1:in `'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/builder.rb:40:in `eval'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/builder.rb:40:in `parse_file'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/server.rb:200:in `app'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/server.rb:301:in `wrapped_app'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/server.rb:252:in `start'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/rack-1.3.2/lib/rack/server.rb:137:in `start'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/bin/sekka-server:90:in `main'\n from /usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/gems/sekka-0.8.8/bin/sekka-server:100:in `'\n from /usr/local/bin/sekka-server:19:in `load'\n from /usr/local/bin/sekka-server:19:in `'\n\n原因\n古いlibtokyocabinetでは、新しいlibtokyocabinetで作ったデータベースフェアを読み込めない。\n=&gt; @mori_devさんところでは発生しないので、@mori_devさんの環境はどうも別の原因っぽいが…\n\n対策\n配布する辞書は Debian と Ubuntuに入っているバージョンのTokyo Cabinetで作る。\nそれによって、[Sekka]をより広い環境で使える様にする。\nDebian squeeze ... tokyo cabinet 1.4.37\n http://packages.debian.org/squeeze/tokyocabinet-bin\nUbuntu 10.10 ... tokyo cabinet 1.4.37\n http://packages.ubuntu.com/maverick/tokyocabinet-bin\nこのあたりで作ればいいかな。\nDebian lennyはtokyo cabinet 1.2.1と古すぎるので対応しない。\n[Sekka] 0.9.1の辞書からtokyo cabinet 1.4.37で作って提供するようにしよう。\n@mori_devさんところの原因は個別に追っていく。こちらで議論して解決できればいいなぁ。\n sekka-serverの起動時に辞書の読み込みに失敗する問題 - sekka_users | Google グループ",
    "url": "/2011/8/25/2011-08-25-post/"
  },
  {
    "id": "2011-08-27-post",
    "title": "平仮名フレーズを辞書として持つのは失敗？",
    "date": "2011-08-27",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-08-27-post.md",
    "content": "平仮名フレーズ辞書を含めた、[Sekka] 0.9.0をリリースして少し経つが、平仮名フレーズを辞書に持つのは良いことなのかわからなくなってきた。\n\n平仮名のフレーズというのはあまりにパターンが多く、やはり普段使うフレーズ全てを辞書に収録するというのは無理がありそう。\n平仮名フレーズ辞書の影響で、Sekkaが勝手にユーザの意図しないフレーズに引きこんでしまうという問題が結構ある。\n例えば、上の文章に出てきた「ありそう」というフレーズ。\n辞書には、「ありそうな」しか入っていないため、\narimsou\n\nと入力すると、\n第一候補「ありそうな」\n第二候補「ありそう」\n\nとなり、ついつい第一候補で確定して見落してしまう。\n第二候補に「ありそう」も存在しているのだけど、[Sekka]は第一候補でとりあえず確定するのが基本。\n間違いがあれば、後で戻って修正するというユーザ・インタフェースになっているので間違いを見落としやすい。\n結果として、ユーザの意図しない文章になってしまうのだ。\n対策として、未知語(というか未知フレーズ)を見つけた時点でユーザが簡単に辞書登録できるユーザ・インタフェースを追加するという方法を考えている。\n今のSekkaは単語登録処理が重いという課題もあるので、単語の登録頻度が上がれば、それがストレスになる可能性もあるが、長期的に見て、辞書が蓄積されていくと文章入力時のストレスは減る方向になるのでそこはトレードオフだと思う。\nうーん。いろいろグダグダ書いたけど、実は日々使ってみて紆余曲折の末、問題が解決できたりするのは非常に楽しい。\nこれが自分でユーザ・インタフェース込みの日本語入力システムを作る楽しさなんじゃないかと思うのだ。\nなんというか自分を発見するというか、使いやすいユーザ・インタフェースはどんなものかというような。\n一緒に実験に参加させられているユーザはたまったものではないが(笑)\nそんなタイミングでSKKに戻っていったりするんだろうな〜(笑)\n\nコメント by Auth:\nJust the type of isnghit we need to fire up the debate.",
    "url": "/2011/8/27/2011-08-27-post/"
  },
  {
    "id": "2011-09-03-post",
    "title": "Sekka 0.9.1 リリース",
    "date": "2011-09-03",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-09-03-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.1をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n主にバグ修正です。\nまた、Tokyo Cabinetのデータベースで辞書データ提供するのをやめました。\nCPUアーキテクチャ間でTokyo Cabinetの辞書データベースのバイナリは互換性がないためです。\n将来、Tokyo Cabinet以外のKey Value Storeもサポートするのです、その伏線も兼ねています。\nversion 0.9.1 変更点\n\nCtrl-RでGoogleIME経由の辞書登録と平仮名フレーズの登録の両方を行えるようにした。\nTokyo Cabinetのサポートバージョンを 1.4.37 以上に引き下げた。\n Debian squeezeとUbuntu 10.10以上に含まれるTokyo Cabinetが1.4.37であるため。\n辞書ファイルの提供形式をTSV(タブで区切りのテキストファイル)にした。\n sekka-serverの初期化時にTSVの辞書ファイルをダウンロードし、その場で辞書ファイル(tch)に変換するようにした。\n (Tokyo Cabinetの辞書は異なるCPUアーキテクチャ間で互換性が無いため)\nバグ修正\n-- M-x 20 space でスペースが20文字入るはずが1文字しか入らないバグを修正した。\n-- sekka-pathが廃止予定のRubygemsのメソッドの使用をやめた。\n https://gist.github.com/1168173\n rubygems 1.8.xの環境では大量の NOTE: の表示が出てしまう\n-- \"2011nen9gatu\"などの数字混じりのクエリを変換するとサーバエラーが出る\n sprintfのフォーマット文字列(%s)と実引数の個数が異なるというエラー。\n\n次の目標\nユーザ・インタフェース改善のいろんなアイデアを試していきます。\n辞書ストレージとして、redisを使ってみようと思います。",
    "url": "/2011/9/3/2011-09-03-post/"
  },
  {
    "id": "2011-09-06-post",
    "title": "どれだけテストを書けばいいか(1)",
    "date": "2011-09-06",
    "categories": [
      "TDD"
    ],
    "file_path": "_posts/2011-09-06-post.md",
    "content": "いま自分のメインプロジェクトは二つあって、両方共TDDで開発している。([Nendo]、[Sekka])\nもうTDDでない開発方法には戻れないと思っているが、効果を上げるには[Nendo]側のテストスイートの網羅率が足りない気がしている。\n(科学的に分析したわけではないが… というか、そもそも科学的に分析できるものなのかもわからないけど)\nあきらかに[Nendo]のほうが複雑なソフトウェアだと思うので、より多くのテストコードが必要になるのだろう。\nそれぞれ、実際にテストコードがどれくらいあるのか気になったので調べてみた。\n調べるのは、製品コードとテストスイートの行数。\n\n実際に調べてみると、[Nendo]の製品コード(テストされる側のコード)は自分が思ったよりも行数が多い。\n5000行程度じゃないかと思っていたが、そうではなかった。\nおまけに、テストコードも製品コードと同じくらい書いていると思っていたが、実際はテストコードのほうが行数が少なかった。\n一方、[Sekka]のほうはバランス良さそう。一応テストコードのほうが行数が多い。\n感覚的には[Sekka]くらいがいいのかも。\n[Nendo]のほうはまだまだ機能追加していくけれども、このペースでいけばテストコードが製品コードを追い抜くことは無さそうだなぁ。\nこのブログのテーマに戻ると、結局どれだけテストを書けばいいかという結論は出なさそうだ。\nしかし何らかの指標にはなるので把握しておいて感覚を掴んでおくといいのではないかと思う。\n他のプロジェクトはどれくらいテストしているんだろう… というのはまた後日。",
    "url": "/2011/9/6/2011-09-06-post/"
  },
  {
    "id": "2011-09-08-post",
    "title": "[Redis](http://redis.io/)を試す",
    "date": "2011-09-08",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-09-08-post.md",
    "content": "前から気になっていたRedisを試した。 (Redis 2.2.12)\n\n[Sekka]の辞書ストレージに使うと高速になりそうだという直感があった。\nしばらく試した結果、非常に[Sekka]向きだということわかった。非常にレスポンスが良く、まさにスラスラという表現がしっくりくる。\n64MByteのメモリを割り当てたTokyo Cabinetと比べてひっかかりが無い。\n但し、問題もあって辞書データが全てメモリに載っているので、64bit環境のredis-serverだと、800MByteのメモリを常時消費した状態になる。\nこれはこれでいいだろう。最近のノートパソコンでもRAMは4GByteほど搭載されてきている。いつもメモリ消費量の進歩については私は楽観的なのだ。\n\nTokyo Cabinetでも設定次第でRedis同様にデータベースをオンメモリにし、DISKへの遅延書き込みもできるだろうが、Redisなら標準設定がそうなっている。\n設定無しでできるのなら、そちらをサポートしたほうが手間がかからない。ユーザにインストールしてもらうことも考慮すると設定不要なのは好都合なのだ。\nまた、In Memory データベースならではの工夫もされているだろうし、今後もいろんな改善が入ってくるだろう。\nSekka 0.9.2に入る予定なのでしばらくお待ちを。",
    "url": "/2011/9/8/2011-09-08-post/"
  },
  {
    "id": "2011-09-10-post",
    "title": "[Redis](http://redis.io/)は仮想メモリ機能を使ってメモリを節約してくれる",
    "date": "2011-09-10",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-09-10-post.md",
    "content": "Redisはメモリが溢れた時に仮想メモリを使用するようだ。\n単純なIn Memoryデータベースだと思っていたので、用途が限られると思っていた。\nデータが全てメモリに載りきらない応用にも使えるんじゃないかなぁ。\n以下は、redis-serverを少ないメモリ容量のサーバで動かした時の様子。\nPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND\n 739 kiyoka 18 0 146m 98m 3672 S 0 2.4 0:34.84 sekka-server\n 497 kiyoka 15 0 814m 46m 624 R 0 1.1 3:18.34 redis-server\n\nmemcachedと“正反対”、Redisが仮想メモリをサポート\n RedisはCで各種データ構造を実装したものをデーモンとしたようなソフトウェ\n アで、リード・ライトともに非常に高速なのが特徴。ただ、実メモリに乗り\n 切らないデータセットは扱えないことから利用局面が限定的だった。バージョ\n ン2.0では、新たに独自に仮想メモリ機構を実装。実メモリに乗り切らないデー\n タをディスクへ書き出す仕組みを取り入れた。\nこれはOSのスワップの仕組みそのものだが、Redisでは、あえて独自で実装し\n たという（実装にはLinuxカーネルを参考にしたという）。理由の1つは、デー\n タ構造が分かっている分、シリアライゼーションによる圧縮効果が高く（最\n 大で10倍程度）、OSに依存するよりもはるかに効率がよくなること。もう1つ\n の理由は、キー・バリューのうち、キーだけはすべてメモリ上に保持すると\n いう設計が可能なため。キーがすべてメモリに乗っていることから、Redisの\n 高速性は保たれるというわけだ。また実際のバリューのほうがいくら大きく\n なっても、メモリ消費量はキーの数にだけ依存することになり、100万キー当\n たり160MBのメモリ消費で済むという。\nなるほど、キーだけメモリ上に置くというのは工夫だなぁ。独自で実装する意味あり。\nこちらは詳細に仕様が書かれている。やはり効率良く仮想メモリを管理できるように独自に実装された仕様のようだ。\n 仮想メモリ技術仕様 — redis v2.0.3 documentation\n もうひとつの重要な仮想メモリの属性として、 vm_max_memory があります。\n このパラメータはスワップのトリガーを設定するために重要となります。\n Redisは、このメモリの設定値を超えた\n メモリを使用した場合にのみ、スワップを行おうとします。この値に到達しな\n い場合は、スワップの必要はないものとして動作します。\n同じ実メモリ容量を使った状態でも体感速度は、Tokyo CabinetよりもRedisのほうが軽く感じる。(Tokyo Cabinetが64MByteでRedisが上記の46MByteを消費した状態の場合)\n[Sekka]は最後に確定した変換候補を記憶するために辞書ストレージに頻繁に書き込みにいくが、Tokyo Cabinetのほうは即座にDiskにsyncしようするのに対して、Redisのほうは遅延させているのだろうと推測している。\n[Sekka]の場合、最悪学習データがDiskに書き込まれずにサーバが落ちても致命的な問題にならない程度の重要度なのでRedisは[Sekka]向きだ。\n実際に使ってみればいろいろ工夫が見えて勉強になる。何事も実践あるのみだね。",
    "url": "/2011/9/10/2011-09-10-post/"
  },
  {
    "id": "2011-09-17-post",
    "title": "Sekka 0.9.2 リリース",
    "date": "2011-09-17",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-09-17-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.2をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n過去の日記で何度か実験の様子を書きましたが、ついにRedisをサポートしました。\nこれまで通り、Tokyo Cabinetも使えます。\nRAMが大量に余っている環境では、Redisを試してみてください。(800MByteくらい余っていることが望ましい)\n非常にレスポンスが良くなります。辞書学習のディスク書き込みが遅延されているためか、ディスクIO特有の引っ掛かりは無くなります。\n体感的には全てmemcachedにキャッシュされているのという感じです。\n注意: [Sekka.VersionUp]を参考に古い辞書を一旦削除してください。\nversion 0.9.2\n\n辞書用ストレージとして、Redisに対応した。\n 経緯など\n [kiyoka.2011_09_08]Sekka Redisを試す\n [kiyoka.2011_09_10]Sekka Redisは仮想メモリ機能を使ってメモリを節約してくれる\n辞書にバージョン番号を含めた。(key=SEKKA::VERSION)\n [Sekka.VersionUp]を参考に古い辞書を一旦削除してください。\n sekka-serverへの辞書データアップロード済みかどうかを、上記のキー(SEKKA::VERSION)の有無で判断します。\n'q'キーで無変換を指定するユーザ・インタフェースを追加した。\n 有効/無効は、sekka-muhenkan-keyで 'q' 以外のキーに変更可能。\n\n次の目標\n特に決まったTODOは無いので、気がついたユーザ・インタフェースの改良などを随時やっていきます。",
    "url": "/2011/9/17/2011-09-17-post/"
  },
  {
    "id": "2011-09-22-post",
    "title": "Scaleの関数プログラミングのアプローチについて(1)",
    "date": "2011-09-22",
    "categories": [
      "Scala"
    ],
    "file_path": "_posts/2011-09-22-post.md",
    "content": "この本のScalaの章を読み初めたばかりで、まだScalaについてはよく分かっていないのだけど、作者のインタビューが掲載されていて、Scalaはオブジェクト指向と関数プログラミングの橋渡し役になるという話が書いてあった。現代の二大プログラミングパラダイムを両取り。\n自分として、一番興味があるのは、Scalaが破壊的操作が必須のオブジェクト指向と破壊的操作が非推奨の関数プログラミングのバランスをどう取っているのかというところ。\n現在私が開発中の[Nendo]という言語では、破壊的操作をしようしている場所を、実行時ではなくコンパイル時に検出できないかと考えている。\nScalaがそのへんを解決したのかが知りたい。\n仮に解決しているなら、どうやって解決しているのかを知りたいと思っている。\nまさか、実行時に検出できるレベルで満足しているのだったら残念なんだけど。もう、その時点でScalaから貰うものは無いかなー。\nHaskellの場合は、破壊的操作自体の無い純粋な世界を構築しており、プログラマがその世界の中でプログラミングしないといけないようにしてある。オブジェクト指向が付け入る隙は全く無い。プログラミングパラダイムは単一というわけだ。パラダイムというかパラダイス的な(笑)\nこの本でのScalaのページ数は少ないので書いていないかもしれないけど、ヒントくらいは書いてあればと楽しみに読んでいる。\nこのエントリの最後に(1)番号が書いてあるように、この疑問が解けるまで引き続き書く予定。",
    "url": "/2011/9/22/2011-09-22-post/"
  },
  {
    "id": "2011-09-24-post",
    "title": "foursquareは何故MongoDBを選んだか",
    "date": "2011-09-24",
    "categories": [
      "MongoDB"
    ],
    "file_path": "_posts/2011-09-24-post.md",
    "content": "このビデオを観た。\n The 10gen Blog on MongoDB and NoSQL, 10gen CEO on NoSQL; foursquare discusses why they use MongoDB\n\n foursquareのエンジニアの方のトーク。 何故、MongoDBを選んだか。\nNoSQLなのでスケールするのは当然として、ほかのNoSQLテクノロジに比べて、\n既存のSQLデータベースに近いので移行しやすいそうな。\n次にWebアプリを作るとしたら、試すのはMongoDBだなと感じた。",
    "url": "/2011/9/24/2011-09-24-post/"
  },
  {
    "id": "2011-09-29-post",
    "title": "Rubygems.orgから取得したgemでエラーが出るのはなぜか",
    "date": "2011-09-29",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2011-09-29-post.md",
    "content": "ずっと前から自分が作ったgemが環境によってエラーになる原因が解析できずにいた。\nやっと、tenderloveことAaron Patterson氏が書かれたブログエントリでメカニズムが理解できた。\nAaron Patterson氏の説明を読み解く\nShaving a YAML Yack | RubyGems.org\n Have you ever seen this error?\n$ gem install rails --pre\n ERROR: While executing gem ... (NameError)\n uninitialized constant Psych::Syck\n $\nYes, I have too. Today we’re going to discuss the source of this error, and what we\n need to do to fix it.\nやっぱり、誰もが同じエラーに遭遇していたのか。\n自分の環境が悪いのかと思っていた。自分の環境はちょっと違うエラーメッセージだけど、原因は同梱のようだ。\n結局RubyのYamlライブラリの互換性問題だった。\ngemspecファイルの依存規則のところに'='イコールを使うとダメらしい。\nGem::Specification.new do |s|\n ...\n s.add_dependency('activesupport', '= 3.1.0')\n ..\nend\n\n上記のようなgemspecファイルを元に、gemパッケージが生成されるが、gemの中に格納されるmetafileはyaml形式となる。\ngemパッケージ生成環境がPsychを使っている場合と、Syckを使っている場合で生成されるmetafile中の '='の扱いが異なる。\n再現確認\nメカニズムについては上記のAaron氏のブログエントリに書かれている通りなので、NGとOKパターンだけまとめると次のようになる。\n (1) OK ... Syckで作ったgem =&gt; SyckライブラリがインストールされたRuby環境でmetafile(yaml)をパース\n (2) OK ... Syckで作ったgem =&gt; PsychライブラリがインストールされたRuby環境でmetafile(yaml)をパース\n (3) OK ... Psychで作ったgem =&gt; PsychライブラリがインストールされたRuby環境でmetafile(yaml)をパース\n (4) NG ... Psychで作ったgem =&gt; SyckライブラリがインストールされたRuby環境でmetafile(yaml)をパース\nNGの確認は自分のOSSパッケージsekka-0.9.3のパッケージをPsych環境で作った。gemspecには次のような行がある。\n gemspec.add_dependency( &quot;nendo&quot;, &quot;= 0.5.3&quot; )\n\nなお、gemをインストールした環境はlibyamlの入っていないRuby環境だ。そこではyaml parserはPSychではなくSyckが使われる。\nこのようにエラーメッセージが出る。\n/tmp $ gem --version\nInvalid gemspec in */usr/local/stow/ruby-1.9.2-p290/lib/ruby/gems/1.9.1/specifications/sekka-0.9.3.gemspec*: Illformed requirement *&quot;# 0.5.3&quot;*\n1.8.10\n\n念のためSyck環境であることを確認。\n/tmp $ ruby --version\nruby 1.9.2p290 (2011-07-09 revision 32553) *x86_64-darwin10.8.0*\n/tmp $ irb\nirb(main):001:0&gt; require 'yaml'\nrequire 'yaml'\n=&gt; true\nirb(main):002:0&gt; YAML.dump * '=' *\nYAML.dump * '=' *\n=&gt; &quot;--- \\n- \\&quot;=\\&quot;\\n&quot;\nirb(main):003:0&gt; YAML.load &quot;---\\n- =\\n&quot;\nYAML.load &quot;---\\n- =\\n&quot;\n=&gt; *#*\nirb(main):004:0&gt; \n\nrubygems.orgとの関係\nAaron氏のブログエントリでも書いてあるように、rubygems.orgはmarshalされたオブジェクトをユーザーに配布しているらしい。\n上記の私の再現確認では、ローカルにあるgemファイルを使ってgem install していたが、rugygemsに登録した場合はrubygems.org内部のyamlパーサでパースしたmarshalオブジェクトが配布されるということだ。\n現在rubygems.orgはSyckだそうで、これからPsychに差しかえるべく動いているとのこと。\nつまり、Psyckでgemsでパッケージを作りrubygems.orgに登録すると上記のパターンで書いた(4)に該当する。\nこのとき、クライアント環境がどのような環境であろうとエラーが出るはず。これはマズい。\nShaving a YAML Yack | RubyGems.org\n How can we fix this?\nWe have two ways to deal with this issue. The first way to deal with\n this issue is to upgrade rubygems. Rubygems contains code to work\n around the issue when installing gems. But it does not fix the issue.\nThe only way we can fix this error for all users is to upgrade\n rubygems.org to use psych as the YAML parser. Upgrading rubygems.org\n will prevent the strange objects from entering marshal data sent to\n users.\n回避方法 案1\ngemspecはSyck環境でgemパッケージを作ってrubygems.orgに登録する。\n[Sekka]ではこれまで、この方法を使っていた。\n回避方法 案2\ngemspecに、'='を使わない。かわり'&gt;='を使う。\n* SekkaのRakefile\n現状\n gemspec.add_dependency( &quot;nendo&quot;, &quot;= 0.5.3&quot; )\n\n回避策\n gemspec.add_dependency( &quot;nendo&quot;, &quot;&gt;= 0.5.3&quot; )\n\nかなり姑息というか、本来行いたい指定とは違うのでちょっと不満がある。\n[Nendo]のほうで下位互換性を壊すバージョンアップがあった場合[Sekka]が動かなくなるという直接的な問題がある。\nただし、どんな環境でgemパッケージを作ってもよい。\nまとめ\ngemのinstall時のエラーは多くの人が遭遇しているはず。\nメカニズムを理解すれば環境に依存しないgemを作れるが、スマートな解決方法は無い。\n追記\n実際に複数の環境でgemパッケージを作り、内容を貼りつけた。\n「 [kiyoka.2011_09_30]Ruby Rubygems.orgから取得したgemでエラーが出るのはなぜか(追記)」",
    "url": "/2011/9/29/2011-09-29-post/"
  },
  {
    "id": "2011-09-30-post",
    "title": "Rubygems.orgから取得したgemでエラーが出るのはなぜか(追記)",
    "date": "2011-09-30",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2011-09-30-post.md",
    "content": "昨日のエントリ「[kiyoka.2011_09_29]Ruby Rubygems.orgから取得したgemでエラーが出るのはなぜか」の続き。\n実際に作ったGemパッケージの中のmetafileの内容を調べたのを貼りつけておく。\n昨日のエントリに入れると、記事として長すぎるのでやめたもの。\nRuby 1.9.1-p429 + Syck環境 + Rubygems 1.7.2で作った\nsekka 0.9.2の配布済みのRubyGems。\ngemspec\n gemspec.add_dependency( &quot;nendo&quot;, &quot;= 0.5.3&quot; )\n\ngem内部のmetadata\nrubygems_version: 1.7.2\n- !ruby/object:Gem::Dependency \n name: nendo\n requirement: &amp;id015 !ruby/object:Gem::Requirement \n none: false\n requirements: \n - - &quot;=&quot;\n - !ruby/object:Gem::Version \n hash: 13\n segments: \n - 0\n - 5\n - 3\n version: 0.5.3\n type: :runtime\n prerelease: false\n version_requirements: *id015\n\nRuby 1.9.2-p280 + Psych + rubygems 1.8.10で作った\ngemspec\n gemspec.add_dependency( &quot;nendo&quot;, &quot;= 0.5.3&quot; )\n\ngem内部のmetadata\n- !ruby/object:Gem::Dependency\n name: nendo\n requirement: &amp;72178800 !ruby/object:Gem::Requirement\n none: false\n requirements:\n - - =\n - !ruby/object:Gem::Version\n version: 0.5.3\n type: :runtime\n prerelease: false\n version_requirements: *72178800\n\nRuby 1.9.2-p280 + Psych + rubygems 1.8.10で作った\ngemspec\n gemspec.add_dependency( &quot;nendo&quot;, &quot;&gt;= 0.5.3&quot; )\n\ngem内部のmetadata\n- !ruby/object:Gem::Dependency\n name: nendo\n requirement: &amp;72174990 !ruby/object:Gem::Requirement\n none: false\n requirements:\n - - ! '&gt;='\n - !ruby/object:Gem::Version\n version: 0.5.3\n type: :runtime\n prerelease: false\n version_requirements: *72174990",
    "url": "/2011/9/30/2011-09-30-post/"
  },
  {
    "id": "2011-10-03-post",
    "title": "Scaleの関数プログラミングのアプローチについて(2)",
    "date": "2011-10-03",
    "categories": [
      "Scala"
    ],
    "file_path": "_posts/2011-10-03-post.md",
    "content": "Scalaの章を読了した。\nしかしこの本だけでは、Scalaがどうやって破壊的操作を検出するか/あるいはしないのかについての全体像はわからなかった。\nわかったのは、varとvalがあり、valが破壊的操作を許さない変数を定義するためのもので、静的に破壊的操作を禁止するものだ。\nものによっては静的には検出できないので、その場合はランタイムで破壊的操作のエラー(例外)が出るというレベル。かなり浅い。\nそこで、次の本で調べ始めた。\n※ 後で知ったが、下のリンクで本の中身が公開されている。\n 紙の本でいうとChapter 2だ。\n First Steps to Scala\n Summary In this article, you'll follow twelve steps that are designed\n to help you understand and gain some basic skills in the Scala\n programming language.\nさっそく、O'REILLY Safari Bookshelfで上記「Programming in Scala」を本棚\nに登録し、まえがきにも、チュートリアルの章にも目もくれず、目次から一直線\nに「Chater 17のCollectionsの章」にジャンプした。\nそこから、「前のChapterで説明した…」とかのリンクを辿ること数回、次の文\n章に辿りついた。どうも各Collection型の操作ライブラリにはimmutableと\nmutableの二つのバージョンがあるようだ。ものによると、immutableバージョ\nンしか無い型もあるようだ。\n Page 47\n Step 10. Use Sets and Maps\n imperative styles, its collections libraries make a point to\n differentiate between mutable and immutable collection classes. For\n example, Arrays are always mutable, whereas Lists are always\n immutable. When it comes to Sets and Maps, Scala also provides\n mutable and immutable alternatives, but in a different way. For Sets\n and Maps, Scala models mutability in the class hierarchy.\n\nこれで概略が掴めた。プログラマがそのメソッドを完全にimmutableにしたけれ\nば、注意してimmutableな部品を選んでプログラミングする必要があるわけだ。\nまた、必要な部品郡は概ね足りているのだろう。\nただ、私が一番知りたいのは、immutableなコードの中にmutableなコードが混在し\nたことを検出できるかどうかだ、うっかり混在させることはよくあることだと\n思うからだ。できればコンパイル時に検出されるのが望ましい。\nもし、Actorモデルなどの並行性を構築したい場合、うっかり破壊的なコード\n(mutableなどコード)が混在してしまっては非常に原因を調べるのが難しいと考\nえられる。\nもうちょっと調査が必要。",
    "url": "/2011/10/3/2011-10-03-post/"
  },
  {
    "id": "2011-10-04-post",
    "title": "Sekka 0.9.3 リリース",
    "date": "2011-10-04",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-10-04-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.3をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nEmacsから接続するSekkaサーバを複数登録しておき、生きているサーバを自動的に使うようにしました。\n\nversion 0.9.3\n\nsekka.elに最大３つの接続先sekka-serverのURLを登録できるようにした。\n-- カスタマイズ変数 sekka-server-url、sekka-server-url-2、sekka-server-url-3の３つ。\n-- 第一サーバが落ちていたら、第二サーバ、第三サーバを順に試す。\n-- モードラインに接続中のsekka-serverのホスト名を常に表示する。\n これにより、ユーザが意識しなくても自宅で変換した時は自宅サーバーの\n sekka-serverを使い、オフラインで変換した時は、localhostの\n sekka-serverを使うという運用ができる。\n\n次の目標\n[Nendo]に新しい例外処理機能が付くのでそれを使って、テストを拡充する予定です。",
    "url": "/2011/10/4/2011-10-04-post/"
  },
  {
    "id": "2011-10-05-post",
    "title": "Scaleの関数プログラミングのアプローチについて(3)",
    "date": "2011-10-05",
    "categories": [
      "Scala"
    ],
    "file_path": "_posts/2011-10-05-post.md",
    "content": "しつこくScalaについて調べる。使うのはこの本。\n第７章で「Refactoring imperative-style code」というタイトルを見つけたのでその章をじっくり読む。\nvarを見つけてはvalを使うコードに変換し、副作用のあるコードを排除し、ループ変数を使ったコードからimmutableなコレクションと高階関数の組みあわせに書きかえていくという内容。\nただ、どこまでもやったらリファクタリング完了なのかは書いていない。どこまでもやったら副作用の無いコードになったのかを確認する術も書かれていない。\nやっぱりそんな仕組みは無いのかな。\n自分は、ずっとそこに拘っているけど、一般人はそこまで拘るものでは無いのかなと思えてきた。「現場のプログラミングの世界ではそこまで拘っても別のところのコストの下にかくれて誤差の範囲になるんだよ」というような声が聞こえてくるような気がした。\nしかーし、ここは気を取りなおして、副作用の無いコードと十分な件数のテストコードの安心感を体で知っている自分としては、とことん拘っていくつもりだ。\nScalaができていないなら[Nendo]が達成してやろうじゃないかというところだ。\nもしそれがいいものであったら、べつの言語に輸出すればいい。\n今回の調査ではScalaからは盗めなかったけど、[Nendo]は独自に考えてimmutable範囲チェックを実現してみたいと思う。",
    "url": "/2011/10/5/2011-10-05-post/"
  },
  {
    "id": "2011-10-06-post",
    "title": "Sekka 0.9.4 リリース",
    "date": "2011-10-06",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-10-06-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.4をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n緊急バグ修正リリースです。sekka.elに３つのsekka-serverを自動切替する機能を付けた時、どこにも接続できなくなるバグを埋め込んでました。\nその修正です。\nversion 0.9.4\n\nsekka.elが変数の初期化不良でsekka-serverに接続できないバグを修正した。\n 変数 current-sekka-server-url の初期化不良\n\n次の目標\n[Nendo]に新しい例外処理機能が付く予定なので、その機能を使ってテストを拡充する予定です。",
    "url": "/2011/10/6/2011-10-06-post/"
  },
  {
    "id": "2011-10-07-post",
    "title": "コードブロックに副作用が混在するかを検出できるかどうか",
    "date": "2011-10-07",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-10-07-post.md",
    "content": "先日のScalaの本からの流れで勝手に盛り上ってしまっている話題を前へ進めてみる。\nさて、[Nendo]にimmutableなコードブロックを保証するスペシャルフォームを追加したいと考えている。\nこんな感じ。もしコード中に破壊的操作を行うメソッドが混在していたら、例外を発生させる。\n(immutable S式)\n\nimmutableは[Nendo]の予約語で、引数に取ったS式はマクロ展開されたあと破壊的操作が無いかを検査される。\nランタイムではなくて、コンパイルフェーズでチェックができればベスト。\nこれができたら画期的だと思う。\nやりたい理由は、テスタビリティの確保だ。破壊的操作が無いコードはテストコードが非常に書きやすい。\n破壊的操作があるプログラムは、環境を用意するのも一苦労だ。\n以下の引用は、テスト環境を用意するのが大変という話を説明するのにもってこいのやつ。\nJoe Armstrong\n 「再利用性の欠如はオブジェクト指向言語から来るもので、関数型言語では\n 話が違います。オブジェクト指向言語の問題は、それが周りに引きずってい\n る暗黙の環境にあります。バナナが欲しかったのに、手に入れてみたら、バ\n ナナを握ったゴリラと、それにジャングルまでついてきたというようなもの\n なのです。」\nつまり、オブジェクト指向の方法ではテストデータや環境を準備するための依存を断ち切るのが非常に困難だということだ。\n話を戻して、破壊的操作のある/なしを切り分けることが本当にできるのか？というのは、今はできると思っておいたほうが楽しいので、しばらくはつっこまないで頂きたい(笑;)\n難しいと思っている理由は、いろいろあるんだけど、[Nendo]はRubyへのトランスレータとして実装しているので、ターゲットが生粋のオブジェクト指向言語だというところ。\nオブジェクト指向は、基本的にはオブジェクトに状態を持つパラダイムであり、オブジェクトの状態を変更しながらプログラムが走行させるのが基本だ。\nつまり、状態の破壊的操作が基本にあるということ。\nかたや、私がやりたいのはあるコードブロック内では非破壊的なメソッドだけを集めてプログラミングしたいという要求であり、Rubyを選んだ時点で矛盾があるような気もするが…\n(ただ、似たような状況に立っている言語のScalaがうまくやっているということわかったので少し楽観的だ)\n図で説明してみる。\n\nいくら書いても、具体的にどうやればできるという話が出てこないけれども、それはこれから考えるのだよ(笑)。\n最後の手段としては、人間が慎重に破壊的操作の無いメソッドを選び出してリストを作るということになるのだけど…\nブラックリストではなく、ホワイトリストになるのかな。\n因みに、ScalaではSet/Mapはひとつの親クラスからimmutable版とmutable版のそれぞれをtraitで継承して作りだしている。Listはimmutable版しかなくArrayはmutable版しかない。あとはプログラマが慎重に部品を選びなさいというような感じだと思う。(本を読んだだけのレベルだけど)\n[Nendo]はどうするか。これからじっくり考えます。\n\nコメント by shiro:\nコンパイル時にやるには、型情報があった方が圧倒的に楽ですね。生のSchemeの場合、そこから参照している手続きを全部追っかけていかねばならず、結局それはその場で一種の型情報をつけようとするのと同じですから。参照透明かどうかって情報だけ追えば良いので完全な型付けほど大変じゃないですが、外から引数で渡される関数なども追っかけることになるので、グローバルなプログラムの解析になりそうです (外から渡される関数引数に型情報をアノテートできるようにしていれば別ですが)。\nあと、immutableは「対象が変更不可」という形容詞だと思うので、変数やオブジェクトに対して使う形容詞であって、「式」に対して使うのは違和感があります。式に対して形容するならreferentially transparentが正確だと思いますが、長いので (pure ) とかかな? (no-side-effect ) はちょっとださいし。\n\nコメント by kiyoka:\nコメントありがとうございます。\nshiroさんのコメントを読むまで、外から渡される関数に思い至っていませんでした。そうか、それもありますね。\n参照透明かどうかをグローバルに解析しないといけないのは大変ですね。Rubyのライブラリクラスのメソッドが参照透明かどうかを自動で検査するのも難しいという問題もあります。\nやはり参照透明な関数や変数(というか定数)をリストアップするホワイトリスト方式が有力なのかもしれません。\nそれはある意味、型情報のアノテーションを手作業でやるということに相当するのかな。\nホワイトリストなので、必要な分だけをアノテーションすればいいので始めやすいですが、関数が増えるごとに手作業で追従しないといけないのが難点です。\n漏れが出ると便利さが半減するので…\n\nコメント by kiyoka:\nもうひとつ。immutableは形容詞ですね。(pure ) がかっこいいので実現できたらこれにするかもしれません。但し実現できたらの話ですが。 :)\nコメント by shiro:\nコンパイル時にやるには、型情報があった方が圧倒的に楽ですね。生のSchemeの場合、そこから参照している手続きを全部追っかけていかねばならず、結局それはその場で一種の型情報をつけようとするのと同じですから。参照透明かどうかって情報だけ追えば良いので完全な型付けほど大変じゃないですが、外から引数で渡される関数なども追っかけることになるので、グローバルなプログラムの解析になりそうです (外から渡される関数引数に型情報をアノテートできるようにしていれば別ですが)。\nあと、immutableは「対象が変更不可」という形容詞だと思うので、変数やオブジェクトに対して使う形容詞であって、「式」に対して使うのは違和感があります。式に対して形容するならreferentially transparentが正確だと思いますが、長いので (pure ) とかかな? (no-side-effect ) はちょっとださいし。\nコメント by kiyoka:\nコメントありがとうございます。\nshiroさんのコメントを読むまで、外から渡される関数に思い至っていませんでした。そうか、それもありますね。\n参照透明かどうかをグローバルに解析しないといけないのは大変ですね。Rubyのライブラリクラスのメソッドが参照透明かどうかを自動で検査するのも難しいという問題もあります。\nやはり参照透明な関数や変数(というか定数)をリストアップするホワイトリスト方式が有力なのかもしれません。\nそれはある意味、型情報のアノテーションを手作業でやるということに相当するのかな。\nホワイトリストなので、必要な分だけをアノテーションすればいいので始めやすいですが、関数が増えるごとに手作業で追従しないといけないのが難点です。\n漏れが出ると便利さが半減するので…",
    "url": "/2011/10/7/2011-10-07-post/"
  },
  {
    "id": "2011-10-08-post",
    "title": "楽譜をなぞるアニメーション付きJazzシリーズが楽しい",
    "date": "2011-10-08",
    "categories": [
      "Jazz"
    ],
    "file_path": "_posts/2011-10-08-post.md",
    "content": "速いフレーズで知られるチャーリー・パーカーとかジョン・コルトレーンとかは自分が聴き慣れている分楽しめる。\nやっぱりアニメーションで見てもフレーズが速いぞこの人たち。\nConfirmation by Charlie Parker\nGiant Steps by John Coltrane\nSo Whatも相当聴いたので楽しい。Bill EvansファンなのでMiles Davisよりもそっちに目がいきがちだけど。\nMiles Davisの少ない音数とColtraneの無駄に多い音数の対比を目で見るという楽しみも。\n So What by Miles Davis (Clean Audio)\n残念ながら、このシリーズはYoutubeへの登録数が少ないなぁ。もっと登録してくれー。",
    "url": "/2011/10/8/2011-10-08-post/"
  },
  {
    "id": "2011-10-09-post",
    "title": "Youtubeを使った編集無しのマッシュアップ遊び",
    "date": "2011-10-09",
    "categories": [
      "Youtube"
    ],
    "file_path": "_posts/2011-10-09-post.md",
    "content": "これすごい。\n Impossible Youtube duet: Miles Davis improvising on LCD Soundsystem\nと思ったけど、自分でもそこそこできるじゃん。ピッタリ合うわけじゃないないけど。\nSadeの歌い出しでMilesのVideoの再生ボタンを押すとそこそこ合う。\n Sade - Cherish The Day\n↑の再生が23秒くらいになったタイミングで↓の再生ボタンを押してみよう。\nMilesのほうのボリュームを大きくしたほうが、バランスが良いかも。\n Miles Davis - Louis Malle's Elevator To The Gallows Recording Session\nというか、このVideoでもそこそこできるじゃん。\nこれも歌い出し(43秒あたり)でMilesのVideoの再生ボタンを押してみてほしい。\n Sade (17/17) - Jezebel - YouTube\nJazzのインプロビゼーションというのはなんといいかげんなことよ。\nMilesのが映画音楽だからなんにでも合うのかな。",
    "url": "/2011/10/9/2011-10-09-post/"
  },
  {
    "id": "2011-10-15-post",
    "title": "Sekka 0.9.5 リリース",
    "date": "2011-10-15",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-10-15-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.5をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\n大きな変更点は、sekka.elのカスタマイズ変数のデフォルト設定変更です。\nこれまで、Ctrl-Jとスペースキーの両方で変換確定する操作をデフォルトで有効にしてきましたが、今回スペースキーでの変換確定を無効に戻しました。\nスペースキーで変換確定する操作はMS-IMEなどの一般的なIMEと操作感が同じになるため、良い面もありますが、Sekkaの最大の特徴である「モードレス」が失なわれるという大きな問題がありました。\n(スペースキーの挙動を止めるためにCtrl-Gを押して、日本語変換モードを抜ける必要がある)\nプログラミング中に日本語コメントや文章を入力する頻度が高くなるとモードレスでないとモード切替忘れによる入力ミスが出ます。\n数ヶ月使ってみて、やはりSekkaのアイデンティティはモードレスでないといけないと思い至りました。\n\n ↓Ctrl-Jを押す。\n\n変換モードがあっても許せる人なら、カスタマイズ変数でスペースキーでの変換を有効にしてもらう、もしくはSKKなどを使ってもらえればいいと思います。:(\nversion 0.9.5\n\nsekka.el: url-host関数が呼び出せず、mode-lineのSekka[]の表示が消えるバグを修正した。\n (require 'url-parse)が必要だった。\nsekka.el: sekka-kakutei-with-spacekey のデフォルト値を nil に戻した。\nsekka.el: sekka-muhenkan-key のデフォルト値をnilに設定した。\n また、指定したキーをkeymapに設定する必要があるので、カスタマイズ変数でなくした。\n 例えば、.emacsで(setq sekka-muhenkan-key \"q\") する必要がある。\nsekka-serverの辞書追加/既に登録済みのメッセージをシンプルなものに変更した。\n\n次の目標\n[Nendo]に新しい例外処理機能を付けている最中です、その機能を使って例外まわりのテストを拡充する予定です。",
    "url": "/2011/10/15/2011-10-15-post/"
  },
  {
    "id": "2011-10-26-post",
    "title": "Nendo 0.5.4 リリース",
    "date": "2011-10-26",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-10-26-post.md",
    "content": "[Nendo] 0.5.4をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの目玉\n例外をハンドリングできるようになりました。道具立てはguardとunwind-protectです。\nGaucheとAPIをなるべく似せて、Gaucheに慣れた人が新しく覚えることを少なくしました。 ([Nendo.ReferenceManual] のguardのあたり参照)\nテストフレームワークの nendo.testもgauche.test同様のAPIにしています。\nGaucheは独自の例外オブジェクトを持っていますが、Nendoでは例外オブジェクトとしてRubyのそのものを使うことになっているので、Rubyのオブジェクトをそのまま指定できるようにしました。\nRuntimeErrorやArgumentErrorやTimeout、Errno::ECONNREFUSEDなんかがそのまま書けます。\nGaucheとRubyの両方知っている人は、(exc.is_a? TypeError)のくだりなんかは非常に気持ち悪いかもですね。GaucheとRubyのどっちになりたいんだよと。\n例)\n(guard\n (exc (else (sprintf &quot;Type is *%s*&quot; (exc.class))))\n (error &quot;This is RuntimeError&quot;))\n\n→ \"Type is RuntimeError\"\n(guard\n (exc (else (sprintf &quot;Type is *%s*&quot; (exc.class))))\n (raise ArgumentError))\n\n→ \"Type is ArgumentError\"\n(guard\n (exc ((exc.is_a? RuntimeError)\n &quot;Type is *RuntimeError*&quot;)\n ((exc.is_a? TypeError)\n &quot;Type is *TypeError*&quot;))\n (+ (Array.new) 1)\n (error &quot;This is RuntimeError&quot;))\n\n→ \"Type is TypeError\"\nついでにguardを使って、unwind-protectも実装しました。\nNendoでも衛生的なマクロ(syntax-rules)をサポートしたおかげで、このようなマクロもあっという間に書けるようになりました。\nだいぶライブラリが積み上ってきた感があります。\n以下リリースノートです。\nversion 0.5.4\n\nguardフォームをサポートした。\nunwind-protectフォームをサポートした。\nraiseフォームの引数を可変長引数にした。\n Gauche 0.9.2の仕様に似せた。\nテストフレームワーク nendo.test に期待した例外が上がるかどうかテストする機能を追加した。\n Gauche 0.9.1に付属のgauche.testをポーティングし、(test-error )関数などを実現した。\nutil.listのテストケースにRuntimeErrorが発生するテストケースを追加した。\n Nendo 0.5.3まではコメントアウトしていたもの。\n\n次の目標\nもうそろそろNendoで実践的なWebサービスを作っていってもだいじょうぶかなと思い始めました。\nWebフレームワーク、ドキュメントStore(MongoDB)などと組み合わせて使う場合、どんなやりかたが良いのかを考えながらライブラリを拡張していきたと思います。\nそれから、副作用のあるコードブロックのチェック機能(pure S式)もぼちぼち考えていきます。こちらは優先度低いです。\nあっ、その前にリファクタリングする予定がありました。\nnendo.rbの行数がとんどもないことになっているので、ファイル分割します。\nそれからいろいろ手をつけていきます。",
    "url": "/2011/10/26/2011-10-26-post/"
  },
  {
    "id": "2011-10-28-post",
    "title": "Nendo 0.6.0 リリース",
    "date": "2011-10-28",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-10-28-post.md",
    "content": "[Nendo] 0.6.0をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの概要\nnendo.rbをファイル分割しただけで、挙動は0.5.4から変化ありません。\nファイル分割しただけですが、ソースコード管理上は大きな変化であるということ、機能的に安定していることの二つの理由から、マイナーバージョン番号を0.6.0にを上げました。\n以下リリースノートです。\nversion 0.6.0\n\nnendo.rbを機能ブロックごとに以下のファイルに分割した。\n ruby/types.rb\n ruby/reader.rb\n ruby/builtin_functions.rb\n ruby/evaluator.rb\n ruby/printer.rb\n ruby/core.rb\n ruby/out_of_module.rb\n\n次の目標\nversion 0.5.4の時から変化なしです。\n参考 ([kiyoka.2011_10_26] Nendo Nendo 0.5.4 リリース)",
    "url": "/2011/10/28/2011-10-28-post/"
  },
  {
    "id": "2011-11-03-post",
    "title": "MongoDB: The Definitive Guide",
    "date": "2011-11-03",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2011-11-03-post.md",
    "content": "この本いいよ。\n第二版が出るらしいのだけど、待てないので第一版を買った。\n当初WebブラウザでSafari Books Online上の電子書籍を読んでいたのだけど、疲れるので紙の書籍にした。電子書籍リーダー持ってないし。\nMongoDBを本格的に使おうと思ってこの本にした。本格的に使うなら、最初からこの本を読み通しておくべきだろうと。\nMongoDBのコミッター(10genのエンジニア)も著者に入っているので、なぜこういう設計になっているのかというところも説明してくれている。\n実際にサーバー側の内部を知っているものでないと、このような解説はできないだろう。\nMongoDBサーバーの設計ポリシーや実装上のトレードオフを最初から理解しておくことは重要だと思う。結果、MongoDBの適用範囲を間違えなくて済む。\nトレードオフがわからないままだと、「ここは設計上律速するはずなので、部分的にmemcaced使っとこか」というようなアプリケーションのトレードオフの判断ができない。\nMySQLを本格的に使う時に、この本を2回通しで読んだ記憶があるが、1回目はとにかく読む。2回目は使い倒しながら読んだ。\n今回のMongoDBもそこまでできるかわからないが、MongoDBをヘビーに使う気でいるので、じっくり読むぞ。\nMongoDBの試用実験も始めているので、その経過もブログに書く予定。",
    "url": "/2011/11/3/2011-11-03-post/"
  },
  {
    "id": "2011-11-05-post",
    "title": "MongoDB試用開始",
    "date": "2011-11-05",
    "categories": [
      "MongoDB"
    ],
    "file_path": "_posts/2011-11-05-post.md",
    "content": "MongoDBをさわりはじめた。versionは現時点の最新の version 2.0.1 。\nメモリがいくらあっても足りない。4GByte RAMのサーバマシンで3.8GByteまで使っている。\nもちろん他にもいろいろ走っているので、2GByteほどswapしている。\nまず、1GByte程度のapacheログをmongoimportできるJSON形式にしてimportした。\nmongoimport用の変換内容は時刻部分をDate型に、転送サイズを数値型に変換した。それ以外は文字列のまま。\nmongoimportで投入し、リクエスト時刻フィールドにIndexを張ったらDBサイズが5GByteになった。\nうげー、でかいよ。\nその後、リクエスト時刻部分から時分秒を00:00:00に切り落としたDate型をもうひとつ追加したら、DBサイズがまた肥大した。\nDISKもよく食う。\n結局次のようなドキュメントの構造になった。\nIndexはtimestampとurlに張って、14GByteのDBサイズに！\n $ mongo --host black sumibi\nMongoDB shell version: 2.0.1\nconnecting to: black:27017/sumibi\n&gt; db.apachelog.findOne()\n{\n &quot;_id&quot; : ObjectId(&quot;4eaf66c734168d18eb210c4e&quot;),\n &quot;client_id&quot; : &quot;-&quot;,\n &quot;hostname&quot; : &quot;111.111.111.111&quot;,\n &quot;referer&quot; : &quot;-&quot;,\n &quot;req&quot; : {\n &quot;method&quot; : &quot;GET&quot;,\n &quot;url&quot; : &quot;/sumibi/Sumibi_stable.wsdl&quot;\n },\n &quot;request&quot; : &quot;GET /sumibi/Sumibi_stable.wsdl HTTP/1.0&quot;,\n &quot;result_code&quot; : &quot;200&quot;,\n &quot;tfrsize&quot; : 6940,\n &quot;timestamp&quot; : ISODate(&quot;2011-10-08T21:56:22Z&quot;),\n &quot;timestampDaily&quot; : ISODate(&quot;2011-10-08T15:00:00Z&quot;),\n &quot;user_agent&quot; : &quot;-&quot;,\n &quot;username&quot; : &quot;-&quot;\n}\n&gt; db.apachelog.count();\n6072350\n\n※ hostname部分はblog用にマスクしてあります。\nそれにしてもMongoDBのshellがJavaScriptなのが便利だなーと思ったのも束の間、すぐにJavaScriptの非力さが気になりはじめた。\nPrototypejsを使いたくなるほどのプレーンさだ。でも、mongo shellには載らないだろうな。うーん。なんとかならんかな。\n久々にこんなプレーンなfor文を書いたよ。半年ぶりくらいかなー。\n for ( i = 0 ; i &lt; a.length ; i++ ) {\n ...\n}\n\nPrototypejsを使えば、mapやeachなんかを使って書くのでループ変数を使ったコーディングは懐しささえ感じる。\nまだ使い始めたばかりなので、癖はわからないが、いろいろ負荷の高い処理をやらせたりMapReduceをやったりして数日使ってみようと思う。\n※ ちなみに個人的な学習用リポジトリはkiyoka/learn-mongodb - GitHubで公開しているので、クエリのサンプルとか見れますよ。\n\nコメント by kiyoka:\n自分でコメントします。\nなんかメモリが足りないという発想がMongoDBに合っていない気がする。\nデータベースのサイズに対してメモリが足りないのであればマシンを増やして分散するのが筋かなー。\nもうちょっと実験が進んだら、AWSの時間貸しインスタンスを借りるのがいいのかな。",
    "url": "/2011/11/5/2011-11-05-post/"
  },
  {
    "id": "2011-11-06-post",
    "title": "Nendo 0.6.1 リリース",
    "date": "2011-11-06",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2011-11-06-post.md",
    "content": "[Nendo] 0.6.1をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの概要\n例外関連のフォームのバグ修正と、シンタックスチェックの不備を修正しました。\n以下リリースノートです。\nversion 0.6.1\n\nバグ修正:\n-- guardのコンディション比較にelseを書かない場合でも、全ての例外が捕捉されてしまうバグを修正した。\n 以下のコードはTypeErrorが発生するが、それがguardの上位にraiseされないバグ。\n\n (guard (exc (exc.is_a? (print &quot;*RuntimeError*&quot;)))\n (+ (Array.new) 1.1))\n\n-- letフォームのシンタックスチェックが抜けていたのを修正した。\n 例えば、正しいlet1フォームのlet1をletに書き換えと、improper listというエラーになる。\n-- let1フォームのシンタックスチェックが抜けていたのを修正した。\n 以下のコードが、生成後のRubyコードでSyntaxError例外が発生していた。\n(let1 ((a 1)) (print 1))\n\n-- #/正規表現/ を含むS式に#?=を付けると不正なシンタックスのRubyコードが生成される\n 以下のコードがSyntaxErrorになる。\n #?=(rxmatch #/a-z/ \"abc\")\n #正規表現/ の外部表現の出力に間違いがあったのが原因。\n次の目標\nversion 0.5.4の時から変化なしです。\n参考 ([kiyoka.2011_10_26] Nendo Nendo 0.5.4 リリース)",
    "url": "/2011/11/6/2011-11-06-post/"
  },
  {
    "id": "2011-11-08-post",
    "title": "Sekka 0.9.6 リリース",
    "date": "2011-11-08",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2011-11-08-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.6をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nリリースの概要\n耐障害性を向上しました。\nsekka-serverに関連するバックエンドサービスの障害を検知するようになりました。\n公開辞書を自宅サーバからクラウドサービスに引越ししました。\n以下リリースノートです。\nversion 0.9.6\n\ngemの依存規則で、Nendoの必須バージョンを0.6.1に限定した。\nsekka-serverのエラー処理を追加した。\n-- memcachedがダウンしている状況をクライアントに報せるようにした。\n-- Redis-serverがダウンしている状況をクライアントに報せるようにした。\nテストスイートにmemcachedとRedis serverへの接続エラーの例外発生ケースを追加した。\n公開辞書の提供サイトをsumibi.orgから、DropBoxに変更した。(ハードウェア障害に強いサイトへ)\n 将来 URLの変更が効くように、github上の以下のファイルにダウンロードURL\n を記載する方式にした。(自前リダイレクト方式)\n\nhttps://github.com/kiyoka/sekka/blob/master/public_dict/0.9.2/SEKKA-JISYO.SMALL.url\n\n次の目標\n特にありません。\nEmacs 24で動かした時の非互換が見つかれば対応します。今のところEmacs 24-pretest版でも動いています。",
    "url": "/2011/11/8/2011-11-08-post/"
  },
  {
    "id": "2012-01-01-post",
    "title": "2012年の抱負",
    "date": "2012-01-01",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2012-01-01-post.md",
    "content": "去年も抱負を書いているようなので今年も書くとしよう。\n今年は仕事内容が請負開発から自社商品開発に変わったので新しいことができそうだ。\nプライベートでもいろいろやりたいことがあるが、欲張らず自分のペースで進んでいけたらと思う。\n今年のテーマは公私ともにクラウドになりそう。\n去年末は自宅サーバ全壊をきっかけにふっきれて全面クラウド依存環境に突入。同時に仕事も心機一転、新しい部署でクラウドに関連した(どっぷりつかった？)仕事をやらせてもらうことになった。\n\n餌はたくさんもらったが慣れない環境でなのでいろいろ勉強しながらやっていこう。\nまだ家庭環境方面でアクセル全開とはいかないので、70%くらい踏んだ感じでいこう。(去年は50%くらいだったと思う)\n脳やコンピュータリソースをフルに回して(時には金で時間を買うなどして)時間効率を上げる工夫が必要かなー。\n参考: [kiyoka.2011_01_09] Life 2011年の抱負",
    "url": "/2012/1/1/2012-01-01-post/"
  },
  {
    "id": "2012-01-02-post",
    "title": "「Amazon EC2」と「さくらのクラウド」の使いわけ",
    "date": "2012-01-02",
    "categories": [
      "Cloud"
    ],
    "file_path": "_posts/2012-01-02-post.md",
    "content": "正月休みを利用して、Amazon EC2で遊んでみた。\n去年の11月ごろ、自宅サーバーが故障する直前までMongoDBを試していたが、クラウド上に復旧するのに時間が空いてしまって今になってしまった。\n「Amazon EC2」と「さくらのクラウド」の両方を使っているが、その使いわけがわかってきたのでエントリを書いておこう。\n自分の同じような使いかたをしている人はいないかなとググッてみたが、自分ほどガチで使っている話題はなかったので、書いとく価値はあるかな…\n伸び縮みのメリット(EC2)\n[Sumibi.org]の10MレコードオーダーのapacheログをMapReduceで集計した。\n後でMongoDBのデータベースが30GByteくらいに膨れあがることに気がついたのでAWSにしておいた良かった。\nWiki(oldtype.sumibi.orgドメイン)のapacheログもmongoimportすると最終的にはMongoDBのデータベースサイズが50G Byteくらい消費した。\n予想を越えるDISK消費だったのでMongoDB用に 80G ByteのEBSを追加した。\napacheログからmongoimportできるjsonファイルに変換するのに大量のCPUリソースが欲しかったので、EC2のインスタンスを「ラージ インスタンス(64bit)」から「ハイ CPU エクストララージ インスタンス(64bitの8コア)」に変更して\"make -j 6\"で処理した。\n8時間かかっても終わらなかった処理が2時間ちょうどで終わった。\n※ \"make -j 8\"にすると、Emacsでの編集作業でさえひっかかるため、\"make -j 6\"にした。\n急にDISKを大量に使いたいとか、CPUを大量に使いたいという時にはそのの柔軟性のおかげで、EC2の便利さが体感できた。\nプライベートであっても、処理を待っている間に別のハックをすると裏で走っている処理が気になる。\n短時間で処理が終わって頭を次のタスクに切り替えれるのはありがたい。\n時間を金で買うという感じだ。\nタスクの切れめが縁の切れめ(EC2)\nいざ集計を終えてみると、EC2は不要になった。\n多分、次に重い処理をするまでは使わない。\nbit単価が高い(EC2)\n「ラージ インスタンス(64bit)」が時間 30円くらいで、「ハイ CPU エクストララージ インスタンス(64bitの8コア)」が時間70円くらい。\n「マイクロ インスタンス(64bit)」は時間 1.3円くらいで安いのだけど、はっきりいって何もできないくらい遅い。\nマイクロではEmacsでコピーアンドペーストをするだけで、5秒くらいかかる。文章の編集さえできないので使う意味は無い。\n「スタンダード」というランクがあれば良いのだけど、32bit環境にしか無い。普段64bitのソフトウェアを使いたいので、それも無し。\n結局「さくらのクラウド」が常用環境\n「さくらのクラウド」にSumibi.orgサイトを起動しっぱなしにしているので、普段はそちらを使えばいいという結論になった。\nちなみに、本エントリ時点の「さくらのクラウド」のサイズはRAM 3GByte / HDD 80GByte / 月額約 5000円。\nMySql(常時300 MByte消費)、Apache、sekka-server(tokyocabient使用)、Kahua(worker process10個)という構成。\nEmacsをX forwarding over sshで手元のMacBook Proに転送している。(twitter-modeとw3mも使う。特に問題ない速度)\n本エントリも、「さくらのクラウド」上のEmacsとsekka-serverで書いている。\nまとめ\n\nAmazon EC2は必要な時だけ使う。\n常用環境は、費用対効果を考えると「さくらのクラウド」になる。\n\n参考:\n [kiyoka.2011_12_28]Cloud 自宅サーバが全壊したので「さくらのクラウド」に[Sumibi.org]環境を再構築した",
    "url": "/2012/1/2/2012-01-02-post/"
  },
  {
    "id": "2012-01-03-post",
    "title": "MongoDB: The Definitive Guide 読了",
    "date": "2012-01-03",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2012-01-03-post.md",
    "content": "やっと読み終わった。\n過去のエントリを見ると11月ごろから読んでいたのがわかる。\n [kiyoka.2011_11_03]本MongoDB MongoDB: The Definitive Guide\n英語の書籍にしては意外と早く読み終わった。\n電子書籍ではなく、紙の書籍を買ったので通勤時間なんかを使えたのが良かったかも。\nまだapachelogの集計を試しただけで、本格的なアプリケーションは書いていない。\nshardingもreplicaもやっていないので、本を読んだだけで終わってしまった。\n [kiyoka.2011_11_05]MongoDB MongoDB試用開始\n新しいプライベートプロジェクトに使おうと思って読み初めたのだけど、まだ構想がまとまらないので、ここでは一旦置いておく。\nあまりに構想(妄想)が壮大すぎてスタートできなくなってきており、もしかしたらこのまま妄想が発散してやらないかも…(汗;;)\n一方、仕事で使うかどうかだけど、きっと使わないだろうなー。多分。\nMongoDBの適用範囲がわかってきたので、わかった上で使わないという判断ができそうだ。\nログ集計だけならHadoop(またはEMR)なので、よほど巨大なデータを検索したいという要件が無いと使わないし、EC2でもなんでも使ってマシンをたくさん用意してスケールアウトするとなると予算が…という感じになりそう。\nでも、RAMにデータが乗ってないと一般的いは高速化しないので、結局ありという結論に戻ってくるのかも。\n今後の課題として置いておこう。\nMongoDBの個人的な学習用リポジトリはGitHubで公開しているのでMongoDBでMapReduceをやってみたい人は参考にされたし。\n kiyoka/learn-mongodb -GitHub",
    "url": "/2012/1/3/2012-01-03-post/"
  },
  {
    "id": "2012-01-04-post",
    "title": "]を公開サービスにするという思考実験(サービスイメージ)",
    "date": "2012-01-04",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-01-04-post.md",
    "content": "ソフトウェアを試してみようと思った時、インストールの容易さが最初に心理的障壁になる。\n特にインストールがそうとう難しい場合は心理的障壁は上がる。\nsekka-serverはRuby 1.9.xとTokyo Cabinetがインストールされていればわりとインストールは簡単にした積もりだけど、まだまだ苦労する人もいる。\nDebian化という話もあって、それも良いことではあるが(@uwabamiさんすみません、ちょっと停滞しています… 気長に待っていてください)\nもし2012年現在の技術で、sekka-serverを公開サーバにするならどんな風にするの良いのか考えてみた。\n誰が得するのか全くわからないエントリだが、まあ書いてみる。\nEmacsのサーバー側のサービスをクラウド化するなんていう話を書く人間は自分しかいないのでニッチに違いない(笑)\n[Sekka]の比較対象としてSKKからの乗りかえを狙って作ったので、SKKとする。\nSekkaの接続アカウント\n2010年くらいならSekka専用のアカウントをsign upページで取得してもらうのが普通だっただろう。\nしかし、2012年ならFacebookかTwitterアカウントでログインしてもらうのが良いだろう。\nWebブラウザでFacebookかTwitterアカウントで管理画面にログインすると、WebAPIの接続トークンが表示されているという方式だ。\nちょっと前のtwittering-modeがその方式を取っていたと思う。(最近はWebブラウザは不要になったと思う)\nsekka.elのインストール(案1)\nsekka.elは手でインストールする必要がある。\nユーザーが.emassをどんなふうに管理しているかはわからないので、そうせざると得ないかな？\nsekka.elのインストール(案2)\n.emacsにWebからsekka.elを取得して直接loadするemacsを書いてもらう。\n※ これは、クライアントがオンラインでないといけないのと、sekka.elを他人が差しかえてしまうというセキュリティ上の懸念がある。\nどうだろう。\n必ずオンラインでないといけないという制約があるが、そういう環境は少しづつ増えてきていると思う。\n後日、サービス提供の裏側を書いてみたいと思う。",
    "url": "/2012/1/4/2012-01-04-post/"
  },
  {
    "id": "2012-01-06-post",
    "title": "]を公開サービスにするという思考実験(サービスの裏側)",
    "date": "2012-01-06",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-01-06-post.md",
    "content": "先日の、「 [kiyoka.2012_01_04]Sekka [Sekka]を公開サービスにするという思考実験(サービスイメージ)」というエントリの続き。\n今回はsekka-serverをホスティングする側のアーキテクチャをどうするかを書いてみたいと思う。\nデータベース(案1)\nRedisで1台のサーバでスループットの総量を確保する。\n最初はメモリを1GByte程度用意しておけば、数人程度のユーザ辞書は入るだろう。\nスケールしたくなった時は、Redis clusterを使う。\nデータベース(案2)\nAmazon SimpleDBで最大容量と最大処理量を確保する。\n処理量とユーザー辞書容量はSimpleDB側で自動的にスケールする。30から50ユーザーくらいは収容できるのではないかな？\n課題は、SimpleDBには1024byte以上のvalueが保存できないという制限があるので、sekka-serverを変更しないといけないことだろう。\nRack\nsekka-serverはRackで動いてるが、こちらもスケールする必要がある。\n一番CPUリソースを使う処理は曖昧文字列検索なので、そこがスケールアウトする必要があるだろう。\nsekka-serverのサーバ台数を増やす、またはCPUコアが多いマシンにスケールアップして対応する。\nユーザー用管理ページ\nフレームワークはRailsかSinatra データベースは何らかのRDBで良いのではないかと思う。\n機能は辞書の登録状況と、登録状況のリセットのみ。\nユーザー語彙のマスターデータはユーザーのローカルマシンに ~/.sekka-jisyoとして持っているので、問題があればホスティング側は何度でもリセットすることもできる。\nここまで書いてみて、大袈裟かなー、そこまで使われるかなー、というのが正直な感想。\nそこまでしなくても、公開サイトは自分のローカルにsekka-serverをインストールする前にデモ的に使うためのものにするというのが落としどころか。\nそれなら、何の認証も無い状態でsekka-serverのデモをWebAPIで公開するというのが実は落としどころかな。\nインストールが面倒という問題は、sekka-server専用のVirtualBox仮想マシンイメージで公開するというのがいいのかも…\n思考実験をしてみると、スケールするにはまだ考慮が足りないという事実と、実際にスケールさせるためにはかなりランニングコストがかかりそうという事実がわかってくる。\nなかなか難しい。",
    "url": "/2012/1/6/2012-01-06-post/"
  },
  {
    "id": "2012-01-24-post",
    "title": "Kahuaのメモリリークの調査と対策",
    "date": "2012-01-24",
    "categories": [
      "Cloud"
    ],
    "file_path": "_posts/2012-01-24-post.md",
    "content": "[Sumibi.org]を「さくらのクラウド」に引越した後もKahuaのメモリリーク問題が解決していなかった。\n急遽RAM容量の大きなサーバインスタンスに変更して運用回避していたが、このまま無意味なコストの垂れ流しを止めるべく調査した。\nやっと解決したので調査結果を書いておこうと思う。\nこのまま放置するとコスト削減額はなんと月額4000円にもなるので、ちょいと見過ごすわけにはいかないのである。\n概要\n[Sumibi.org]のサイトは1台のサーバインスタンスで構成されており、[Sumibi.org]の日本語変換サービスと、Wikiシステムの[OldType]が同居している。\nメモリリーク問題は[OldType]のほうにあり、使っているKahuaフレームワークのworkerのプロセスが膨張していくというのが問題だった。\nKahuaのworkerがメモリを圧迫し、結果的に[Sumibi.org]の変換レスポンスが重くなるという現象が発生していた。\n膨張のペース\n[OldType]を1日程度放置すると、Kahuaのworkerプロセスが1個につき1.2GByteまで膨張する。\n常時2個のworkerを起動する設定にしていたため、3GByteのRAMでは足りず、swapを2G Byteほど侵食し、[OldType]のサイトがエラーを返すようになる。\nGoogleやYahooのクローラが来て、サイトのページを一巡するとworkerは1.2GByteあたりになる。なぜか1.2GByte以上には膨張しないようだ。\n回避策\nさくらのクラウドの料金シミュレーション ページより\n\n原因究明までの間、「さくらのクラウド」のインスタンスを3GByteから6GByteにして20日間ほど回避した。\n6GByteならリークしていても問題なく運用できていた。ランニングコストを除いては問題ない(笑)\nしかし、お金さえ払えば、問題を先送りして普通に運用できるのはクラウドサービスの良いところである。\n対策\nworkerを1時間に1回リスタートするスクリプトを動かして対応した。\nこのスクリプトはOT_SITEにサイトバンドルのパスさえ設定すれば、どんなKahuaアプリでも使えるはず。\n hourly restarter for Kahua workers(restarter.sh)\n結果\nRAM 3GByteでも約1GByteの余裕を持って運用できるようになった。\n青い線はリザルトコード。一番下側に張りついている線は、\"200 OK\"のリクエスト。\n\"404 Not Found\"が大量に出るのは、Kahuaフレームワークが非ブラウザが動的生成されたURLを叩いた時だ、自動的に404にしてくれているようだ。頼もしい。\n\nrestarter.shをリスタートすると、freeメモリのグラフがキザギザになる。うまくいっているようだ。\nrestarter.shを一定期間止めておいて、再度開始する実験をしたが、freeエリアがいっきに復活している。うまくいっているようだ。\n\nまとめ\n[OldType]もしくはKahuaのworkerプロセスが膨張するが、workerプロセスの定期的restartをかければ問題なく運用できる。\nなぜworkerがそんなにメモリを消費するのかという原因追求はしていない。\n対処療法的ではあるが対策し、無用なランニングコストを抑えることができた。\n\nコメント by shiro:\nworkerプロセスは継続をたくさんハッシュテーブルに登録してますが、それのexpireがうまくいってないのかな?\nworkerが掴んでる継続の一覧をモニタできるようにしてみるといいかも。ちょっと見てみます。\n\nコメント by kiyoka:\n通常運用で、workerが膨張するのでshiroさんの予想は当たっているかもしれません。\nOldTypeはコンテンツページの１行毎に継続が生成されているので、開放されないとするとすぐにworkerが肥大しそうですね。\n以前shiroさんもchatonで同様の現象について、他に同じような現象を見た人はいませんかというような書き込みをされていたと思いますが、まさにこれがそうかも。\n同じ原因だといいですね。よろしくお願いします。\nコメント by shiro:\nworkerプロセスは継続をたくさんハッシュテーブルに登録してますが、それのexpireがうまくいってないのかな?\nworkerが掴んでる継続の一覧をモニタできるようにしてみるといいかも。ちょっと見てみます。",
    "url": "/2012/1/24/2012-01-24-post/"
  },
  {
    "id": "2012-01-25-post",
    "title": "ZFSを先延ばしにしていたら、いつのまにか不要になっていた件",
    "date": "2012-01-25",
    "categories": [
      "Cloud"
    ],
    "file_path": "_posts/2012-01-25-post.md",
    "content": "ZFSの開発の歴史や、Software Designの記事などを読んで ZFSを使いたいなぁと常々思っていた。\n 今は読めない(デッドリンク)。残念。Oracleが隠しちゃった？\n Solaris 10ファイルシステムZFS誕生エピソード『心を解き放て！』\nこちらは読める\n自分はFreeBSDではなく使い慣れたLinuxで使いたいと思っていて、待っていたがZFSのライセンスの関係でなかなかLinuxに取り込まれなかった。\n時は流れて、「さくらのクラウド」を使い初めたら、ストレージがZFSだということを知った。\n The Cloud Storage Sun ZFS Storage Applianceがクラウドベンダーに次々と採用される理由とは？｜日本オラクル\n IIJ（インターネット・イニシアチブ）、さくらインターネット、ITコアなど\n のクラウドベンダーや、「ニコニコ動画」を運営するドワンゴのようなSNS事\n 業者が、次々とSun ZFS Storage Applianceを採用している。\nZFSにしたかったのは、新しくHDDを買ってきたら簡単に既存のパーティションサイズを拡張できそうだというのが一番の理由だった。\n今は自分でサーバハードウェア資源を持たないので不要になった。\nクラウドのストレージを使えば、追加ストレージデバイスのサイズ指定も自由自在なのである。\nぼんやりしていると、すぐに下のレイヤーが整備されてくるいい時代なのであるが、仕事としては下のレイヤーは失われていっているわけで、うかうかしてられんなぁとも思うのであった。\n\nコメント by Pranoy:\nGreat comomn sense here. Wish I'd thought of that.",
    "url": "/2012/1/25/2012-01-25-post/"
  },
  {
    "id": "2012-01-27-post",
    "title": "そろそろ]のDebian化にとりかかろう",
    "date": "2012-01-27",
    "categories": [
      "Debian"
    ],
    "file_path": "_posts/2012-01-27-post.md",
    "content": "去年の11月くらいから自宅サーバが全壊したり、さくらのクラウドに[Sumibi.org]環境を復元したりしているうちに、もう３ヶ月も経ってしまった。\nそろそろ、落ちついたし懸案だった[Nendo]をDebian化しよう。\nDebian化の話は、KOF2011：関西オープンソース2011で佐々木 洋平さん(twitterアカウント@uwabamiさん)に[Sekka]をDebian化してみませんかという提案をもらったことから始まっている。\nそういえば、佐々木さんは今月のSDでDebianの記事を書いていらっしゃるのであった。\nヘビーユーザの佐々木さんのDebain愛を感じる。Debianの良さを再認識する良い記事です。\n話は戻って、[Sekka]は[Nendo]やfuzzy-string-matchなど、いろんなソフトウェアに依存しているので、まずは[Nendo]から順番に攻めていこうと考えている。\nDebianはもう１０年以上も使ってきたが、Debian標準のrubyはほとんど使ったことが無く、いつもソースからrubyをビルドしていた。\ndeb版のgemsがどういう位置付けなのかわからない状態なので、そのあたりから調べてみるつもり。\n以下、KOF2011：関西オープンソース2011の会場で @uwabamiさんに[Sekka]をDebian化する上で問題になりそうな部分を洗い出ししてもらった時のメモを公開しておきます。\n誰かの役に立ては本望。非公開にしててももったいないないので。\n(佐々木さん、当日はありがとうございました、かなり時間経っていますが…すみません)\n去年中にDebian化できていればUbuntuに入っていくかもというタイムスケジュールだったけれども、また次を狙います。まあ焦らずにいきます。\ndeb化についての基本\n基本はrubygems.orgにアップロードされたgemをdeb化する。\nnendoの問題(v0.6.1)\n\ngemにRakefileが含まれていない\nrake testでテストが通るほうがよい。Debian化の提案がスムースに通りやすい。\n\nfuzzy-string-matchの問題(v0.9.1)\n\ngemにRakefileが含まれていない\nrake testで走る RSpecのテストスイートがamatchに依存している。\n配布したgemがamatchに依存しないように、rake testを修正したほうがいい。\ngitの開発リポジトリで rake bench でamatchとのベンチマーク比較が走ればよい。\n\nsekkaの問題(v0.9.6)\n\ngemにRakefileが含まれていない\nrake testでテストが通るほうがよい。Debian化の提案がスムースに通りやすい。\nsekka-serverがDebian 6.0上のruby 1.9.xで動かない。\nsekkaのような非標準ライブラリは vendor配下に置かれる。\n例えば、sekkaconfig.rbは以下に置かれる。\n /usr/lib/ruby/vendor_ruby/sekkaconfig.rb\nそのパスをrequireするコードは、\n\nrequrie 'rbconfig'\n\nと\nRbConfig::CONFIG* 'libdir' *\nRbConfig::CONFIG* 'vendor_dir' *\n\nを使って環境に依存しないようにすること。\n\n辞書データのインストール方法には工夫が必要。\n Webマイニングしたデータを含むので、パッケージインストールしてから辞書を取りに行くなど工夫が必要。",
    "url": "/2012/1/27/2012-01-27-post/"
  },
  {
    "id": "2012-02-01-post",
    "title": "gemsのDebian化ツールについて",
    "date": "2012-02-01",
    "categories": [
      "Debian"
    ],
    "file_path": "_posts/2012-02-01-post.md",
    "content": "[Nendo]のgemのDebian化を簡単にできるツールからスタートしようとして、Google検索しているとこんな記事が出きて、Debian上の行く末が心配になったりした。\n多分杞憂に終わりそうだけど…\n Rails Hub情報局: DebianのRubyパッケージメンテナ辞任で騒動に\nこちらがオリジナルのブログポストです。大量のコメントが付いています。\n Lucas Nussbaum’s Blog » Blog Archive » Giving up on Ruby packaging\nLucasさんの開発されたgem2debを使おうとしているので、なんとなくその後を把握しときたくなるというのが人情というもの。\ngem2debは今でも使えるのかとかも気になるし…\nと思ってLucasさんのいくつかのブログ記事を見ていると、gem2debはメンテナンスされていることがわかった。とりあえずそれで進もう。\n Lucas Nussbaum’s Blog » Blog Archive » Debconf\n Lucas Nussbaum’s Blog » Blog Archive » Re: Ubuntu vs Ruby\nGithub上のリポジトリもその後機能改善されている。\nが、なぜかgem2debの最新版がrubygems.orgに上がっていないというオチもあったり…(笑)\ngithubからスナップショットを取ってくれとな。\n https://github.com/ln/gem2deb\nというわけで、安心して\n「gem2debを使いながらDebianパッケージ化してみてgemの作りかたを調整」\nという手順を繰り返せそう。\nまずは、[Nendo]をrubygems-testに対応してからかな。",
    "url": "/2012/2/1/2012-02-01-post/"
  },
  {
    "id": "2012-02-10-post",
    "title": "Nendo 0.6.2 リリース",
    "date": "2012-02-10",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2012-02-10-post.md",
    "content": "[Nendo] 0.6.2をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの概要\ngem単体でテストが走る rubygems-test への対応が中心です。\nこれまで、Nendoはgitリポジトリ上でしたテストが走りませんでした。\nこれからは、\n$ gem install rubygems-test\n$ gem test nendo\n\nでテストが走ります。\n 参考: Gem Testers\n以下リリースノートです。\nversion 0.6.2\n\nSupported testable gem\n Please install rubygems-test and \"gem test\".\nModified Rakefile to build the debian package.\n to invoke rspec with \"ruby which rspec ...\" instead of \"rspec ...\"\nChanged dependency rules of gemspec.\n\n次の目標\n[Nendo]については今のところ目標はありません。\n使いながら足りないものから機能追加していきます。\n\nコメント by Lisa:\nYeah that's what I'm takling about baby--nice work!",
    "url": "/2012/2/10/2012-02-10-post/"
  },
  {
    "id": "2012-02-18-post",
    "title": "[fuzzy-string-match](http://github.com/kiyoka/fuzzy-string-match) 0.9.2 リリース",
    "date": "2012-02-18",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2012-02-18-post.md",
    "content": "二つの文字列同士を曖昧比較するライブラリ(gem)をリリースしました。\n\nlucene-3.0.2からJaro-Winkler distance アルゴリズムだけをポーティングしたものです。\n今回は、gemをC言語native版と、pure ruby版に分離しました。\nこれによって、JRubyからも簡単に使えるようになりました。\nリリースノート\n\n0.9.2\n\nSupported JRuby platform\n\nDivided into two gems.\n\nfuzzy-string-match ... native (RubyInline) version.\nfuzzy-string-match_pure ... pure ruby version\n\nDivided rspec files into several files.\n\nSupported testable gem\n Please install rubygems-test and \"gem test fuzzy-strint-match\".",
    "url": "/2012/2/18/2012-02-18-post/"
  },
  {
    "id": "2012-02-19-post",
    "title": "Nendo 0.6.3 リリース",
    "date": "2012-02-19",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2012-02-19-post.md",
    "content": "[Nendo] 0.6.3をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの概要\nnendoのライブラリ(.nnd .nndc)のインストール先パスを一段深くし、nendoディレクトリ配下に置くようにしました。\nDebianパッケージ化しようとして、0.6.2では、\n /usr/lib/ruby/vendor_ruby/init.nnd\n\nにインストールされてしまうことから、インストール先が間違っていることに気がつきました。\n本リリースでは、以下のパスに修正されます。\n /usr/lib/ruby/vendor_ruby/nendo/init.nnd\n\nload' とuse' マクロは上記の古いパスと新しいパスの両方を探す挙動にしたため、ユーザスクリプトは変更無しで動きます。\n以下リリースノートです。\nversion 0.6.3\n\nRemoved gem dependency for jeweler' andruby-prof'.\nChanged install path of library files written in nendo. like\n .nnd =&gt; nendo/.nnd\n debug/.nnd =&gt; nendo/debug/.nnd\n nendo/.nnd =&gt; nendo/nendo/.nnd\n rfc/.nnd =&gt; nendo/rfc/.nnd\n text/.nnd =&gt; nendo/text/.nnd\n util/.nnd =&gt; nendo/util/.nnd\n\n次の目標\nそろそろ、リファレンスマニュアルを 英語で ちゃんと書きたいと思っています。\nフォーマットは何がいいかなぁ。RubyなのにSphinxとかあり？",
    "url": "/2012/2/19/2012-02-19-post/"
  },
  {
    "id": "2012-02-20-post",
    "title": "nativeとpureの両方に対応したgemを作る方法",
    "date": "2012-02-20",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2012-02-20-post.md",
    "content": "[Sekka]の曖昧文字列マッチングを担っているkiyoka/fuzzy-string-matchというgemのpure ruby版を作った話を書く。\nJSONのgemがnativeとpureの両方をサポートしていたので参考したのだが、結果的にJSONよりもコンパクトに実現できたのでメモしておこう。\n[Sekka]がJRubyでは動かないのでkiyoka/fuzzy-string-matchのJRuby対応は自分は必要ないのだけど、GitHub上でJRuby用のforkが多かったので対応した。\n自分はDebianパッケージ化の準備がメインの作業なのでgemの依存関係を直すだけでいいのだが、気分がノッている間に作業した。こういう勢いは重要だ。\nDebianにはJRubyも入っているので、うまくいけばDebianのJRubyでも使えるのかな？\nJRuby対応といってもJavaで高速な編集距離ライブラリをコーディングするわけではなく、pure Ruby版も用意しただけ。\nGitHubでforkしてくれた方々はC言語に依存した部分を外してpure rubyのコードのみ残し、コメントに「JRubyで動かすため」と書いておられた。\n処理速度もpure rubyで十分と書いておられる方もいた。\n要望\nJRubyでは、gccを必要とするRubyInlineをインストールしてほしくない。\n- fuzzy-string-match_pure パッケージはRubyInlineに依存せず、pure Ruby版のみがインストールされてほしい。\n- fuzzy-string-match と fuzzy-string-match_pure の二つのパッケージを両方同時にインストールしても良いようにしたい。\n- fuzzy-string-match は nativeとpureの両方を同梱してあり、テスト用に動的に切り替えれるようにしたい。\n動的に切り替えるAPI\n-- requireで切り替えれる\nnative版を使いたい場合\nrequire 'fuzzystringmatch'\n@jarow = FuzzyStringMatch::JaroWinkler.create()\n\npure版を使いたい場合\nrequire 'fuzzystringmatch/pure'\n@jarow = FuzzyStringMatch::JaroWinkler.create()\n\n-- コンストラクタで切り替えれる\nnative版を使いたい場合\nrequire 'fuzzystringmatch'\n@jarow = FuzzyStringMatch::JaroWinkler.create( :native )\n\npure版を使いたい場合\nrequire 'fuzzystringmatch'\n@jarow = FuzzyStringMatch::JaroWinkler.create( :pure )\n\n実装方法(Rubyコード)\nnative版にのみRubyInlineで実装したRubyクラスを含める。\nrequire 'fuzzystringmatch' でrequireした時、native版のクラスが存在しなければ、自動的にpure版にfall backするようにした。\n以下がLoadError例外処理を入れたrequire。JSONと同じ方法。\nrequire 'fuzzystringmatch/pure'\nbegin\n require 'fuzzystringmatch/inline'\nrescue LoadError\nend\n\nfactoryメソッドで、実際にpure版にfall back しているコードがこちら。\nnative版のクラスのNameError例外を補足して、pure版のインスタンスを返している。\n def self.create( type = :pure ) # factory method\n case type\n when :pure\n FuzzyStringMatch::JaroWinklerPure.new\n when :native\n begin\n FuzzyStringMatch::JaroWinklerInline.new\n rescue NameError\n STDERR.puts &quot;fuzzy-string-match Warning: native version is disabled. falled back to pure ruby version...&quot;\n FuzzyStringMatch::JaroWinklerPure.new\n end\n end\n end\n\n実装方法(gemspec)\nfuzzy-string-match_pure gemパッケージは以下のようにしている。\n- RubyInlineへの依存を外している。\n- native版のRSpecテストケースを含めていない。\n- 以下のファイルを含めない。\n lib/fuzzystringmatch/inline.rb\n lib/fuzzystringmatch/inline/*\n\nそれによって、factoryメソッドで :native が指定された場合でも、前述のRubyのLoadError例外によりpure版にfall backする。\nこのような方法で、純粋な計算しかしないライブラリではpure ruby版を用意すれば、それなりに喜ばれるだろう。",
    "url": "/2012/2/20/2012-02-20-post/"
  },
  {
    "id": "2012-02-24-post",
    "title": "Nendo 0.6.4 リリース",
    "date": "2012-02-24",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2012-02-24-post.md",
    "content": "[Nendo] 0.6.4をリリースしました。(リリースノート: [Nendo.ReleaseNote])\n\nリリースの概要\nCOPYINGとREADMEをgemに追加しました。\n[Sekka]のテストスイート内で#?=によるデバッグ出力を抑制したかったので debug.null を追加しました。\n以下リリースノートです。\nversion 0.6.4\n\nAdded debug.null library for inhibiting to display debug message.\nAdded COPYING and README to gem.\nRefactored Rakefile.\n Divided task test' intotest1' and test2'\n Renamed tasktest2' to `test3'\n Removed arrays of command string.\n\n次の目標\nそろそろ、リファレンスマニュアルを 英語で ちゃんと書きたいと思っています。\n\nコメント by Rathod:\nEssays like this are so important to broaedinng people's horizons.",
    "url": "/2012/2/24/2012-02-24-post/"
  },
  {
    "id": "2012-02-25-post",
    "title": "Sekkaにトライ木の実装が必要な理由",
    "date": "2012-02-25",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-02-25-post.md",
    "content": "[Sekka]の曖昧文字列マッチングはかなり手抜きな実装になっているので直したい。\nトライ木を実装すべき時かもと思いはじめてきた。\n\n残念なデータ構造\n[Sekka]の辞書は、Tokyo CabinetやRedisなどKey-Value Storeに格納されるが、次のような残念なデータ構造になっている。\n例えば、\"kanji\" というローマ字をキーに曖昧検索をする場合は、先頭2文字 \"ka\" のキーワードリストを キー \"(ka)\" で取り出す。\nそのキーワードリストに対して、\"kanji\"との編集距離を求め、ある閾値を越えたキーワードだけを抜き出す。\nキー 値\n(aa) \n (ab) \n .\n .\n (ka) Ka Kappa Katze ka ka' ka'ba ... kanji kanjiban kanjibann ...\n .\n (za) za za'md za'men za'menn za'meq za'ra za'ru za'rurannto ...\n .\n残念な点は次の通り\n- 先頭２文字がキーになっているので、先頭２文字にタイプミスがあると曖昧検索に失敗する。\n例えば、\"kanji\" を \"knji\" に タイプミスすると救えない。\n\nキーワードリストのサイズが大きい\n例えば \"(ka)\" に対するキーワードリストは1.6MByteある。(汗;)\n\nそのため、valueのサイズ制限があるKVSには入れることができない。\nAmazonのSimpleDBに格納したい。SimpleDBにはvalueが1024バイトまでしか入れられない。\n\nキーワードリストの更新が重い。\n特にTokyoCabinetを使った時はDISK I/Oが発生してしまう。\nRedisはDISK I/Oの遅延をしてくれるので、マシではあるが…\n\nトライ木のライブラリを探すが見つからず\n世の中には大量のトライ木のライブラリがある。\n 参考:\n オープンソースのTrieライブラリまとめ - nokunoの日記\n自分が欲しいのは、Key Value Store上にツリーを格納でき、幅優先探索できるもの。\nそして、さらには幅優先探索しながら編集距離で探索範囲を最適化できるもの。\nここまでくるとなかなか無い。\n自分で実装するなら\n次回は、自分で実装するならどういうデータを格納するかを書いてみたい。\n(comment)",
    "url": "/2012/2/25/2012-02-25-post/"
  },
  {
    "id": "2012-02-27-post",
    "title": "[fuzzy-string-match](http://github.com/kiyoka/fuzzy-string-match) 0.9.3 リリース",
    "date": "2012-02-27",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2012-02-27-post.md",
    "content": "二つの文字列同士を曖昧比較するライブラリ(gem)をリリースしました。\n\nfuzzy-string-matchは lucene-3.0.2からJaro-Winkler distance アルゴリズムだけをポーティングしたものです。\n今回はrspecの依存規則をdependencyに変更しました。\nGithub上でpull requestをもらったのをそのままmergeしました。\n #2: rspec is a development dependency by MSch for kiyoka/fuzzy-string-match - Pull Request - GitHub\nリリースノート\n\n0.9.3 / 2012-02-27\nChanged gem dependency of `rspec'.\n gemspec.dependency( \"rspec\" ) to gemspec.development_dependency( \"rspec\" )\n\nソーシャルコーディングは楽しいです。",
    "url": "/2012/2/27/2012-02-27-post/"
  },
  {
    "id": "2012-03-03-post",
    "title": "Sekka 0.9.7 リリース",
    "date": "2012-03-03",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-03-03-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 0.9.7をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nリリースの概要\n主に、Debianパッケージ化の作業が中心です。\nrubygems-testに対応し、\"gem test sekka\"でテストが走るようにし、gem2debでDebianパッケージ化するとそのままではsekka-serverが起動しない問題を解決しました。\n以下リリースノートです。\nversion 0.9.7\n\njewelerの仕様変更に対応した\n-- カレントディレクトリにGemfileがあると、生成されたgemspecの依存規則に採用されてしまう。\n-- SekkaのGemfileはTrivis CI専用なので gemfiles/Gemfile に移動した。\nrubygems-testに対応した\n-- .gemfileをgemに含めた。\n-- \"rake\" のデフォルトタスクではredisのテストを省いた。\n-- 辞書データフォーマット変換の出力を簡潔にした。(MD5の結果値のみにした)\n-- STDOUT出力と、STDERR出力を混ぜるとrubygems-testがブロックする問題の回避\nテストのコンソール出力は、STDOUTのみ使うようにした。\ngem2debでDebianパッケージ化してもsekka-serverが正常に起動するようにした。\n-- sekka.ruのパスを RbConfig::CONFIG'vendordir' を使って解決するようにした。\n 但し、RbConfig::CONFIG'vendordir' 配下にsekka.ruが無い場合は、\n これまで通りsekka-server自身からの相対パスを使う。\n\n次の目標\n先日のエントリ([kiyoka.2012_02_25]SekkaKVSTRIE Sekkaにトライ木の実装が必要な理由)で書いたように、辞書のデータ構造に手を入れて辞書検索の計算量を減らす実験をしてみようと思います。うまくいくかは実験結果次第です。",
    "url": "/2012/3/3/2012-03-03-post/"
  },
  {
    "id": "2012-03-04-post",
    "title": "読んだ本など",
    "date": "2012-03-04",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2012-03-04-post.md",
    "content": "ちょっとミーハーなやつも混ざっているけど…\nこの３冊の本を偶然同時期に見つけて読んだんだけど、この３冊をあわせて読むといい感じでつながってくる。\nいろんな欲しいサービスや製品が頭の中で生まれては消え、という感じで脳の中に新しいネットワークが形成された感じ。\nそれぞれの本を単品で読んでも、あるいは時期がずれたらきっとこういう感じにはならないと思うので、何をどう読むのかって大事なんだなぁと考えさせられる。\nもしかしたら、インフルエンザで寝込んでは起きてしながら本を読んでいた今だからこそ起きた現象なのかもしえないけど。\n(先進国に済んでいる身として)これから自分はどこに向かうべきかについていろいろ考えたりする。\nというか今のままではイカンのかなと思うのであった。\n※ ちなみに、アルゴリズムの本も読んだけど、熱は無くてもインフルエンザの時に読むとトライ木をトラバースしてぐるぐる視点移動しまくる悪夢を見てしまった。\n※ 悪夢をみやすい体調の時はアルゴリズムの本は向いてないな。注意されたし。",
    "url": "/2012/3/4/2012-03-04-post/"
  },
  {
    "id": "2012-03-07-post",
    "title": "Sekkaにトライ木を実装するとしたら ver-1",
    "date": "2012-03-07",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-03-07-post.md",
    "content": "先日の記事 「[kiyoka.2012_02_25]SekkaKVSTRIE Sekkaにトライ木の実装が必要な理由」の続き。\n[Sekka]の曖昧文字列マッチングはかなり手抜きな実装になっている。\nそこをトライ木で改善できるのではないかという話。\n※ 本記事はKey-Value Store型データベースにトライ木を構築する方法を書いています。ポピュラーなtrieライブラリであるDouble ArrayやLOUDSなどのデータ構造の話では無いので、それを期待されて来られた方はすみません… そのあたりの話は全部次の本に書いてあります。私は買いました。ステマではありませんよ。\n問題点\n現状の[Sekka]ではローマ字のキーワードが単純な文字列のリストで格納されているだけなので、ユーザが入力したローマ字との編集距離の比較が大量に発生する。\n例えば、\"Kanji\" に対する編集距離(Jaro Winkler関数)の呼びだし回数は 113211回 (全文字列サイズデリミタのスペース文字を入れると1.6MByte)となる。\nまた \"Ka\"という２文字を入力した時と、\"Kanji\"という５文字を入力した時では同じ回数Jaro Winkler関数が実行される。\nこれはかなりひどい。\nKey-Value Stroeの上に実装する理由\n通常、トライ木のライブラリはCやJavaなどの言語を使って実装され、整数型の配列やポインタを駆使し(時にはビット演算まで使って)格納データサイズを圧縮することに主眼が起かれていることが多い。\nしかしここでは、世間の常識に反してプレーンなKey-Value Stroe上に実装してみる。\n理由は、C言語のtrieライブラリを使うとインストール作業の敷居が上がるのでやりたくないのと、分散ハッシュテーブルを使って曖昧文字列マッチングがスケールアウトする様を見てみたいというのがある。\n実は、単純に趣味の問題も大きいが…\nトライ木\nトライ木を使えば、計算しても意味が無い部分ツリーをばっさり枝刈りできると考えた。\n文字列が短かければそれだけ計算量を減らすことができる。\nトライ木の概念\nプレフィックス木（Prefix Tree）とも言われるだけあって、検索したい文字列の先頭から1文字づつ比較しながら木を降りていける。\n幅優先探索も、深さ優先探索もどちら簡単に実装できる。\n概念図は下記のようなもので、各ノードから子に降りて行くエッジ部分に１文字のアルファベットが付いている。\n\n\"A\", \"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\" というキー群によるトライ木\n上の図はトライ木 - Wikipediaからコピーしてきたもので、これを使って考える。\nKey-Value Storeでの実現方法\nあるノードの子をたどれるようにするために以下のようなデータ構造を考えることが可能だ。\nkeyはKey-Value Storeのキー、valueはKey-Value Storeの値とする。\nキーという用語が二つ出てくるので注意。\nKey-Value Storeのキーをkey 、トライ木のキーを「キー」と表記する。\nなお、扱える文字クラスはアスキーの範囲しか考慮していない。また $ は特別な記号に使っているため $ も使えない。\n *key* *value*\n\n1 node:$ \"i$ t A$\"\n 2 node:i \"n$\"\n 3 node:in \"n$\"\n 4 DATA:i 11\n 5 DATA:in 5\n 6 DATA:inn 9\n 7 node:t \"e o$\"\n 8 DATA:to 7\n 9 node:te \"a$ d$ n$\"\n 10 DATA:tea 3\n 11 DATA:ted 4\n 12 DATA:ten 12\n 13 DATA:A 15\n順番に解説すると1行目の key \"node:$\" はスーパールートといってツリー全体の根になる。\nvalue側の \"i$ t A$\" のうち \"i$\" は $が付いているのでトライのキーとして登録されていることを示す。\nkeyの \"node:\" で始まっているものがトライ木のノード、\"DATA:\"で始まっているものがトライ木に上のキーに対応するデータである。\nvalueの数字は実際のデータである。そのKey-Value Storeがサポートしたデータならなんでも良い。\n13行目は A に対してのデータで数値の15を例として入れてある。(わかりやすいように上の図のノード番号を入れている)\nprefix searchの手順\n木全体から \"in\" で始まる単語を探索する場合\n- 1行目の \"node:$\" のvalueを調べる\n- 1文字目の i がキーワードとして終端している \"i$\" があるので、iをキーワードとして蓄積する。\n- iに続くキーワードがまだあるかも知れないので、KVSから\"node:i\"で引いてノードがあるか調べる。\n- 2行目の \"node:i\" が見つかるのでvalueを調べる。\n- 2文字目の n がキーワードとして終端している \"n$\" があるので、inをキーワードとして蓄積する。\n- inに続くキーワードがまだあるかも知れないので、KVSから\"node:in\"で引いてノードがあるか調べる。\n- 2行目の \"node:in\" が見つかるのでvalueを調べる。\n- 3文字目の n がキーワードとして終端している \"n$\" があるので、innをキーワードとして蓄積する。\n- innに続くキーワードがまだあるかも知れないので、KVSから\"node:inn\"で引いてノードがあるか調べる。\n- ノードが無いので、inn以下のトラバースはしない。\n- 探索結果から、検索文字列 \"in\"よりも文字列長が短かい \"i\" を削除したリストをprefixの結果とする。\n※ 途中、valueに複数の子ノードが見つかったら、それぞれのエントリを再帰的にトラバースする。\n編集距離による絞り込み探索\nprefix searchと違う点は文字列が完全一致しているかどうかを調べるかわりに、探索クエリ文字列とトラバース中に見つかったキーワード同士の編集距離が閾値に収まるかで判定する。\n閾値に収まらないキーワード配下のツリーは探索対象としない。\nキーワードの動的な登録\n注意する点は、一般的なKVSは複数keyの一貫性のある登録をサポートしていないので、登録中に参照があった場合、おかしな木が見える可能性があること。\n対策として登録順を工夫する。\n最初にデータ、次にツリーの葉のほうから根に向かって順に登録していくことで参照時のファントムリードが無いようにできる。\n※ 参考:Tokyo Cabinetは複数エントリの一貫性のある登録(トランザクション)をサポートしている。\nキーワードの動的な削除\n注意する点は、一般的なKVSは複数keyの一貫性のある削除をサポートしていないので、削除中に参照があった場合、おかしな木が見える可能性があること。\n対策として削除順を工夫する。\n最初にツリーの根のほうから葉に向かって順に削除、最後にデータという風に削除していくことで参照時のファントムリードが無いようにできる。\n※ 参考:Tokyo Cabinetは複数エントリの一貫性のある登録(トランザクション)をサポートしている。\nというわけで、一度実装してみて問題があれば、訂正記事を書こうと思う。",
    "url": "/2012/3/7/2012-03-07-post/"
  },
  {
    "id": "2012-03-30-post",
    "title": "Sekkaにトライ木を実装するとしたら ver-2",
    "date": "2012-03-30",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-03-30-post.md",
    "content": "先日の記事 「[kiyoka.2012_03_07]SekkaKVSTRIE Sekkaにトライ木を実装するとしたら ver-1」からの差分。\nGitHub上で実際にdistributed-trieという名前でライブラリを実装してみた。\n現在は鋭意パフォーマンス計測中。\n分散トライ木\nトライ木は通常、C言語などのようなbit単位でデータを操作できる低レベル言語で実装されるのが一般的だ。\n同一のマシンの同一プロセス空間にポインタなどを使って密結合なデータ構造を作るのがポピュラーなやりかた。\n一方、今回私が作ったdistributed-trieはセオリーから外れており、Pure Rubyで書いてあるのと、複数のマシンから成る分散ハッシュテーブル(KVS)上にトライ木を構築するといったものだ。\n分散のメリット\n巨大な辞書を分散ストレージで一元管理し、パフォーマンスが足りなくなってきたらマシンをスケールアウトして対応することを狙っている。\nGoogleの「もしかして？」機能のようなスペルミス訂正などに使えると思う。\nAWS EC2を使えば、リクエストが少ない時間帯は稼動マシン数を減らすなどしてコストを抑えることも可能だ。\ndistributed-trieの特徴\n構成図\n\n* Trie木の例\n\n\"A\", \"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\" というキー群によるトライ木\n* 役割範囲はキー群の管理に限定\n以下のキー部分の操作ライブラリが担当する。\n *key* *value*\n\n1 node:$ \"i$ t A$\"\n 2 node:i \"n$\"\n 3 node:in \"n$\"\n 4 node:t \"e o$\"\n 5 node:te \"a$ d$ n$\"\nつまり、トライ木のキーに対応するデータは、ライブラリの責任範囲外。アプリケーションは自分でデータを格納する。\nデータの内容はアプリケーションの都合で自由に決めれる。\n1 DATA:to データ7\n 2 DATA:i データ11\n 3 DATA:in データ5\n 4 DATA:inn データ9\n 5 DATA:tea データ3\n 6 DATA:ted データ4\n 7 DATA:ten データ12\n 8 DATA:A データ15\n* トランザクション機能はKVS機能の担当\n例えば、Tokyo Cabinetは複数エントリの一貫性を保持するトランザクション機能を持つ。\nこれも、ライブラリの責任範囲外。\nトライ木の構築とトライ木に対応したデータの格納をトランザクションで括れば一貫性のあるデータ管理ができる。\n※ 分散KVSで一貫性を持つものはほとんど無いため、あまりトランザクションを使う場面は無いかもしれないが…\n* KVSはプラッガブル\nユーザーがKvsIfクラスと同じ挙動を示すクラスを用意すれば、何にでもトライ木を構築できる。\n例えば、DynamoDB、HBase、Okuyamaなど、Rubyのバインディングが存在するKVSなら簡単にトライ木を構築できる。\n現段階では distributed-trie は Tokyo Cabinet / memcached / gdbm / SimpleDB / DynamoDB / Redis / ruby's pure hash をサポートしている。\nパフォーマンスの特性がわかってきたら、またブログ記事を書く予定。",
    "url": "/2012/3/30/2012-03-30-post/"
  },
  {
    "id": "2012-04-01-post",
    "title": "Ruby 2.0(開発版)に入ったEnumerable::Lazyを試してみた",
    "date": "2012-04-01",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2012-04-01-post.md",
    "content": "ゆくゆくは Ruby 2.0に入るようだ。\n今回、Ruby 2.0の開発版を実際に動かしてみた。\n Ruby 2.0 Enumerable::Lazy | Railsware blog\n (うちの猫がLazyな時の写真)\nLazyが無いとどうなるか\n次の例ように、ファイルから行単位で処理するようなRubyプログラムがあるとする。\nbashで書くならば、 \"grep ruby test.txt | head -5\" のような処理。\n File.open( 'test.txt' ) do |f|\n arr = f.map(&amp;:chomp).grep(/ruby/).take( 5 )\n arr.each{ |x| puts x }\n end\n\n一般的に、読みやすいコードを心掛けると上のように全行をメモリに読み込んで処理するように書くだろう。\nmapとかeachを使ってメソッドチェーンを多用すれば簡潔に書けるからだ。\nただ、メソッドチェーンの度に新しいArrayが確保されるため、test.txtが大きいとメモリを大量に消費する。\nLazy(遅延評価)はこれを綺麗に解決してくれる。\nRuby 2.0をインストールする方法\nRuby 2.0をビルドしたいなら、githubからcloneするのが簡単だ。\nmasterブランチがRuby 2.0の開発版になっているようだ。\ngit clone https://github.com/ruby/ruby.git\nCloning into ruby...\nremote: Counting objects: 222847, done. \nremote: Compressing objects: 100% (44673/44673), done. \nReceiving objects: 92% (206057/222847), 64.40 MiB | 317 KiB/s pwd\nremote: Total 222847 (delta 177021), reused 220708 (delta 176422) \nReceiving objects: 100% (222847/222847), 76.22 MiB | 310 KiB/s, done.\nResolving deltas: 100% (177021/177021), done.\n\n~/work/github $ cd ruby/\n~/work/github/ruby $ ls Makefile*\nMakefile.in\n\n~/work/github/ruby $ autoconf\n~/work/github/ruby $ bash ./configure\nchecking build system type... x86_64-unknown-linux-gnu\nchecking host system type... x86_64-unknown-linux-gnu\n .\n .\n.ext/include/x86_64-linux/ruby/config.h updated\nverconf.h updated\nruby library version = 2.0.0\nconfigure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: creating ruby-2.0.pc\n\n~/work/github/ruby $ make dist\nruby ./tool/make-snapshot tmp \nExporting trunk@35198\nExported revision 35198.\ntake a breath, and go ahead\ncreating configure... done\ncreating prerequisites...\n .\n .\nprerequisites done\ncreating bzip tarball... /home/kiyoka/work/github/ruby/tmp/ruby-2.0.0-r35198.tar.bz2 done\ncreating gzip tarball... /home/kiyoka/work/github/ruby/tmp/ruby-2.0.0-r35198.tar.gz done\ncreating zip archive... /home/kiyoka/work/github/ruby/tmp/ruby-2.0.0-r35198.zip failed\n* /home/kiyoka/work/github/ruby/tmp/ruby-2.0.0-r35198.tar.bz2\n SIZE: 9913268 bytes\n MD5: 943937f8635458fedfc271f97e6133c9\n SHA256: ed5850f393db8ec39568fcd9446566ebcdabe4584c0f8c7a827e21e0bd0a9e3a\n\n* /home/kiyoka/work/github/ruby/tmp/ruby-2.0.0-r35198.tar.gz\n SIZE: 12561052 bytes\n MD5: 60bb6bdf08dcdbf424cd757b517ded75\n SHA256: 898aa4e3222d5585621112dd8c277d3e565a130540f2ea8a5bd4b0d70c7ad334\n~/work/github/ruby $ \n\nできた tmp/*.tar.gz をオフィシャルリリースされた ruby-1.9.3-p125 の tar.gz と同様にビルド、インストールできる。\n※ ちなみに、私は stowというツールでいろんなRuby環境をスイッチできるようにしている。\nLazyの効果\n実際に大きなサイズのtest.txtを用意して試してみた。\n$ du -sh test.txt \n198M test.txt\n\n* Lazyなし\n$ ruby ./lazy_sample.rb \n*without Lazy*\nbioruby\neruby\nfxruby\nhruby\nhruby's\n=&gt; VmPeak: 1282188 kB (1252.1MB)\n\n* Lazyあり\n$ ruby ./lazy_sample.rb lazy\n*with Lazy*\nbioruby\neruby\nfxruby\nhruby\nhruby's\n=&gt; VmPeak: 26280 kB (25.6MB)\n\nプロセスがどこまでも肥大したか(ピーク)を調べると、lazyを使ったバージョンは25.6MByteしかメモリを消費しないことがわかった。\n\".lazy.\" の6文字を追加しただけでこれだけの効果がある。素晴らしい。\n実験したソースコード\nlazy_sample.rb\n sample for Enumerable::Lazy of Ruby 2.0 — Gist\n感想\nRubyに遅延評価が入るとは思ってなかったのでこれは嬉しい。\n私が作っているLisp処理系の[Nendo]はRubyとのインテグレーション済みなので、[Nendo]のmapやfor-eachにEnumerable::Lazy型を渡せば同様にLazyに処理できるはず。(今度実験してみよう)\n実は、普段[Nendo]で500MByteクラスのテキストファイルを処理することがよくある。その度に、メモリ消費量を削減するためにfor-eachで1行づつ処理するループをコーディングしていた。\nもうその必要が無くなるだろう。Ruby 2.0が正式リリースされるのが本当に楽しみになったぞ、これは。",
    "url": "/2012/4/1/2012-04-01-post/"
  },
  {
    "id": "2012-04-03-post",
    "title": "SHOT NOTEはじめました",
    "date": "2012-04-03",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2012-04-03-post.md",
    "content": "手書きメモをスッキリデジタル化「ショットノート」 | KINGJIM\nもう、マウスで図を描くのがいやになった。ちょっとした図を描く時は時間をかけたくない。\nというわけで、究極のUIである紙とペンを使うことにした。\n写真はLサイズで、MacBook Proの13インチと比べてもそんなに大きくないので、机を占有しない。\n実際に描いてみると、Mサイズでも十分図が描けそうな感じがした。\n\n期待通り、短時間で図が描けてしまう。\nBlogでなにか込み入ったことを説明する場合は、文章を書く手間も省けそうだし読む側もきっと図を見たほうが早い。\n早速、githubで公開しているソフトウェア(distributed-trie)のREADMEにも使い始めた。\n上の図を、SHOT NOTEで取り込んで若干色を加工すると下の図になる。\n\nメンテの必要の無い図を書く時は、全部これでいこう(笑)\nおすすめです。",
    "url": "/2012/4/3/2012-04-03-post/"
  },
  {
    "id": "2012-04-04-post",
    "title": "Sekkaのブランチを1.0と1.1にわける予定",
    "date": "2012-04-04",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-04-04-post.md",
    "content": "二つの系列に分けることを考えている。\n- 1.0は安定版としてメンテナンスモードへ(0.9系列をそのまま1.0へ)\n- 1.1は開発版としてアグレッシブな変更を入れるモードへ\n\n1.1の取っ掛かりとして、distributed-trieを組み込む。\nさてどれだけ日本語変換のレスポンスが良くなるか。\n今のSekka 0.9系列は単語によってレスポンス性能にムラがある。\n曖昧文字列検索のインデックスに偏りがあるせいだ。\ndistributed-trieでそのあたりのムラが減少するとみている。\n余力があれば、その後曖昧検索付きのmigemoが作れるか実験してみたい。Sekkaの辞書を使えばできるはず。\n問題は、生成した正規表現が大きすぎるのでEmacsが拒否してくるという可能性か。そのあたりはひと工夫要りそう。\nいろいろやってみたいことはあるので、開発版はしばらく不安定になるかもしれない。\nそれにしても日本語入力は興味が尽きないテーマだなぁ。\n何か新しい技術なりライブラリ(今回は分散KVSとtrieだが)があると、とりあえず日本語入力に適用してみるとその素性がつかめるし楽しい。",
    "url": "/2012/4/4/2012-04-04-post/"
  },
  {
    "id": "2012-04-05-post",
    "title": "MySQL CluterがRDBMSのASIC特性を保持しつつスケールアウトできるのはなぜか",
    "date": "2012-04-05",
    "categories": [
      "MySQL"
    ],
    "file_path": "_posts/2012-04-05-post.md",
    "content": "タイトルは釣りです… 誰か教理由を教えてください。\nそんなことがあるわけないので、何かミスリードがあるに違いない。\n MySQL :: MySQL Cluster: スケーラビリティ\n\n MySQL Clusterの自動シャーディング\n 他の分散型データベースとは異なり、シャード間でクエリーおよびトランザ\n クションを実行する際にJOIN処理を実行する機能を損なうことはなく、\n ACIDを犠牲にすることもありません。\nもう少し調べてみるつもり。\n MySQL :: MySQL Cluster に関する FAQ",
    "url": "/2012/4/5/2012-04-05-post/"
  },
  {
    "id": "2012-04-07-post",
    "title": "Ruby 2.0(開発版)に入ったEnumerable::Lazyを試してみた(Nendo編)",
    "date": "2012-04-07",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2012-04-07-post.md",
    "content": "「[kiyoka.2012_04_01]RubyNendo Ruby 2.0(開発版)に入ったEnumerable::Lazyを試してみた」の続き。\nRuby 2.0をビルドする手順は先日の記事を参照してほしい。\n今日は、Nendoでも試してみた。\n もうひとつLazyな写真\n[Nendo] 0.6.4でもそのままLazyの効果は出た。\nそういえば、書き忘れていたが、Lazyは使用メモリを削減するだけじゃなくて、計算量も削減するのだった。実際に必要な分しか計算しない。\n今回のサンプルプログラムでは、take 5 しているので、grepして見つかった最初の5行が見つかったところで計算を打ち切る。\nLazyの効果\n実際に大きなサイズのtest.txtを用意した。\n$ du -sh test.txt\n58M test.txt\n\n* Lazyなし\n$ time nendo ./lazy_sample.nnd \n*without Lazy*\nruby\nruby's\nrubying\nruby\nruby's\n=&gt; VmPeak: 428816 kB (418MByte)\n65.48user 0.43system 1:11.54elapsed 92%CPU (0avgtext+0avgdata 1572592maxresident)k\n\n* Lazyあり\n$ time nendo ./lazy_sample.nnd lazy\n*with Lazy*\nruby\nruby's\nrubying\nruby\nruby's\n=&gt; VmPeak: 65544 kB ( 64MByte)\n2.19user 0.04system 0:02.45elapsed 91%CPU (0avgtext+0avgdata 132704maxresident)k\n\nメモリ消費量が減ったと同時にCPU消費も減ったことも確認できた。\nすばらしい。\n実験したソースコード\n先日のRubyコードはリファクタリングして読みやすくした。\n lazy_sample.rb\n sample for Enumerable::Lazy of Ruby 2.0 — Gist\nNendo版はRuby版と対比させやすいようなコーディングにしてあるので比較してみてほしい。\n lazy_sample.scm\n Nendo sample for Enumerable::Lazy of Ruby 2.0 — Gist\n感想\nNendoに変更を加えなくてもとりあえずLazyになった。素晴らしすぎるぜ。",
    "url": "/2012/4/7/2012-04-07-post/"
  },
  {
    "id": "2012-04-12-post",
    "title": "Sekka 1.0.0 リリース",
    "date": "2012-04-12",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-04-12-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 1.0.0をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nリリースの概要\nSekka初の安定板リリースです。\nひととおりの機能が長期間の使用に耐えて安定してきたので、1.0.0とします。\nmemcachedの負荷が重くなった時に、sekka-serverがmemcachedが落ちているというメッセージを返していたので、少し余裕を見てタイムアウト設定を1秒にしました。\nその後、localhostでsekka-serverでも上記のメッセージは見なくなったので、一応の調整はできたと考えています。\n以下リリースノートです。\nversion 1.0.0\n\nMemcachedのタイムアウトを1秒に拡大した。\n\n次の目標\n先日「[kiyoka.2012_04_04]SekkaIME Sekkaのブランチを1.0と1.1にわける予定)」で書いた通り、開発版のブランチ 1.1系を開発していきます。",
    "url": "/2012/4/12/2012-04-12-post/"
  },
  {
    "id": "2012-04-13-post",
    "title": "Amazon DynamoDBが思ったほど低レイテンシではなかった件",
    "date": "2012-04-13",
    "categories": [
      "AWS"
    ],
    "file_path": "_posts/2012-04-13-post.md",
    "content": "DynamoDBを使ってみた。\nこれまで、私はTokyo Cabinet、memcacehd、 Redisといった、わりと単純なデータモデルのKey-Value Storeを使ってきた。\nそんな私が、DynamoDBを使ってだいぶ違うということを感じたので記事にしたい。\nそれはRemote APIのレイテンシが小さいか大きいかで全く適用範囲が違う別モノだということだ。\n分散Key-Value Storeといってもいろんなタイプがある\nKey-Value Storeというくくりが広すぎるということもある。(NoSQLという呼び名も同じ)\nとにかく、分散ハッシュテーブルの原理を使ってスケールアウト可能なやつは全てKey-Value Storeと呼ばれているので注意が必要。\n大きく分けると「ドキュメントデータベース」と「それ以外」になると思う。\n分散Key-Value Storeの分類\nもっと別の分類方法があると思うが、アプリケーションとしてどちらを適用するかという観点で見た場合の分類として考えてほしい。\n\n* ドキュメント指向データベース\n傾向として書き込みは低速、APIのレイテンシは長い。\n一般的に、JSONなどの複雑なデータを格納することができる。\nカラム毎にインデックスを設定することができ、後でカラムに対する検索クエリが使える。\nそういう分類をすればSimpleDBとDynamoDBはドキュメント指向データベースだと思う。\nMongoDBやCouchDB、BigTableも同じカテゴリに入るだろう。\n* それ以外\n傾向として書き込みは高速、APIのレイテンシは短い。\nKey-Value StoreのValueに保存するデータ構造がシンプルなものを全部をこっちに入れたい。\nTokyo Cabinet、Redis、memcached、memcachedプロトコルでアクセスできる殆どのデータベースはこっち。\n他にもOkuyama、flareなどデータベースもこちら。\nシングルスレッドのレイテンシ\nRedisはシンプルスレッドのプログラムから秒間10000オーダーのレスポンスを返してくれる。\n現在開発中のdistributed-trieはそういう低いレイテンシを期待したtrieのライブラリだが、それをSimpleDBとDynamoDBに適用しようとして無理だとわかった。\nDynamoDBの方は宣伝文句に「低レイテンシ」と書いてあるので期待してしまったのだが、シングルスレッドからのレイテンシは長めで、高いスループットは出せない。\nAPIはhttpの上にRESTで構築されているので、シングルスレッドからは秒間100オーダーを出すのがやっとだろう。実際にAWS SDKに入っているPure Rubyのクライアントからは秒間20を出すのがやっとだった。\n従って、DynamoDBが「低レイテンシ」と書いてあるのは、複数のスレッドから平行にアクセスした場合のトータルで計算したらレイテンシが低いという意味でとらえるべき。\nそれは低レイテンシとは言わない気がするけどなぁ。高スループットは但しいけど。\n勘違いの要因\nDynamoDBの方は宣伝文句に「低レイテンシ」と書いてあるので、もしかしてドキュメントベースのようにもmemcachedのようにも使える万能なものだと勘違いしてしまったのが要因。\nまとめ\nDynamoDBはKVSと呼ばれているが、memcachedのような低レイテンシなKVSと混同して使うと失敗する。\nむしろ、メンテナンスのいらないApache CouchDBのようなものとして使うこと。\n補足\n適用範囲を間違えただけでDynamoDBが期待外れの性能という意味ではありません。\n複数スレッドからのスループットは期待通りであり、DBを止めずに限界スループットを上げていける様は圧巻です。将来きっと何かに使います。\n Amazon DynamoDB Overview, a fully managed NoSQL database service\n参考\nkey-valueストアの基礎知識\n Bigtableと分散KVS - スティルハウスの書庫\n 分散KVSの使い方 - sdyuki-devel\n ここで言うところの分散KVSには、BigTableやCassandraなどの、いわゆる\n Multi dimensional sorted storeは含めていない。これらの分散データストア\n はkey-valueよりも高級なデータモデルを持ち、単純なKVSの効率上の問題を解\n 決しようとしている。",
    "url": "/2012/4/13/2012-04-13-post/"
  },
  {
    "id": "2012-04-15-post",
    "title": "「ビッグデータを征す クラウドの技術 Hadoop&NoSQL」を読んだ",
    "date": "2012-04-15",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2012-04-15-post.md",
    "content": "NoSQL(分散KVS)関連の仕組みがよくまとまっている。いいぞこれ。\nNoSQLの部分はHBaseとCassandoraが中心に解説してあるのだけど、原理から教えてくれるので、他の分散KVSがどういうものか検討が付くようになる。\nCAP定理についてここまで平易に書かれているものは無いような気がする。\nおかげで、Amazon DynamoDBがどういう位置付けでどういう用途に向いているかも間接的にわかった。\nもし、自分のように運用まで手がまわらなくて、でもHbaseやCassandoraのような本格的な分散KVSを使いたい場合はDynamoDBに頼るのが良いのだろうと思った。\n今後NoSQLをウォッチしていきたい人は一度読んでおくことをお薦めする。",
    "url": "/2012/4/15/2012-04-15-post/"
  },
  {
    "id": "2012-04-23-post",
    "title": "distributed-trieを使って曖昧文字列検索実装してみた感想",
    "date": "2012-04-23",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-04-23-post.md",
    "content": "曖昧文字列マッチングのindexをtrieにしたのだが、前よりもモッサリした感じになった。\n以前のバージョン 1.0.x では、\"Kanji\"というクエリに対して、1.6MByte程度のインデックスがKVSから１回で返ってき\nていた。\n 例\n MASTER::(ka) ka ... kanji ... (1.6MByteもある)\n今回のtrieを使ったバージョン 1.1.x (開発版) ではtrieのツリーを辿りながら、曖昧文字列マッチングをするという方式に変えた。\n文字列の流さが10文字であれば、悪くて100回程度のKVSへのリクエストが飛ぶ可能性がある。\n 例\n Master::Index::k a$\n Master::Index::ka n\n Master::Index::kan j\n Master::Index::kanj i$\n .\n .\n良くなった点\n登録が軽くなった。\nユーザー辞書に新規の語彙を追加した時にも重くならない。\nread/writeのバランスが良くなった。\n1.0.xでは辞書登録中は重くて10秒以上レスポンスが返ってこないことも多かったが、1.1.xでは辞書登録の影響はほんとんど無くなった。\n1.0.xではインデックスの更新に、1.6MByteのwriteが発生することになるので、かなりDISK I/Oに負荷を掛けていたに違いない。\n1.1.xでは小さいエントリを沢山細切れに書くようになる。writeの合間にreadも可能だ。\n悪くなった点\n* 変換レスポンスが悪くなった。\nTokyo Cabinetを使った時の体感的なレスポンスが悪くなった。\nsekka-benchmarkコマンドでベンチマークを取ると３倍ほど速くなっているんだけど、それはベンチマークの方法が悪いということで…\nRedisを使った時はほとんど劣化は無いような気がする。\n* 辞書が大きくなった\n辞書のリストア用TSVイメージであるSEKKA-JISYO.SMALL.tsvが223Mから381Mに増えた。\n結果、redis-serverが消費するRAM容量が800MByteから1.4GByteに増えた。\nredis-serverが消費する容量の増加具合が比例していない気もするが、Redisのkeyのインデックス分なのではないかと推測する。\nKVSのエントリ数は 3873011件 から 11533536件 に増えた。エントリ数は約３倍だ。\n改善案\n1.0.x は Tokyo Cabinetが使うメモリ容量は64MByteだが、それを256Mや512Mくらいに設定してやれば、もしかしたら良いバランスに落ちつく可能性がある。\n要はDISKのreadを適度に抑制してやる必要があるわけだ。\nRedisはDISK I/Oが無いので高速なのは当然だが、メモリが大量にある人向けのオプションだなぁ。\n自分はRedisを使うけど。\n感想\nなんかローカルにsekka-serverを立てる場合、良くなったのか悪くなったのかわからないなぁ。\n多分、今回の変更でスケールアウトするようになったのは確実なのでそのあたりも調べてみたい。\nしかしスケールアウトするといってもぴったりマッチするKVSも無いわけだが… (Redis Clusterか？)\nうーん、何だか趣味の領域を脱出できてない気がする…",
    "url": "/2012/4/23/2012-04-23-post/"
  },
  {
    "id": "2012-04-26-post",
    "title": "Sekka辞書に[distributed-trie](http://github.com/kiyoka/distributed-trie)を利用する際の最適値を見付けた",
    "date": "2012-04-26",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-04-26-post.md",
    "content": "先日、曖昧文字列マッチングのindexをtrieにしたが、モッサリした動きになったと書いた。\n 「[kiyoka.2012_04_23]SekkaKVS distributed-trieを使って曖昧文字列検索実装してみた感想」\n今日はSekka 1.1.0はこれで行けるという最適値を見付けたのでメモしておく。\n以下の設定でほぼリアルタイム(0.2秒間隔)で変換でき、ユーザー語彙登録中も1秒以内に変換レスポンスが返ってくる。\nSekka 1.0.xよりも少ないメモリ使用量で効率的に動けるようになり、前のように10秒以上レスポンスが返ってこない場面も無くなった。\n最適な組みあわせ\n\nKVSはTokyo Cabinetを使う。Redisは不要。\nTokyo Cabinetのキャッシュ設定を256MByteにする。 ( #xmsiz=256m )\n\nやっと、distributed-trieの成果が現れてきたので嬉しい。",
    "url": "/2012/4/26/2012-04-26-post/"
  },
  {
    "id": "2012-04-28-post",
    "title": "[distributed-trie](http://github.com/kiyoka/distributed-trie) 0.8.0 リリース",
    "date": "2012-04-28",
    "categories": [
      "KVS"
    ],
    "file_path": "_posts/2012-04-28-post.md",
    "content": "ファーストリリース。\nとりあえず[Sekka]に組み込んでライブラリAPIとして使えるということが検証済みなのでリリースした。\nコードの高速化はまだやってない。ソースコードはもうすこしリファクタリングが必要かも。\nまた、trieキーの削除には対応していないなど、まだまだ改善しないといけないこと多いが…\n高速化は 0.8.x でやり、キーの削除は 0.9.x でやるという感じのぼんやりとしたマイルストーンを予定している。\nどのDBでどこまでスケールするのかという計測も順次やっていかんとなぁ。",
    "url": "/2012/4/28/2012-04-28-post/"
  },
  {
    "id": "2012-05-04-post",
    "title": "昭和16年夏の敗戦",
    "date": "2012-05-04",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2012-05-04-post.md",
    "content": "よくぞここまで取材したなぁという感想を持った。\nなんというか、第二次世界大戦当時とは違うと思いたいけれど、この本を読む限り、今の日本もあまり変化してないと考えさせられる。\n空気という見えない力が働いて、誰も大きな流れを止めることはできない現実。",
    "url": "/2012/5/4/2012-05-04-post/"
  },
  {
    "id": "2012-05-05-post",
    "title": "Sekka 1.1.0.pre リリース",
    "date": "2012-05-05",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-05-05-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 1.1.0.preをリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nリリースの概要\n開発版のため、まだ安定しているとは言えません。\npreリリース版であるため、次のように \"--pre\" オプションを付けないと 1.1.0.pre はインストールされません。\ngem install sekka --pre\n\n従来通り、最新版は次のコマンドで\ngem install sekka\n\n1.0.0(安定板)がインストールされます。\n以下リリースノートです。\nversion 1.1.0.pre\n\ndistributed-trieを使って曖昧辞書検索を高速化した。\nTokyo Cabinetのメモリキャッシュ指定を64MByteから256MByteに増やした。\n\n次の目標\n開発版のブランチ 1.1系で引き続きmigemo互換インタフェースなどに挑戦してみます。",
    "url": "/2012/5/5/2012-05-05-post/"
  },
  {
    "id": "2012-05-06-post",
    "title": "DynamoDBのスループットを減らす場合に制約がある理由について考えてみた",
    "date": "2012-05-06",
    "categories": [
      "DynamoDB"
    ],
    "file_path": "_posts/2012-05-06-post.md",
    "content": "Amazon DynamoDBのスループットを減らす時は、以下の画面キャプチャように1日1回しかできないようになっている。\nその理由を考えてみた。ほとんど推測なので、間違っているかもしれない。目くじら立てないで欲しい。\nこれはもしかして、これはアザトい仕様なのかもしれない… とか少し思った。\n\n理由１ 技術的(理論的？)制約があるため\n* スループットを増やす時\nDyanmoDBは基本的にDHT(Distributed Hash Table)なのでconsistent hashingアルゴリズムを使っている。\nスループットを上げる時は、内部でマシンの数を増やして、スケールアウトしているはず。\n例えば、スループットを倍に上げるためには、単純にマシンの数を倍にすれば良い。単純複製をすると、半分のデータはアクセスされずゴミになるが…\nマシンの数を増やすためには、ストレージの内容を複製する必要がある。\n実際にDynamoDBを使ってみるとわかるが、Webコンソールからスループットを倍に上げる指示を出してから約1分程度で反映される。\nまた、ガーベッジコレクションとして、アクセスされる可能性の無くなったゴミデータは少しずつ消しているはず。これは後でゆっくりやっているはずだ。\n* スループットを減らす時\n次にスループットを下げる時は、内部でマシンの数を減らす必要がある。\nそうしないと、遊んでいるマシン分をAWS側が負担しなければならず、原価割れするだろう。\n問題はスループットを下げる時は、複数のマシンとストレージに入っているデータをマージする必要があることだ。\nそのとき、primaryキーのインデックスを再構築する必要がある。\nDynamoDBの仕様として、primaryキーはレンジサーチができる必要があるので、おそらくB+ツリーなどのインデクスを利用していくだろう。\nいづれにしても再構築には時間がかかる。\nなので、スループットを下げる時は、どうしてもなんらかの時間的制約を入れる必要がある。\n理由２ スループット設定を下げ忘れさせるため\nちょっといじわるな見方をしてみよう。\nもしかして、ユーザーにスループットを下げることを忘れさせて、課金を最大化するためにやっているのではないか？\nまとめ\n良心的な目でみるなら、理由１だろう。\n私が初めてこの制限を知った時には、結構失望したが、技術的・理論的な理由が考えられなくも無いということで、一応メモ。\nもしあなたが、急激なアクセスピークをDynamoDBで乗りきった後、上司やクライアントにすぐ設定を減らすように言われたが、すぐにはできないというこの制限に気がついた時は一つの釈明として使ってもらえればと思う。",
    "url": "/2012/5/6/2012-05-06-post/"
  },
  {
    "id": "2012-05-07-post",
    "title": "自分にしみついたオープンソース的な感覚について",
    "date": "2012-05-07",
    "categories": [
      "透明性"
    ],
    "file_path": "_posts/2012-05-07-post.md",
    "content": "私は趣味のプログラミングを全部オープンソースにしているが、仮にそうでなかった場合どうだっただろうと考えた。\n考えるきかっけになったのはこの記事のこのくだり。\n 透明性への耐性を備えた組織を設計する - Joi Ito's Web - JP\n まるで、ソフトウェアが書かれた後に「オープンソース化する」ことになった\n プロジェクトのようなものだ。コードがごちゃごちゃで、ほとんど不可能とい\n う場合が多い。ソフトウェアをオープンにする場合には、外の人間にも理解で\n き、恥ずかしくないような書きかたをするのが普通だ。例えば変数に卑猥なこ\n とばを使ったり、コード内のコメントのところで恋愛関係の不満をぶちまけた\n りする開発者も何人か知っている。彼らはコードが突然オープンになったら、\n 職や伴侶を失うことになりかねない。\n実は、このくだりはこの記事の極端な例え話として使われている話題であり、テーマそのものでは無い。\nしかし、テーマには関連する。\nテーマは、インターネットが主流になった世界においては、透明性に対する耐性を普段から上げておくために普段からそれを意識した組織にしておく必要があるということ。\nいつオープンにするよう求められてもその耐性を組み込んでおけということ。\nで、前置きが長かったが自分の話に戻ると、普段からオープンソースを自分のニュートラルな状態としてしみこませていると、クローズドな環境であっても恥しくないコードを書こうとするということ。\nこれはエンジニアとしてコダワリにも通じる。(悪くいえばコストをいくぶん度外視した自己満足的なところあるかもしれないが)\n結果的に、透明性に対する耐性を上げているということになる。\nそうしておくと、突然いま書いているコードを他者に転売・譲渡(納品という形が一番多いが)する時に問題が無い。\n実際に過去のプロジェクトで自社商品から派生したシステムのソースコードが納品されることもあったなぁと思い出した。\n最近、Web系企業から多くのプロダクトがオープンソースになっている。\nこの流れは加速しそうなので、今クローズド前提のコードを書いている人も心掛けておいて損は無いと思う。",
    "url": "/2012/5/7/2012-05-07-post/"
  },
  {
    "id": "2012-05-08-post",
    "title": "失敗事例: Microインスタンスのスラッシング状態で 1日 $10課金された件",
    "date": "2012-05-08",
    "categories": [
      "AWS"
    ],
    "file_path": "_posts/2012-05-08-post.md",
    "content": "先日、Sekkaの辞書を作るためにAWSのEC2サービスを利用した。\nSekkaの辞書を作る処理は半年に1回程度しか必要にならないのだが、手元のMacBookで実行すると24時間位はかかるような重い処理だ。(CPUとメモリの両方を大量に使う)\n手元のMacBook Proは電源を入れっぱなしにしたくないので、できればどこかのサーバー上で処理したかった。\n一般的にいって、こういう用途にAWSのEC2はぴったりだ。Microインスタンスを使えば課金はタダのような値段だ。(少なくともそのハズだった)\nしかし、EBSの重量課金の罠にハマってしまったので、広く失敗事例を公開しておこうと思う。\nMicroインスタンスでスラッシング発生\n上記のような根拠でEC2のMicroインスタンスを使ってSekkaの重い処理を実行開始した。\n急ぎでもなかったので、バッチを開始して1週間くらい放置しておけばできあがっているだろうと気楽に考えていた。\n実際、1日放置してみたが、進捗状況から、あと6日前後で処理は完了することが推測できた。\n2日間放置したところで、たまたまAWSの課金状況を他の件(DynamoDBがどうなってるか気になった)で確認することがあり、EBSの課金がとんでもないことになっているのに気がついた。\n以下が画面キャプチャ。\n\nなんと、EBSのI/Oリクエストで1日 $10程度課金されていた。(後で、AWSの\"Account Activity\"からCSVを出力して詳細な操作ログを確認したが、本当に1日 $10相当のI/Oがあった)\n心当たりはスワップしか無い。\nSekkaの辞書作成用処理はメモリを1.5GByte程度消費するので、常時1GByte程度がスワップアウトする計算になる。\nスワップパーティションはEBSを2GByte割りあてており、1GByte程度が常時スラッシングしていたに違いない… なんということだ…\nEBSのI/Oリクエスト回数はどうせ安いだろうと気にしたこともなかったので盲点であった。\nもし、7日間放置していたらどうなっていたことか… 単純計算で$70になるじゃないか…\nEC2でのスワップはどこに確保すべきか\n少しググってみたが、OSのスワップ領域をEBS以外に取る方法は見つけられなかった。\n大勢の人がEBS上にmkswapしているようだ。\nくれぐれもその方達のMicroインスタンスがスワップしないことを祈ろう。\nエフェメラル領域に確保すれば良いのかもしれないが、Microにはエフェメラル領域は無い。これも重ねて落とし穴にハマりやすい仕様になっている。\n解決策は？\n基本はEC2ではスワップさせないこと。\n一時的にスワップするのは問題無いが、何日もスワップする場合は使い方が間違っている。\n一つ上のスペックのインスタンスタイプを使ってスワップしないメモリ容量を確保しよう。\nまとめ\nEC2ではスワップさせていけない。\nスワップしても長時間はダメ。EBSへのI/Oリクエスト課金がEC2のコンピューティング課金を上まわる。\n\nコメント by そういえば:\n少し高いですがSSDのEBSでは、I/Oリクエスト課金がなくなりました。\nhttp://aws.amazon.com/jp/ebs/details/\n新しいt2.microインスタンスは、メモリが1GBになっている点もいいですね。\n\nコメント by kiyoka:\n本当ですね。情報ありがとうございます。\nSSDのEBSでは1GB単位で予めI/O料金を含んでいるんですね。\nhttp://aws.amazon.com/jp/ebs/pricing/\nコメント by そういえば:\n少し高いですがSSDのEBSでは、I/Oリクエスト課金がなくなりました。\nhttp://aws.amazon.com/jp/ebs/details/\n新しいt2.microインスタンスは、メモリが1GBになっている点もいいですね。",
    "url": "/2012/5/8/2012-05-08-post/"
  },
  {
    "id": "2012-05-17-post",
    "title": "「幸福」になる方法を教えてくれるTEDのプレゼン",
    "date": "2012-05-17",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2012-05-17-post.md",
    "content": "ゴールデンウィークに見たTEDのプレゼンの中で気に入ったものを自分用にメモしておこう。\nいつかもう一度見たくなるはず。\n人間はどのような時に「幸福」を感じるかを研究している人達がわかりやすく教えてくれている。\n全部日本語字幕があるので御安心を。\nVideo\nミハイル・チクセントミハイ フローについて | Video on TED.com\nショーン・エイカー 「幸福と成功の意外な関係」 | Video on TED.com\nマーティン・セリグマンのポジティブ心理学 | Video on TED.com\n参考記事\n「フロー体験」理論のあまりの凄さに戸惑いを隠せない：YLOGオルタナティブ：ITmedia オルタナティブ・ブログ",
    "url": "/2012/5/17/2012-05-17-post/"
  },
  {
    "id": "2012-05-19-post",
    "title": "Sekka 1.1.1.pre リリース",
    "date": "2012-05-19",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-05-19-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 1.1.1.preをリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nリリースの概要\nだいぶ安定してきたので、もうしばらく使って1.2.0にしたいと思っています。\npreリリース版であるため、次のように \"--pre\" オプションを付けないと 1.1.1.pre はインストールされません。\ngem install sekka --pre\n\n従来通り、最新版は次のコマンドで\ngem install sekka\n\n1.0.0(安定板)がインストールされます。\n以下リリースノートです。\nversion 1.1.1.pre\n\n.sekka-jisyoファイルに次の平仮名フレーズの書式を追加した。\n 既存仕様\n ひらがな //改行\n 追加使用\n ひらがな改行\nsekka-serverに辞書バージョンの整合性チェック追加した。\n\n次の目標\n他に開発したい別事案が発生したので、Migemoインタフェースの開発は保留にしました。\nすみません。しばらく別アプリに注力します。",
    "url": "/2012/5/19/2012-05-19-post/"
  },
  {
    "id": "2012-05-20-post",
    "title": "MacOS X Lion上のsvnで濁点付きのファイル名を扱えるようにする方法",
    "date": "2012-05-20",
    "categories": [
      "OSS"
    ],
    "file_path": "_posts/2012-05-20-post.md",
    "content": "自分は本ブログ(というかWiki)をSubversionで編集しており、濁点付きのファイル名も扱う\nMacOS X をLionに上げた時に、折角パッチを当てていたsvnを消されてしまった。\nだが、すぐに次の情報が見つかった。\n Mac用SubversionクライアントsvnXで濁点付きのファイルを扱えるようにする - backyard of 伊勢的新常識\n自分的にはこの1行だけが重要。最近はMacPortsがパッチを作ってくれているのか。便利な時代になったなぁ。\nsudo port install subversion +unicode_path",
    "url": "/2012/5/20/2012-05-20-post/"
  },
  {
    "id": "2012-05-22-post",
    "title": "コンプガチャ問題で気付いたこと",
    "date": "2012-05-22",
    "categories": [
      "Internet"
    ],
    "file_path": "_posts/2012-05-22-post.md",
    "content": "今、世間ではコンプリート・ガチャの問題がホットだ。\n悪い側面ばかりが強調されているが、一歩引いてみると興味深いことに気がついた。\nそれは、たんなるbitであっても希少性のある情報には高い金を払う人がたくさんいるということ。しかも１０万円、２０万円というお金を出す人もいる。\nこれは今後、クラウド上に置かれた音楽や映画など、コンテンツ全般に対して、限定版などのプレミアム価格を値付けして販売できるということを意味するのでは無いかな。\n\n将来、１０万円や２０万円のデータを閲覧する権利なんかが売られるかもしれない。\n特定のアーティストのライブを観る権利とか、他に良い例が思いつかないけど…\nあれ？コピーしてもデータ単体で使えてしまうものではダメか…\nプラットフォームの上で行使できる権利をプレミアム価格で販売することが可能ということかな。",
    "url": "/2012/5/22/2012-05-22-post/"
  },
  {
    "id": "2012-05-30-post",
    "title": "Sekka 1.1.3.pre リリース",
    "date": "2012-05-30",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-05-30-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 1.1.3.preをリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nリリースの概要\n辞書の容量削減のため、AZIK対応版とAZIK非対応版にわけました。\n環境変数 SEKKA_AZIKが定義されている時だけAZIK対応版がインストールされます。\nちなみに私はAZIKを使ってないため、小さいほう(AZIK非対応版)を使っています。\nだいぶ安定してきたので、もうしばらく使って1.2.0にしたいと思っています。\npreリリース版であるため、次のように \"--pre\" オプションを付けないと 1.1.3.pre はインストールされません。\ngem install sekka --pre\n\n従来通り、最新版は次のコマンドで\ngem install sekka\n\n1.0.0(安定板)がインストールされます。\n以下リリースノートです。\nversion 1.1.3.pre\n辞書データの圧縮を行なった。\n- 辞書バージョン1.2.2\n-- キーの圧縮\n マスター辞書のユーザ名 MASTER という文字列を M 1文字に、\n デリミタ :: を : 1文字にした。 \n サイズ (MacOS X 64bit上 : Tokyo Cabinet version 1.4.47 for Mac OS X)\n 圧縮前 version 1.2.0\n SEKKA-JISYO.SMALL.tsv 0.37GByte 399549310 Byte\n SEKKA-JISYO.SMALL.tch#xmsiz=256m 0.59GByte 631434784 Byte\n Redis-2.5.8 の消費メモリ 1.47GByte\n 圧縮後 version 1.2.1\n SEKKA-JISYO.SMALL.tsv 0.30GByte 322684820 Byte 19%減\n SEKKA-JISYO.SMALL.tch#xmsiz=256m 0.50GByte 545817488 Byte 13%減\n Redis-2.5.8 の消費メモリ 1.40GByte 5%減\n-- AZIK非搭載の辞書を用意した。\nAZIKの不要なユーザーはより少ないメモリ消費量で利用できる。\n サイズ\n AZIKを含むもの SEKKA-JISYO.SMALL.A.tsv\n Redis-2.5.8 の消費メモリ 1.40GByte\n AZIKを含まないもの SEKKA-JISYO.SMALL.N.tsv\n Redis-2.5.8 の消費メモリ 0.46GByte 67%減\n-- 環境変数\nexport SEKKA_AZIK=1\n\nが定義されている時だけAZIKを含む辞書が選択される。\n設定無しではデフォルトのAZIK非搭載の辞書がインストールされる。\n次の目標\n他に開発したい別事案があるので、Migemoインタフェースの開発は保留にしました。\nすみません。しばらく別アプリに注力します。",
    "url": "/2012/5/30/2012-05-30-post/"
  },
  {
    "id": "2012-07-29-post",
    "title": "タイムゾーンをUTCで運用するノウハウ",
    "date": "2012-07-29",
    "categories": [
      "Dropbox"
    ],
    "file_path": "_posts/2012-07-29-post.md",
    "content": "Dropboxの運用で、細かいけれど役に立つノウハウが書かれていたのでメモ。\nDropboxはDBから何から内部のタイムスタンプはUTCを使っているらしい。\nDropbox のスケールとか -- Kosei Kitahara's Blog 経由\n Rajiv's blog - Scaling lessons learned at Dropbox, part 1\n UTC\n Keep everything in UTC internally! Server times, stuff in the\n database, etc. This will save lots of headaches, and not just daylight\n savings time. Some software just doesn't even handle non-UTC time\n properly, so don't do it! We kept a clock on the wall set to UTC. When\n you want to display times to a user, make the timezone conversion\n happen at the last second.\nポイントは、「We kept a clock on the wall set to UTC.」というところ。\nちなみに自分が今開発中のソフトウェアは、内部のタイムスタンプを全てUTCで保持しているので早速採用。自分の腕時計をUTCに設定した。\nこれで、ログが何時間前かがわかりやすくなった。ちょっとした工夫でも効果抜群。\n24時間時計なので、意外とサマになったり。",
    "url": "/2012/7/29/2012-07-29-post/"
  },
  {
    "id": "2012-08-11-post",
    "title": "Kyoto.Lisp Hackathon でやったことのまとめ",
    "date": "2012-08-11",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2012-08-11-post.md",
    "content": "Kyoto.lisp Hackathon #1 に参加してきた。\n\nKyotoでLisperが10人以上集ったのだけど、他の大きなイベントとぶつかっていたわりにはよく集ったのかも。\n私は、前からやってみようと考えていたRuby 2.0(Trunk)のlazyをNendoで簡単に使えるようにする拡張にトライした。\n解決したいこと\n大きなテキストファイルを処理する際、メモリを節約するために逐次処理を意識した汚いコーディングに書き直すことがある。\nこれをなんとか、手続き型スタイルに書き直さずに関数型スタイルのまま、内部ではメモリ効率の良い処理をしてくれないか。\nそんな都合の良い方法が見つかったのでトライしてみた。\n遅延評価されたEmumerableを使えば思ったような効果が期待できると考えた。\nHackathon後、家に帰ってからコードを整理していくつかの勘違いも正すことができたので、ここに実験結果を書いておく。\n後日、大袈裟な解決方法だと気がついてボツにしたコードも掲載し解説する予定。\n実験対象のプログラム\n約100MByteのテキストファイルを読み込んで加工・出力する、いわゆるフィルタプログラムで実験した。\n書き捨てプログラムでは一番よく出てくるパターンだ。\n効果\n既存の仕組みだと、全ての入力行をプロセスにいったん蓄積するので、プロセスのピークメモリが大きい。\neagar.nndが、(f.readlines)した一番メモリを使う例。\ngenerator.nndが、(f.lines)でジェネレータスタイルで書いた例。\nlazy.nndが、Ruby 2.0のlazyを使った例。1.9.3ではLazyの機能が無いので自動的にフォールバックして遅延評価なしで動いている。\n\nコード解説\n* eager.nnd\nexample #1 eager filter — Gist\n赤色の部分は入力ファイルの全ての行をメモリ中に保持する。\n全ての行を \"\" で囲んだ中間データもメモリ中に保持するので、入力行の２倍のメモリを消費する。\n\n* generator.nnd\nexample #2 filter with generator — Gist\n青色の部分(入力ストリーム)をジェネレータにして、入力行を全て読み込まないようにする。\n但し中間データは入力行数分のメモリを消費する。\n\n* lazy.nnd\nexample #3 lazy filter — Gist\n入力ストリームをlazy指定するとlazyが伝搬する。緑色の部分はlazyなvectorとなっている。\nこのプログラムでは、どんなに入力テキストデータが巨大になってもメモリは60MByte程度しか消費しない。\nしかも、関数型プログラミングスタイル(高階関数のチェーンによる宣言的プログラミング)が維持できている。\n\n今後の予定\n実験がうまくいったので、lazy-vectorという関数はそのままリリースする予定。(Nendo 0.6.5)\nただし、srfi-1のtakeなどの多くの関数がlazy-vectorをサポートしないとNendoの処理系全体での旨味が出し切れないので順次対応していく。Nendo 0.6.6以降かな…\n学び\nやっぱりブログ記事で文章化しないと、成果はまとまらないことを実感した。\n今後はHackathon中もブログ(またはDokyumentoj)を書きながら頭を整理して作業しようと思う。",
    "url": "/2012/8/11/2012-08-11-post/"
  },
  {
    "id": "2012-08-12-post",
    "title": "Kyoto.Lisp Hackathon で作ったけどボツになったコード",
    "date": "2012-08-12",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2012-08-12-post.md",
    "content": "Kyoto.lisp Hackathon #1 に参加してきた。\n\n話としては([kiyoka.2012_08_11]NendoLisp Kyoto.Lisp Hackathon でやったことのまとめ) の続き。\n本エントリの目的は、Hackathon当日の作業のうち直近ではボツだが、今後再利用できそうなテクニックをメモしておくこと。\n次のような場面で使うスペシャルフォームをマクロ定義した。\nちょっと恣意的な例ではあるが、長いベクタに対して高階関数による多段処理をする例だ。\n大きなテキストファイルをまるごと読み込んだArrayも長いベクタになるので、実用的なプログラミングでも良く出てくるパターンだ。\n入力データは巨大だが、最終的に takeメソッドで最初の数要素のみ使い、あとは不要な場合は遅延評価を使って無駄な計算は省きたい。\n(use srfi-1)\n\n(let (*vec (Range.new 0 1000000)*)\n (for-each\n print\n (. \n (map\n (lambda (x) (sprintf &quot;&quot; x))\n (filter\n (lambda (num) (&quot; x))\n (filter\n (lambda (num) (&lt; num 100))\n vec))\n take 5))))\n\nそれを実現するのがHackathon当日に書いた次のマクロ。\n健全なマクロを使っている。コードが長いので、gistに貼りつけた。\n lazy special form sample — Gist\nあとは%lazy-map、%lazy-for-each、%lazy-filterを関数で実装すれば、(lazy S式)で囲った中身のmap、for-each、filterの実装をlazy版に差しかえることができる。\n便利そうな気もするが、影響範囲が大きいわりにはメリットが少ないような気もして、現段階では自分で(lazy-vector vec)する上の案に落ちついた。\nそれに、Nendoのsyntax-rulesはchibi-scheme 0.3からsyntax-rulesの実装のポーティングだが、ネストした \"...\" が扱えないという問題もあり、すっきり定義できていない。\nこのあたりも今後の課題として残る。\nただ、このテクニックを使ってpure(副作用無しのコードブロック宣言)も実現できるんじゃないかと考えているので、今後はそちらを試す予定。\npureのアイデアについてはこちらの過去記事を参照のこと。\n [kiyoka.2011_10_07]NendoRuby コードブロックに副作用が混在するかを検出できるかどうか\nこういう、できるかどうかわからないけど試す価値のある実験は１日かけて作業するHackathonが向いていると思った。",
    "url": "/2012/8/12/2012-08-12-post/"
  },
  {
    "id": "2012-08-14-post",
    "title": "Sekka 1.2.0 リリース",
    "date": "2012-08-14",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2012-08-14-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 1.2.0をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nお待たせしました。\n安定板を出すまで長くかかってしまいました。\nリリースの概要\n前回の安定板 Sekka 1.0.0 からの変更点はAZIKデータを標準辞書から外し、メモリ消費量を減らしたことです。\nもちろん、AZIKを使いたい方は環境変数を指定すればAZIK入りの辞書もセットアップできます。\nしかし、ほとんどの人はAZIKは不要でしょう。\nまた、曖昧検索用のインデックスとして、distributed-trie を使うようにしました。\nこれにより、検索レスポンスのムラを無くし、時々重くなる問題を解決しました。\n以下リリースノートです。\nversion 1.2.0\n\nversion 1.1.4 preからの変更無し\n\nモードの無いSKKの世界を試してみたい方、是非トライしてください。\n リンク: [Sekka]",
    "url": "/2012/8/14/2012-08-14-post/"
  },
  {
    "id": "2012-09-08-post",
    "title": "日本語IMEを作る責任について",
    "date": "2012-09-08",
    "categories": [
      "日本語"
    ],
    "file_path": "_posts/2012-09-08-post.md",
    "content": "身の振り方を考えるついでに、日本語について考えた - アスペ日記\nこの方のエントリを読んでいると、安易にIMEを作っている自分を振り返ってしまう。\n自分はそこまで深く考えてIME作ってないよ。\n自分も[Sekka]というIME(日本語入力システム)を作っているけど、日本語(というか漢字)は得意では無いし、日本語を大事にするほうでもない。\nそれでもIMEを作っているのは、自分の思い通りに入力できるものを作れないかという想いから作っている。自分だから自分の満足するものを作れると。\nだがしかし、視点を外に向けてIMEありきの世界で今後日本語がどのように書かれるかまでは考えたことは無かったなぁ。\nこの方のように日本語にこだわる人は、自分で全てを掌握できるSKKや[Sekka]を使えば良いのだろうけど、そこで止まっていないところが凄いというか尊敬するというか救いがたい。\nいろんな意味で、今後どのような記事が書かれるのか気になる存在となってしまった。",
    "url": "/2012/9/8/2012-09-08-post/"
  },
  {
    "id": "2012-09-12-post",
    "title": "static linkしたアプリケーション配布の時代は終わったのだろうか",
    "date": "2012-09-12",
    "categories": [
      "Linux"
    ],
    "file_path": "_posts/2012-09-12-post.md",
    "content": "LinuxにはたくさんのDistributionがある。\n昔は配布するビルド済みバイナリを1種類にしたい場合はglibcをstatic linkしたバイナリを配布するのが一般的だったように思う。\n２００５年くらいのMySQLはstaticバイナリを配布していて、rpm以外のディストリビューションの場合はそれを選べた。(Debianとか)\n最近ではMySQLはrpmパッケージしか配布していない。\nJDK\nJDKはどうかと調べてみたら、JDK-1.7.0_05にはtar.gz版バイナリも置いてあったので中身を調べてみた。\n64bit版のJDK-7u7\n $ tar zxf jdk-7u7-linux-x64.tar.gz\n $ cd jdk1.7.0_07/bin\n $ ldd java\n linux-vdso.so.1 =&gt; (0x00007fff4cdff000)\n libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007fd4cc205000)\n libjli.so =&gt; /home/kiyoka/Dropbox/temp/jdk1.7.0_07/bin/./../jre/lib/amd64/jli/libjli.so (0x00007fd4cbfee000)\n libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007fd4cbdea000)\n libc.so.6 =&gt; /lib/libc.so.6 (0x00007fd4cba88000)\n /lib64/ld-linux-x86-64.so.2 (0x00007fd4cc431000)\n $ ldd javac\n linux-vdso.so.1 =&gt; (0x00007fff7e3ff000)\n libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007f413512c000)\n libjli.so =&gt; /home/kiyoka/Dropbox/temp/jdk1.7.0_07/bin/./../jre/lib/amd64/jli/libjli.so (0x00007f4134f15000)\n libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007f4134d11000)\n libc.so.6 =&gt; /lib/libc.so.6 (0x00007f41349af000)\n /lib64/ld-linux-x86-64.so.2 (0x00007f4135358000)\n\nネットの情報をあさってみたが、最近のglibcはもうstaticリンクできないようだ。\nJDKもglibcのstaticリンクはあきらめているようだが、これで、どのDistributionでも動くのかなぁ。なんか不安だなあ。\nRubyは？\nさて、自分が作りたい全方位Distribution対応Rubyバイナリはどうすれば作れるか。\nDebian squeeze(64bit環境)でオプション無しのconfigureで ruby-1.9.3-p194 をビルドすると次のようになる。\n (1) ./configure 版\n $ ldd ./ruby-1.9.3-p194/bin/ruby\n linux-vdso.so.1 =&gt; (0x00007fffc25ff000)\n libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007fc720431000)\n librt.so.1 =&gt; /lib/librt.so.1 (0x00007fc720228000)\n libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007fc720024000)\n libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0x00007fc71fded000)\n libm.so.6 =&gt; /lib/libm.so.6 (0x00007fc71fb6a000)\n libc.so.6 =&gt; /lib/libc.so.6 (0x00007fc71f808000)\n /lib64/ld-linux-x86-64.so.2 (0x00007fc72065d000)\n\n(2) ./configure --with-static-linked-ext --disable-shared\n かつ、ext/Setupを次のように変更したバージョン\nこれは、拡張ライブラリがruby本体にスタティックリンクされるオプションのようだが…\n $ ldd ruby\n linux-vdso.so.1 =&gt; (0x00007fff554f3000)\n libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007fdf7e270000)\n librt.so.1 =&gt; /lib/librt.so.1 (0x00007fdf7e067000)\n libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007fdf7de63000)\n libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0x00007fdf7dc2c000)\n libm.so.6 =&gt; /lib/libm.so.6 (0x00007fdf7d9a9000)\n libc.so.6 =&gt; /lib/libc.so.6 (0x00007fdf7d647000)\n /lib64/ld-linux-x86-64.so.2 (0x00007fdf7e49c000)\n\nあれ？ 結局glibc部分はshared objectにリンクされるのはかわないのか…\nというわけで、staticリンクはあきらめた。\n解決策\n要は、ユーザーのLinuxシステムがどのようなミニマム構成であっても自分のプログラムが動いてほしいということなのだ。opensslとかgdbmとかを使いたい。\n実は、必要な *.so を自分でビルドしいっしょに配布すればよいのだった。\nそして起動スクリプトで、LD_LIBRARY_PATHの先頭に、パスを追加すればよいだけだ。\nうっかり深入りする前に気がついてよかった…",
    "url": "/2012/9/12/2012-09-12-post/"
  },
  {
    "id": "2012-10-29-post",
    "title": "リリースラッシュ",
    "date": "2012-10-29",
    "categories": [
      "Life"
    ],
    "file_path": "_posts/2012-10-29-post.md",
    "content": "世の中はいろんなWindows8やらApple製品やらの新製品発表で溢れかえっている。\nそんな中、自分に関係した もしくは 興味のある製品のほうもリリースされまくっている。\nRedis 2.6\nJRuby 1.7\nDynamoid 0.5\nもうすぐ Rails 4.0\nKindle Paperwhite\nSekka/Nendo/PasteHubを新しいバージョンで動かしてみたい。\nもしかしてJRubyがマルチバイトを正しくサポートできていたらNendoで日本語が通るかもしれない。\nそうすると、SekkaもJavaプラットフォームで動くのではないだろうか。とか。\nはたまた、Railsは4.0を使い始めるべきか？\nだいぶ先だと思っていたRuby 2.0も気がついたらリリースされるんだろうなあ。\n一遍にいろんなものが来た。追いてかれそう…",
    "url": "/2012/10/29/2012-10-29-post/"
  },
  {
    "id": "2012-10-31-post",
    "title": "[BOOKSCAN(ブックスキャン)](http://www.bookscan.co.jp/)で本をスキャンしてもらった",
    "date": "2012-10-31",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2012-10-31-post.md",
    "content": "スキャンが完了した本はこんな感じで本棚に半年置いてくれる。\n1ヶ月約1万円で50冊までスキャンしてくれるプレミアム会員になった。1ヶ月だけだけど。\nそれにしてもマニアックな本ばっかりあるなぁ。\nここには約30冊ある。OCRオプションを付けているが、どれくらいのサイズになるかが気になる。\nこれからサイズを計算してみる予定。\nKindleのPersonal Documentスペースには何冊入る計算なのかがポイントだな。",
    "url": "/2012/10/31/2012-10-31-post/"
  },
  {
    "id": "2013-03-16-post",
    "title": "平仮名フレーズ辞書を入れかえたい",
    "date": "2013-03-16",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2013-03-16-post.md",
    "content": "日々使っているとSekkaの平仮名フレーズ辞書に不満が出てくる。\nあまりに、口語体の表現が多く含まれているので、固めの文章を書いているときにも、口語体の表現が出て、うっかり確定してしまう。\nそれを直すのがめんどくさい。\nなんとかならんのか…というのが発端。\nたとえば、「…かもな」 みたいなフレーズがひょっこり出てきたりする。\n例えば、Sekka 1.2.1で「だったのかも」と打ちたくて「dattanokamo」Ctrl-Jと入力すると、「だったのかもな」が出てくる。\n友達同士で使うような最後の「ね」とか「な」とかのフレーズは辞書に入っていて欲しく無い。\nもし入れるなら「ね」とか「な」が無い「だったのかも」が一緒に入っているべき。そうすれば、「だったのかも」が第一候補になる。\nただ、WebコーパスではWebのコンテンツを収集しているだけなので、それらが全てセットになっていることを保証することはできない。どれが含まれてどれが含まれないかは確率になる。\nということは、そのような口語体の表現を含まないコーパスである程度分量があるものが必要となる。\n2013年の今日ならそのような n-gram コーパスはあるんじゃないか。または、簡単に作れるんじゃなか。例えばウィキペディア日本語版とか。\nというわけで、久しぶりに大規模データマイニングをしてみようかなと思う。",
    "url": "/2013/3/16/2013-03-16-post/"
  },
  {
    "id": "2013-03-23-post",
    "title": "平仮名フレーズ辞書の入れかえ成功",
    "date": "2013-03-23",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2013-03-23-post.md",
    "content": "Wikipedia日本語版のテキストデータを使って平仮名フレーズを作った。\nこれまで使っていた日本語ウェブコーパス 2010は廃止した。\n結果、先日のエントリ「[kiyoka.2013_03_16]Sekka辞書 平仮名フレーズ辞書を入れかえたい」で書いたように口語体の表現が少なくなり、固めの文章が書きやすくなった。\nさらに、もう一つメリットがあって、辞書のライセンスがわかりやすくなった。\nWikipediaはGFDLなので、はれて[Sekka]の辞書は全て次のオープンな素材から生成された辞書となった。\n\n平仮名フレーズ1 = Wikipedia\nGPDL。\n\n平仮名フレーズ2 = IPADic \nBSDライセンスに近い？ 但しDeibanでは non-freeに分類されているらしい。\n\n日本語と片仮名 = SKKの辞書\nGPL2。\n\nというわけで、前よりもDebianなどのディストリビューションに入れやすいものになった。\n一週間くらい使ってみて、Sekka 1.3.0と一緒に公開する予定。",
    "url": "/2013/3/23/2013-03-23-post/"
  },
  {
    "id": "2013-05-13-post",
    "title": "TAPL 型システム入門",
    "date": "2013-05-13",
    "categories": [
      "本"
    ],
    "file_path": "_posts/2013-05-13-post.md",
    "content": "この本良さそう。第一章「はじめに」が無償公開されていたので読んでみた。\n型システム入門 プログラミング言語と型の理論 | オーム社eStore(β)\n[Nendo]に副作用「あり」か「なし」だけでも型チェックさせよう思って、もう１年以上。\n自分の知識の土台が無いので、どこから手を付けて良いものかさっぱりで止まっていた。\nHaskellの本を読んでもなんか関数型に偏りすぎてて、なんか釈然としなかった。\nそこに来てこの本。\n第一章を読むだけで自分の疑問に答えてくれそうな趣きなので、オーム社からPDF版を買った。(もう少しで紙版を買いそうになってPDFがあるのを知った)\n少し高いけどそんなことは気にならない。\nなんか久々にプログラミングのレベルが上がりそうな予感です。",
    "url": "/2013/5/13/2013-05-13-post/"
  },
  {
    "id": "2013-09-03-post",
    "title": "後方一致辞書の実験",
    "date": "2013-09-03",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2013-09-03-post.md",
    "content": "[Sekka]を2008年に作ってからずっと使っているのだけど、ほぼ毎日使っていると不満が出てくるものだ。\n\n最近、重い腰を上げて挑戦したのが、単語の前方からだけでなく、後方からも曖昧辞書検索するという実験だ。\n結果は良好で、さらにミスタイプを救ってくれるようになった。\nSekka-1.2.4までは、1文字目のミスタイプは救ってくれなかった。\n例えば、「日本語変換」と入力する場合、\nNihongohenkan\n\nと打つのが正解だが、\nihongohenkan\n\nと打ってしまったとする。\nSekka-1.4.0(リリース予定版)では変換候補に「日本語変換」も出てくるようになる。Sekka-1.2.4では出てこない。\nミスタイプは、入力文字の前半だろうが後半だろうが同じ確立で発生するのだから、同じように救済するのが正しい。\nしばらく評価期間置いて安定したらリリースする予定。",
    "url": "/2013/9/3/2013-09-03-post/"
  },
  {
    "id": "2013-09-09-post",
    "title": "Sekka 1.4.0 リリース",
    "date": "2013-09-09",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2013-09-09-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 1.4.0をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nしばらく使ってみて安定しているようなのでリリースしました。\n1.4.0では、さらにミスタイプに寛容になりました。\nモードの無いSKKの世界をお試しください。\nなお、AZIK対応辞書ですが、あまりにもサイズが大きくなってきたので配布しました。\n必要あれば再度サポートしますので、フィードバックお願いします。",
    "url": "/2013/9/9/2013-09-09-post/"
  },
  {
    "id": "2013-09-10-post",
    "title": "副作用の無いコードの静的解析について(1)",
    "date": "2013-09-10",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2013-09-10-post.md",
    "content": "だいぶ前に、[Nendo]に型検査を入れて副作用の無いコードを静的解析で保証したいという話題を書いた。\n ( [kiyoka.2011_10_07]NendoRuby コードブロックに副作用が混在するかを検出できるかどうか )\nあれから時間が経ったけど、諦めずに考えているのであった。もう２年も経ったのか…\n最近TAPL(第８章、第９章)を読んで、理論的なところを知ると、いろいろ気づいたので自分用のメモとして書いておく。\n欲しい機能\n[Nendo]にどんな機能を追加したいかというと、\n(pure S式)\n\nと書くと、コンパイル時に静的解析して「S式の中に副作用が無いことを保証してくれる」機能だ。\n例えば、次のコードは静的解析で実行前にエラーとなる。\n(pure\n (define a 0)\n (set! a 1))\n\n次。func1からの関数呼び出しがどれだけ深かろうが静的に検査して欲しい。\n(pure\n (func1))\n\nまた、次のコードは副作用が無いと判断し、エラー無しで通って欲しい。\n(pure\n (define lst '(1 2 3))\n (define result\n (map\n (lambda (x)\n (+ x 1))\n lst)))\n\nただ、そう簡単にはいかないのが世の中というもの。\n問題点\n\nアノテーションの記述量が膨大になる\n\n静的解析するためには、事前に型情報のようなものが必要となる。\n型情報といっても、副作用が無いと考えられる関数全てに「pure」の注釈を付けるだけなので、StringやIntegerなどの型情報は不要だ。\n最低限、pureな全ての関数には必要。\nこれはなかなか膨大な作業で、関数を定義するたびに注釈を付ける必要がある。\nなんとか半自動でやる方法は無いものかなぁ。\n\n構文にも型情報が必要\n\nif や cond 、let let* などの規定の構文(syntax)にも型情報が必要。\nこれは関数とは別に特別扱いで処理する必要がある。\n\nRubyのメソッドディスパッチの問題\n\nNendoは、残念なことに次のような記述を許してしまっている。\n(str.chomp)\n\nstrという変数がRubyのString型であると判別できないと、chompというメソッドがString#chompだとはわからない。\nこれは、Nendoが動的型付け言語なのでstrがRubyのどの型なのか簡単にはわからないため。\n静的解析できるようにするためには、strの型をアノテーションしてやらないいけないが、こいつはプログラマに余分な手間をかけさせてしまう。\nお手軽にやりたいので、アノテーション無しにしたいところ。\n解決策は、(str.chomp)のような 「. (ドット)によるメソッドコンビネーションは使えない」とすることかな。\nその場合は、pureなchomp関数を定義する必要がある。\n(chomp str)\n\n自分が過去に書いたコードでも、str.sizeは多様している気がするので、そこは書き直す必要がある。\nその他(備忘録)\n\nデバッグ出力は特別扱い\n\n#?=S式\n\nという形式のデバッグ出力は、標準エラー出力にデバッグ表示するという副作用があるのだが、気軽にデバッグ出力を入れたいので型検査結果として「副作用なし」としたい。\nおわりに\n[Nendo]はSchemeのサブセットであり、最初から静的型付けの言語とは反対の性質を持っているので、後付けでどこまでできるかという問題になりそうだ。\nまあ、実際にはやってみないと何が出るかわからんというところですな。\nただ、JavaScript界隈では先駆者が多く存在し、JSX、Dartは型はoptionalで、指定が無ければ型推論で補うようになっているなど、参考にできるものはたくさんありそう。\nTAPLを読むだけでなく、先行技術も調査しないといけないなぁ。",
    "url": "/2013/9/10/2013-09-10-post/"
  },
  {
    "id": "2013-10-03-post",
    "title": "副作用の無いコードの静的解析について(2)",
    "date": "2013-10-03",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2013-10-03-post.md",
    "content": "前回の続き。( 前回の記事は、右上の窓から同じタイトルで検索してね )\nNendoにおける型付けについて\nによれば、静的解析をするということは、定義した評価規則と型付規則に従って評価をすることで全ての項を型付けできる。\n[Nendo]に応用し、最低限その関数が「副作用」の無い関数かを検査できるようにしたい。\n(1)ある関数が副作用の無い関数で構築されている場合は、もちろん副作用が無いといえる。\n(2)さらには、関数内の束縛関数は破壊したとしても自由変数を破壊しないのであれば、それは副作用の無い関数といってよい。\n(1)は自動的に判定することができそうであるが、(2)は人間が判断すればできるのではないか。\nそうすれば、現実的なレベルの仕様になるのではないかと考えた。\n型注釈について\n[Nendo]では上記のような基準から、「副作用無し」と「副作用有り」というどちらかの型で型付けする案を考えた。\nプリミティブな関数に型を付与し、そこからブートストラップで全てのユーザー定義関数に型を付けていこうと考えている。\nプリミティブな関数には副作用がある/なしを注釈する。 (型注釈用には :コロン が有力。 Typed Scheme: Scheme with Static Types を参考にした)\n- + の場合\n(: + Pure)\n\ncar と cdr\n\n(: car Pure)\n(: cdr Pure)\n\nset! と reverse!\n\n(: set! Unpure)\n(: reverse! Unpure) ;; srfi-1\n\n自動型付け\n上記の型注釈が付いた関数を使って、関数を構築すると自動的に型が付与される。\n少なくとも、Pureな関数だけが使用された関数はPureであり、それ以外は全てUnpureと判定すればよい。\n(define (inc1 x)\n (+ x 1))\n\n=&gt; pureな関数\n(define (fast-reverse! lst)\n (reverse! lst))\n\n=&gt; unpureな関数\n感想\nTaPLを読んでいるわりには、上記の理論を証明も何もしておらず直感でしか語っていないが、多分いけると思う。\n\nコメント by shiro:\n「定数でないグローバル変数を参照していない」という条件は必要じゃありませんか?\n\nコメント by kiyoka:\nおっと、グローバル変数がありますね。あとグローバル変数の一部だと思いますが環境変数もですね。\nSTDINとかSTDOUTとかは副作用の代表格ですね。\nコメント by shiro:\n「定数でないグローバル変数を参照していない」という条件は必要じゃありませんか?",
    "url": "/2013/10/3/2013-10-03-post/"
  },
  {
    "id": "2013-10-09-post",
    "title": "処理系開発の効用",
    "date": "2013-10-09",
    "categories": [
      "Lisp"
    ],
    "file_path": "_posts/2013-10-09-post.md",
    "content": "このエントリは二年前くらいに書いたものなのでちょっと古いのだが、もったいないので公開。\n新しい視点\nオレ処理系 [Nendo]の開発は単に楽しいからやっているのだが、開発してみるとアプリケーション開発では得られない視点が得られる。\n言語の中でもLisp処理系を作るのは貴重な体験だ。\nLisp処理系を作るためには、Lispの内部構造やプリミティブの制御構文などについて詳細に落とし込んで考える必要がある。\n自分で考えた処理系がある程度動くようになるころには、特定の言語に依存しない抽象的な脳内モデルが生まれる。\n自分は処理系を作って初めて明確な形を取るようになったが、Lispでプログラミングしただけでも脳内モデルが形成される人もいるかもしれない。\nコードの中にlambdaの存在が見えるようになる\n私の場合は脳内モデルとして、抽象的な lambda式の連鎖(lambda計算)として見えるようになった。\n以前は、PHPでプログラムをする時はPHP、Rubyでプログラムする時はRubyの見た目に近い脳内モデルだったような気がするが、最近は全部lambdaになっている気がする。\nそういえば、shiroさんのブログ記事にも似たような話があった。\n Island Life - グラフ指向理解\n で、おもしろいなあと思ったのは、私はプログラムを考える時も頭の中には\n グラフがあって、プログラムはそのグラフをテキストとしてダンプしたもの\n になっている。WiLiKi:Lisp:S式の理由で書いたけれど、だからプログラムを\n 書くときにいちいち頭の中のグラフを翻訳しなければならないプログラミン\n グ言語よりも、グラフを生に近い形でダンプできるLispの方がずっと書きや\n すい。\nでも非Lisperなプログラマに脳内グラフのことを話してみてもあまり賛同さ\n れないので、Lispを好むか好まないかの境目は案外そのへんにあるんじゃな\n いかという仮説を持っているのだけれどどうだろう。\nlambdaの連鎖で見えていることを言葉で説明するのが非常にわかりにくいのも同じかなぁ。\n図で描いたほうが良いのだろうな。\n描いて説明したところで、フウンで終わってしまってセツナイので描かないが。\n設計に役に立つこともある\n例えば、RESTベースのWebAPIを考える時や、1ページを超える長い関数を追う時、それぞれのパーツがlambda単位(クロージャ単位)に分割して見えるようになった。\n長いソース中だろうと、ブロックさえあればなんでもlambda化して切断面が見える能力。意識しなくてもコード中に切断面が飛び出して見えているような。\nうまく言えないけど便利で強力な特殊能力だと思う。\nこれは設計時、リファクタリング時に威力を発揮する。もしかしてこれが悟り体験？",
    "url": "/2013/10/9/2013-10-09-post/"
  },
  {
    "id": "2013-10-12-post",
    "title": "Lisperの楽園: 脳内モデルに一番近い島",
    "date": "2013-10-12",
    "categories": [
      "Lisp"
    ],
    "file_path": "_posts/2013-10-12-post.md",
    "content": "タイトルが、リゾートのパンフレットみたいになっているのは御愛嬌。\nどの言語よりもLispが自分に合っているようだ。\n脳内モデルを現実世界にdumpする手段としてLispがストレスが少ない気がする。\nRubyはどうなのかと聞かれてもないのに答えると(笑)、Rubyはそんなに自分の脳にぴったりフィットする感じではないのだよねー。\n熱狂的なRubyistの方々には悪いけれども、RubyコミュニティのパワーとRuby関連へのお金の流れ込むスピードは圧倒的なのでそこは利用させてもらうのだ。(腹黒いねぇ)\n時にはまとまったコードをgemとして提供することもあるけれど、メインのプログラム言語としてRubyを選択することは無いかなぁ。\nであるからして[Nendo]の「gemが使えるLisp」という路線は今後も健在なのだ。",
    "url": "/2013/10/12/2013-10-12-post/"
  },
  {
    "id": "2013-10-18-post",
    "title": "演習問題をやってみた",
    "date": "2013-10-18",
    "categories": [
      "TaPL"
    ],
    "file_path": "_posts/2013-10-18-post.md",
    "content": "TaPL読書会に向けて11章の演習問題をやってみた。\n [TaPL_exercise] \nTaPLの演習問題をまじめにやるのは結構大変だ。\nどの演習問題も証明せよと書いてあるのだが、証明しようとするとけっこう時間がかかる。\n付録の模範解答ページには証明の流れは書いておらず、例えば「構造的帰納法」を使うとしか書いてなかったりする。\nああでもない、こうでもないと寄り道してなんとか証明した気になっているが、これで合っているのかどうか。\n読書会での答え合わせの場があるのが幸いです。\n自分としては11章を読み終わったら、この本を卒業して、[Nendo]に型検査を実装する作業に時間を使いたいなぁと考えているんだけど…",
    "url": "/2013/10/18/2013-10-18-post/"
  },
  {
    "id": "2013-11-02-post",
    "title": "静的型チェックの設計メモ(1)",
    "date": "2013-11-02",
    "categories": [
      "Nendo"
    ],
    "file_path": "_posts/2013-11-02-post.md",
    "content": "自分用備忘録。\n型付けと、型チェックは2フェーズにする必要あり\n理由は、再帰的に定義された関数は自身を定義するまで自身の型が不明なので、1パス目ではチェックできない。\nサンプルコード\n;; fact\n(define (fact n)\n (if (zero? n)\n 1\n (* n (fact (- n 1)))))\n\nこのコードは、コンパイルフェーズで以下のようにマクロ展開される。\n(define fact\n (lambda (n)\n (if (zero? n)\n 1\n (%tailcall (* n (fact (- n 1)))))))\n\n上のコードで使われている関数群 zero? %tailcall * - と フォーム (if a b c) が全て副作用なしとして型付けされていたとする。\nここで、変数factの型を1パス目で型チェックしようすると、factの型が未定義なので失敗する。\n従って、1パス目でfactの型を決定してから、2パス目で型チェックをする必要がある。\n応用編\n次のようなletrecで定義された束縛変数においても同様。\n(define (append a b)\n (letrec ((append-reverse\n (lambda (a b)\n (if (pair? a)\n (append-reverse (cdr a) (cons (car a) b))\n b))))\n (append-reverse (reverse a) b)))\n\nそれにしてもこのappendの定義ってよくできているなぁ。\n誰が書いたのだろう… Chibi-Schemeから持ってきたハズ…",
    "url": "/2013/11/2/2013-11-02-post/"
  },
  {
    "id": "2014-01-26-post",
    "title": "Sekka 1.5.0 リリース",
    "date": "2014-01-26",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2014-01-26-post.md",
    "content": "SKKライクな日本語入力メソッド [Sekka] 1.5.0をリリースしました。(リリースノート [Sekka.ReleaseNote])\n\nついにWindowsでも動くようになりました。\nCygwinは不要で、RubyInstaller.org 1.9.3 上で動きます。",
    "url": "/2014/1/26/2014-01-26-post/"
  },
  {
    "id": "2014-02-12-post",
    "title": "CRuby 2.1.0の非互換性-Symbolクラスにモンキーパッチできなくなった件",
    "date": "2014-02-12",
    "categories": [
      "Ruby"
    ],
    "file_path": "_posts/2014-02-12-post.md",
    "content": "忘れないうちに[Nendo]をCRuby 2.1.0で動かすのに苦労した話を書いておこう。\n多分、SymbolにモンキーパッチしているプログラムはCRuby 2.1.0で動かなくなるので、その時に誰かの役に立つかもしれない。\nCRuby 2.1.0に持ち込まれた非互換\n.以下は、CRuby 2.0.0で動いて、CRuby 2.1.0で動かないコード\n# Symbolへのモンキーパッチ\nclass Symbol\n def set_lineno(value)\n @lineno = value\n end\n def lineno\n return @lineno\n end\nend\n\nsym1 = :a\nsym1.set_lineno( 10 )\np sym1.lineno\n\nsym2 = :a\nsym2.set_lineno( 20 )\np sym2.lineno\n\n-- 結果(ruby-2.0.0-p353)\n$ ruby symbol.rb\n10\n20\n\n-- 結果(ruby-2.1.0)\n$ ruby symbol.rb \nsymbol.rb:5:in `set_lineno': can't modify frozen Symbol (RuntimeError)\n from symbol.rb:13:in `'\n\n何がしたかったのか\n[Nendo]はRubyで実装したScheme処理系(サブセット)である。\n[Nendo] 0.6.6ではSchemeのソースコードをパースしたツリーの内部で、SchemeのシンボルはRubyのSymbol型に変換して保持していた。\nそうするメリットは絶大で、Schemeの処理系の中で:quoteのようなRubyのSymbolと == 演算子で比較できる。\nまた、同時にそのシンボルがSchemeプログラムのソースコードのどの位置(ファイル名、行番号)に出現したかを保持したい。\nつまり、同じSymbol型でも、位置情報を持っているものと持っていないものがあり、かつ、同じSymbol型として操作できる。\nRuby 2.0.0までは、乱暴だが上のようなモンキーパッチを使うことで、このトリックを実現していた。\nRuby 2.1.0\nRuby 2.1.0では上記のようなモンキーパッチは許されなくなった。\n最適化のためか、はたまた安全性のためか、その両方かもしれないが、そのような挙動になった。\npuppetも同様の問題でひっかかってpuppet側で対応したようだ。\n (maint) Fix can't modify frozen Symbol error on Ruby 2.1.0 by jeffmccune · Pull Request #2184 · puppetlabs/puppet · GitHub\nNendo 0.6.8\n[Nendo]も同様に0.6.8で地道に対応した。\nSymbolへのモンキーパッチをやめて、ParsedSymbolという型を新規に作り、RubyのビルトインSymbolとの比較箇所などを地道に修正していった。\n影響範囲は大きく、なかなか骨の折れる作業だった。\n感想\n本来はモンキーパッチは良くないコーディングだとわかっていたが、このような逃げを許してくれるのがRubyの良いところかと思っていた。\n多分、モンキーパッチを許さないことで最適化しやすくなり実行効率は高まりそうな気がするので、CRubyの進化として良いことだろう。\nただ、ちょっと固くるしいなぁと思わなくもない。\n言語が洗練するとはこういうことなのかなぁ。\n追記 ( 2/23 )\nSymbolもGCできるようにする改善だったようだ。それなら従おう。\n Feature #8906: Freeze Symbols - ruby-trunk - Ruby Issue Tracking System\n Now, Integer and Float objects are frozen objects.\n How about to freeze Symbol objects, too?\n I think Symbol is friend of Integer.\n...\n Background of this proposal:\nNow, I'm working on \"GC-able Symbols\" feature.\n Freezing symbols make this feature easier.\nfor example:\n (1) set an instance variable @iv for symbol s\n (2) collect s\n (3) generate s\n (4) what value of @iv for s returns?",
    "url": "/2014/2/12/2014-02-12-post/"
  },
  {
    "id": "2014-02-22-post",
    "title": "大きなピボット",
    "date": "2014-02-22",
    "categories": [
      "PasteHub"
    ],
    "file_path": "_posts/2014-02-22-post.md",
    "content": "PasteHub.netというコピーペーストを複数のマシンで共有するサービスを作った。\nしかし、ここへきてPasteHub.netの「コレジャナイ感」が大きくなってきた。\n自分が欲しいのは、複数のOS、複数のマシンでコピーペーストが同期されるシステムだ。\nPasteHub.netではそれだけのために、次のような手順を踏む必要があった。\n- サイトを用意\n- ユーザーアカウントを登録\n- アプリケーションをインストール\nこれはなかなか敷居が高い。\nサービスを提供する側にとっても、ユーザーにとっても。\n実際にこの敷居の高さのせいか、ツールを使う人は皆無に近かった。\nそんなわけで、しきり直しをします。\nPasteHub.netを使うには、\n- アプリケーションをインストール\nだけでいけるようにしたい。\n自分でサイトを構築・維持するのではなく、Dropboxのような共有ストレージサービスを利用しようと考えている。\nDropboxのような共有ストレージは既に誰もが使っているだろう。\n有名なドリルの喩えでいうと、「ドリルを買う理由は\"穴\"が必要だからである。ドリルが無くても、穴が得られれば良いのである。」ということだ。\n自分も\"穴\"だけが欲しいので、ここいらでピボット(方針変更)しよう思う。\n共有ストレージも、同期のタイムラグの問題などいろいろ課題は出るだろうが、それを解決できれば簡単に使えるものになるだろう。\n仕組みが単純になる分、Dropboxと連携するIFTTTなどのサービスとも連携できるなど、価値も増える。\nというわけで、いろいろ実験しながら可能性を探っていきます。",
    "url": "/2014/2/22/2014-02-22-post/"
  },
  {
    "id": "2014-02-25-post",
    "title": "新PasteHub.netは何を優先するか",
    "date": "2014-02-25",
    "categories": [
      "PasteHub"
    ],
    "file_path": "_posts/2014-02-25-post.md",
    "content": "自分用メモ。\n- インストールが簡単(設定なし)\n-- Mac/Windowsはインストーラーにてインストールするだけ。\n-- Linuxはrpm/debをインストールするだけ。\n-- Emacsはmelpaからelispをインストールするだけ。\n※ 但し、Dropbox以外のストレージサービスを使っている場合は、設定値変更が必要。\n最後のEmacsクライアントは実装がけっこう大変そうな気がするが、やってやれないことは無い。\n使うのが簡単なものほど作るのは大変というのはよくある話。\n実装が多くなるという意味で当然といえば当然なのだが…",
    "url": "/2014/2/25/2014-02-25-post/"
  },
  {
    "id": "2014-03-15-post",
    "title": "PasteHub.netは「コピペをいろんなWebサービスのハブにする」",
    "date": "2014-03-15",
    "categories": [
      "PasteHub"
    ],
    "file_path": "_posts/2014-03-15-post.md",
    "content": "PasteHub.netの大改造中。\nコンセプト\nコンセプトは「コピペをいろんなWebサービスのハブにする」にしようかと考えている。\nもう、サーバーサイドのコードはgitのmasterからきれいに削除し、Dropbox必須とした。\nおかげでクライアント側のコードも半分以上は不要となった。\nそれでも「コピペを同期する」という本来の機能の利便性と安定性が上がった。\n大改造のきっかけ\nきっかけは自分がスマートフォン(iPod touchなんだけど)を買っていろんなアプリが動くようになったことだろう。\n今迄使っていたiPod touchはとても古く、iOS 4.2までしかインストールできなかった。なにせ2014年におけるiOS 4.2というのは、とんでもない時代遅れのシロモノなのだ。\nどんなアプリ作者もiOS 6.0以上で動くアプリしか作らない(当然か…)。iOS 4.2ではTwitterクライアントはなぜか起動せず、Feedly、Safari to go 、Kindle、Evernoteは非対応だ。\nそれが一変した。\n最新のiPod touchを買ってiOS 7.xが使えるようになり、EvernoteやTwitterクライアント、Feedly、Safari to go、Kindleが動くようになった。\n今までスマートフォンのサービスがここまで便利になっているとは知らずに来たもんだから、その進化には正直たまげた。\nEvernoteもブラウザベースのWebサービスとして使っていると、それほど便利さは実感できない、なので使う意味はほとんど無い。おまけに古いiPod touchにはカメラさえ付いていないので、写真でメモを取るということもできなかった。それはEvernoteと言えるのか？…\n時代の流れとDropboxの普及\n２０１２年に作り始めたPasteHubというプログラムは、当初、コピペ情報を仲介するためのサーバーサイドを時前で持っていた。\n２０１４年の今ではDropboxが事実上の標準となり、使っていない人はいないというところまで来た。(Google DriveとかOneDriveも含めたクラウドストレージというくくりで見ると、ほぼ100%だろう)\nそんな背景もあり、Dropboxに完全依存することに決めた。\nというわけで、ぼちぼち使えるプログラムとして生まれ変わる最中です。応援よろしく。\n kiyoka/pastehub · GitHub",
    "url": "/2014/3/15/2014-03-15-post/"
  },
  {
    "id": "2014-07-16-post",
    "title": "sekka.elからpure emacsでhttp通信しようするも断念",
    "date": "2014-07-16",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2014-07-16-post.md",
    "content": "Emacsも年々進化していることだし、もうそろそろcurlコマンドを使わなくてもEmacsだけでHTTP通信できるのでは？と思ってチャレンジしてみた。\n今回はあきらめたのだが、理由を忘れそうなのでここにメモしておく。\ngibthubのSekka作業ブランチは \"http_pure_elisp\" 。\n https://github.com/kiyoka/sekka/tree/http_pure_elisp\nurl.elのリクエストが不正？な問題\nEmacs-24に入っている url.elを使ってsekka-serverにアクセスするも、webrickが400 Bad Requestを返す。\nurl-retrieve-synchronously関数の返却バッファには、200 OKのレスポンスの後ろに、400 Bad Requestのレスポンスがくっついてくるので原因がよくわからない。\ncurlコマンドからWebrickにリクエストした時は発生しないので、url.elのリクエストがRFCに準拠していないのか、Webrickの潜在バグを突いているのか…\nurl.elからのリクエスト中にEmacsのキーイベントが消費される問題\nurl-retrieve-synchronously関数を実行している間にCtrl-jを押しても効かない。\nキーイベントがどこかで消費されているのかもしれない。\ncurlコマンドをプロセス起動した場合にはそのような現象は発生しないので、url.elの作りの問題なのかもしれない。\nurl*.elで \"discard\" や \"event\" などで検索したがあやしい処理は見つからず…\nWebrickの代替が見つからない問題\nWebrickの代わりに別のRackドライバを探したが、thinくらいしか見つからなかった。\nthinを使ってみるも、Segmentation Faultで動かず断念。\nこんな感じで、あまり時間をかけていないが、一旦断念。\nまた一年後くらいに再チャレンジするかも。\nただ、curlが非常に安定していることもあって、EmacsからHTTPリクエストする場合はcurlがデファクトスタンダードになっているようだ。\nいっそEmacs本家にcurlをリンクしてくれたりいいのにと思うんだけどなぁ。",
    "url": "/2014/7/16/2014-07-16-post/"
  },
  {
    "id": "2014-09-03-post",
    "title": "LLVMが楽しい",
    "date": "2014-09-03",
    "categories": [
      "LLVM"
    ],
    "file_path": "_posts/2014-09-03-post.md",
    "content": "LLVMが普及しつつあるけど実際どうなのか\nふと思いついてLLVMについて調べ始めた。\n世間ではGoogle ChromeのPNaCLとかemscriptenやasm.jsが実用的に使われる気配が見えてきた。\nAppleのMacOS XやFreeBSDのLLVMへの傾倒を見ると、そろそろどんなものか知りたくなってきた。\nなぜか昔から自分はCross Platformの話題が好きなようで、i386で動くLinuxのエミュレーターをJavaで書いたこともある。(完全に黒歴史…)\nLLVM-IR\nCross Platformerとしての興味の対象はLLVM-IRなので、まずはここから。\nLLVM-IRの言語仕様を調べたりclangの出力するLLVM-IRのコードを眺めてみたりした。\nclangの最適化オプションを -O0 から -O3 にしてどれくらい最適化されるのかを眺めたり。\nLLVM-IRの抽象度は非常に高く読みやすく(読むものでは無いだろが)Cross Platformな話題が好きな自分にはかなり楽しそう。\n挙句の果てには、LLVM-IRのコードをEmacsLispで動かせないかと実験をしてみたりした。\nLLVM-IRをEmacsLispに翻訳\n可能性を探るためにちょっとやってみたのだが、LLVM-IRのインタプリタlliコマンド の 約1000倍の実行時間がかかることがわかった。\nということでこれで思考実験は終わり。\nこのようなCプログラムをclangでコンパイルし、LLVM-IRを翻訳したEmacsLispで動かしてみた。\n#include \n\nint main(void)\n{\n int total = 0;\n volatile int i;\n for( i = 0 ; i &lt; (1000000 * 1000) ; i++ ) {\n total += i+1;\n }\n printf( &quot;total = %d\\n&quot;, total );\n return 0;\n}\n\n\"clang -O0 -S -emit-llvm loop.c\" で出力したLLVM-IRコードもあわせて見るにはこちら。\n simple loop program.\nつぎに愚直にEmacsLispに翻訳してみたのが loop1.el \n手でちょっとだけ最適化してみたのが loop2.el \n Translate to Elisp from LLVM-IR code\nLLVM-IRをSchemeに翻訳\n愚直にSchemeに翻訳してGaucheで動かしてみたのがこちら。\nlliの100倍の時間がかかる。しかしGaucheは速い。\n Translate to Scheme from LLVM-IR code\ncmigemoをEmacsLispで走らせられないか(妄想)\ncmigemoを1000倍非力なCPUで動かすとどれくらい使えないかを測ってみた。\ncmigemoの検索クエリから正規表現への展開は1000回実行しても100ms程度で、実用的な範囲。\nしかし、mcigemoが辞書をロードする時間は1000回実行すると3分もかかる。これは実用にならない。\nっと、ここで夢から覚めて我に返った(←イマココ)\nいやー妄想って楽しいもんです。",
    "url": "/2014/9/3/2014-09-03-post/"
  },
  {
    "id": "2015-02-12-post",
    "title": "SKKライクな日本語入力システムでシフトキーを押す回数を減らしたい",
    "date": "2015-02-12",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2015-02-12-post.md",
    "content": "[Sekka]を話題にするのがあまりに久しぶりなのだが、思い立ってSekkaをさらに改善できないか検討している。\n今度は、大文字始まりのローマ字を入力しなくても単語が漢字かひらがなかカタカナかを勝手に推測してくれるというもの。\n本来、SKKライクなIMEを使っている人は、ひと手間掛けてもよいから思考を乱されるような誤変換を減らしたいという心理で使っている。\nなので、わざとひらがなで「ひらがな」と入力したいところを第一候補に「平仮名」という漢字が出てくるといやがられる。\nただ、使い易さというのはバランスなので、あまりにもシフトキーを押す回数が多い場合はそれも思考のさまたげになる。(小指が痛いというのも思考の妨げになる)\n毎回先頭大文字のローマ字を入力しなくてもよいならそれに越したことはない。\n回避策は二つあって、一つは形態素bi-gramの辞書を導入するもの。\n隣りあう形態素同士の共起頻度を使って、文脈から明らかに漢字を優先すべきローマ字は漢字候補を優先する。\n例えば、「漢字」で確定された次の単語で henkan と入力された場合でも Henkan と入力したかった可能性も考慮し 「変換」 と 「へんかん」を共起頻度の得点を積んだ上で変換候補に入れる。\nもう一つは、Ctrl-Jでの変換確定時にマウスのダブルクリックのように素早くCtrl-jを２回押すと先頭を大文字にしたとみなす。 (henkan Ctrl-j Ctrl-j」というキーストローク)\nこの案は安易すぎるかもしれないけど、意外とこういう姑息な方法でも効果があったりするのでやってみるのもよいかな。",
    "url": "/2015/2/12/2015-02-12-post/"
  },
  {
    "id": "2015-02-23-post",
    "title": "SKKユーザーを満足させるのは難しい",
    "date": "2015-02-23",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2015-02-23-post.md",
    "content": "前回の記事で、[Sekka]をレベルアップできないかという話題を書いた。\nSKKライクなIMEの特徴である、シフトキーを頻繁に押さないといけないという問題をなんとか改善できないか…\nローマ字先頭の大文字を指定しなくても快適に使えるようにならないかということを軽々しく書いた。\nSKKユーザーを満足させるのは難しい\nいろいろ試してみて、漢字とひらがなは「現段階では」人間が細かく指定したほうがよいという結論になった。「現段階では」という括弧書きだが。\nいくらIMEが賢くなってもどこかでユーザーの考えていることとくい違ってしまう。つまりそれは誤変換だ。\n本当のことをいうと、ユーザーが考えていることと完全に一致した結果を返せれば、それは誤変換は無いということになるので、完全に満足できる「賢さ」というポイントは必ずあるはずだ。\nしかし、コンピューターの能力は有限なのでどこかでその壁が来る。\n試しに、共起頻度の辞書100MByte分を追加して実験してみたが、変換中の単語の直前2語が辞書にヒットするとは限らず、どの単語が確からしいかは推定できない。(bigramとskip-bigram)\n辞書には \"日本語\" と \"変換\" は共起するという情報があるので \"日本語\"の直後の\"henkan\" は漢字の\"変換\"と推定できるが、いつもこのようにうまくいくとは限らない。\n自分の文章が必ずセオリーどおりのパターンで構成されているわけではない。辞書に無ければそれでアウトだ。\nSKKユーザーはこの「漢字」と「ひらがな」と「カタカナ」間の誤変換というのを普通の人以上に嫌うので、なかなか難しい問題だ。\nパーソナライズというもうひとつの問題\nWebコーパスなどから集計した共起頻度の辞書を使うと、例えば句読点として「、。」を使うのか「，．」を使うのかという個人設定を維持することを困難にする。\nコーパスとその人の趣向が一致しない場合、期待しない候補が選択されてしまう。(まあ、狭い範囲での解決策はいろいろあるが)\nこの点、SKKは最後の選択肢が愚直に第一候補になるので、文脈によって変換候補の順位が影響を受けない。\n結論\nSKKユーザーのように少しの誤変換も許しがたいユーザーにとって、IMEの挙動に推測はなるべく入れないほうが良い。\n恐らく、SKKユーザーを納得させることができるのは人間の知性を上まわる「強いAI」が完成した時しかありえないだろう。\n使ったデータ\n辞書は以下の2gmと3gmを使った。\n N-gram コーパス - 日本語ウェブコーパス 2010\n 形態素 N-gram 頻度 10 以上のファイルリスト 圧縮時 12.1GB，展開時 75.2GB \nGitHubの作業branch\n多分リリース予定なし。将来の約に立つかも。\n https://github.com/kiyoka/sekka/tree/ngram_dict\n感想\n自分でいうのもなんだが、SKKユーザーはなかなか頑固ものである…",
    "url": "/2015/2/23/2015-02-23-post/"
  },
  {
    "id": "2015-04-29-post",
    "title": "Daybreakというpure rubyのkey-value-storeを試してみた",
    "date": "2015-04-29",
    "categories": [
      "Sekka"
    ],
    "file_path": "_posts/2015-04-29-post.md",
    "content": "目的\nSekkaの辞書データベースとして、プラットフォームに依存しない形式は無いものかと探している。\nSekkaの辞書データは結構大きいので、Sekkaインストール時にInternetから取得する方式にしているのだけど、プラットフォーム依存だとどうしても導入時に変換が入ってしまう。\nその変換時間がバカにならない。\nできれば、ダウンロードして即動かしたい。\n現在Sekka辞書 1.6.1でサポートしているフォーマットはgdbm/TokyoCabinet/Redisで、どれもtsvからの読み込みが発生してしまう。\n結論:Daybreakはメモリ消費量が多すぎてボツ\nこれが、試しに実装してみたブランチ。リリースはしない。\n https://github.com/kiyoka/sekka/tree/daybreak_db\nin memoryデータベースなのでしょうがないとはいえ、Sekka辞書ver1.6.1では3GByteのメモリを消費してしまう。\n同じin memoryデータベースのRedisだと1.2GByte程度で収まる。\nDaybreak 0.3.0のドキュメントを読む限り、内部はRubyのHashをそのまま保持しているようだ。\nそれに対してRedisはデータ圧縮などの工夫や、その他の工夫をしているようで、メモリフットプリントが少ない。\n感想\n一般論として、pure rubyのまともなkvsは実現が困難だと思う。\nデータ量が小さいのであれば、pure rubyのHashクラスをそのまま使うのはありだろうが、ある程度データ量が増えると、どこかでDISKに退避したりメモリフットプリントを減らす工夫が必要だと思う。\n結局RedisやTokyo CabinetなどC言語などできめ細かく実装するしかないと思う。",
    "url": "/2015/4/29/2015-04-29-post/"
  }
]